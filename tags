!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  A() const { return (*this)(0,0);  }$/;"	f	class:psimag::MetricTensor
A	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      A,   \/* Looking for _rray (array)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
AKIMA_H_	PsimagLite/src/AkimaSpline.h	/^#define AKIMA_H_$/;"	d
ALLOWS_ZERO	PsimagLite/src/ChebyshevSolver.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::ChebyshevSolver::__anon114
ALLOWS_ZERO	PsimagLite/src/LanczosSolver.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::LanczosSolver::__anon122
ALLOWS_ZERO	PsimagLite/src/LanczosVectors.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::LanczosVectors::__anon113
ALMOST_EQUAL_H	PsimagLite/src/AlmostEqual.h	/^#define ALMOST_EQUAL_H$/;"	d
AR	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      AR,  \/* array    *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
AR	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      AR,  \/* Looking for __ray (array)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
ARR	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      ARR, \/* Looking for ___ay (array)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
ARRA	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      ARRA, \/* Looking for ___y (array)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
ARRAY	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      ARRAY, \/* Looking for ____( (array)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
ASSERT	PartialPsimag/PSIMAGAssert.h	/^#define ASSERT(/;"	d
ASSERT	PsimagLite/src/JSON/PSIMAGAssert.h	/^#define ASSERT(/;"	d
AXPY	PartialPsimag/BLAS.h	/^void AXPY(int size,const double &a,const double* x, int sx, double* y, int sy){$/;"	f	namespace:psimag::BLAS
AXPY	PartialPsimag/BLAS.h	/^void AXPY(int size,const float &a,const float* x, int sx, float* y, int sy){$/;"	f	namespace:psimag::BLAS
AXPY	PartialPsimag/BLAS.h	/^void AXPY(int size,const std::complex<double> &a,const std::complex<double>* x, int sx, $/;"	f	namespace:psimag::BLAS
AXPY	PartialPsimag/BLAS.h	/^void AXPY(int size,const std::complex<float> &a,const std::complex<float>* x, int sx, $/;"	f	namespace:psimag::BLAS
AXPY	PsimagLite/src/BLAS.h	/^void AXPY(int size,const double &a,const double* x, int sx, double* y, int sy){$/;"	f	namespace:psimag::BLAS
AXPY	PsimagLite/src/BLAS.h	/^void AXPY(int size,const float &a,const float* x, int sx, float* y, int sy){$/;"	f	namespace:psimag::BLAS
AXPY	PsimagLite/src/BLAS.h	/^void AXPY(int size,const std::complex<double> &a,const std::complex<double>* x, int sx, $/;"	f	namespace:psimag::BLAS
AXPY	PsimagLite/src/BLAS.h	/^void AXPY(int size,const std::complex<float> &a,const std::complex<float>* x, int sx, $/;"	f	namespace:psimag::BLAS
Abort	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      Abort,         \/* Abort Parsing            *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
AbstractRat	PartialPsimag/Symmetry/AbstractRat.h	/^    AbstractRat(): std::vector< std::pair<IntType, IntType> >$/;"	f	class:psimag::AbstractRat
AbstractRat	PartialPsimag/Symmetry/AbstractRat.h	/^  template<typename IntType> class AbstractRat: $/;"	c	namespace:psimag
ActionType	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^    } ActionType;$/;"	t	class:JsonParser::ActionsMixin	typeref:enum:JsonParser::ActionsMixin::actions
ActionsMixin	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^  class ActionsMixin {$/;"	c	namespace:JsonParser
AdditionalData	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		struct AdditionalData {$/;"	s	class:PsimagLite::KTwoNiFFour
AdditionalDataType	PsimagLite/src/Geometry/Geometry.h	/^			typedef typename GeometryTermType::AdditionalDataType AdditionalDataType;$/;"	t	class:PsimagLite::Geometry
AdditionalDataType	PsimagLite/src/Geometry/GeometryFactory.h	/^		typedef KTwoNiFFour::AdditionalData AdditionalDataType;$/;"	t	class:PsimagLite::GeometryFactory
AdditionalDataType	PsimagLite/src/Geometry/GeometryTerm.h	/^			typedef typename GeometryFactory::AdditionalDataType AdditionalDataType;$/;"	t	class:PsimagLite::GeometryTerm
AkimaSpline	PsimagLite/src/AkimaSpline.h	/^		AkimaSpline(const VectorType& x,const VectorType& s)$/;"	f	class:AkimaSpline
AkimaSpline	PsimagLite/src/AkimaSpline.h	/^class AkimaSpline {$/;"	c
AkimaSplineType	PsimagLite/drivers/akimaSpline.cpp	/^typedef AkimaSpline<VectorType> AkimaSplineType;$/;"	t	file:
AkimaStruct	PsimagLite/src/AkimaSpline.h	/^	struct AkimaStruct {$/;"	s	class:AkimaSpline
AlmostEqual	PsimagLite/src/AlmostEqual.h	/^		AlmostEqual(const RealType& eps) : eps_(eps) { }$/;"	f	class:PsimagLite::AlmostEqual
AlmostEqual	PsimagLite/src/AlmostEqual.h	/^	class AlmostEqual {$/;"	c	namespace:PsimagLite
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    AppliedSymmetryElement(): $/;"	f	class:psimag::AppliedSymmetryElement
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    AppliedSymmetryElement(const AppliedSymmetryElement& other): $/;"	f	class:psimag::AppliedSymmetryElement
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    AppliedSymmetryElement(const AppliedSymmetryElement<Field,DIM,Occupant,OtherLatticeType,Algorithms>& other): $/;"	f	class:psimag::AppliedSymmetryElement
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    AppliedSymmetryElement(int index,$/;"	f	class:psimag::AppliedSymmetryElement
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^  class AppliedSymmetryElement$/;"	c	namespace:psimag
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    AppliedSymmetryElement(): $/;"	f	class:psimag::AppliedSymmetryElement
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    AppliedSymmetryElement(const AppliedSymmetryElement& other): $/;"	f	class:psimag::AppliedSymmetryElement
AppliedSymmetryElement	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^  class AppliedSymmetryElement: $/;"	c	namespace:psimag
AppliedSymmetryElementIterator	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^     explicit AppliedSymmetryElementIterator(const AppliedSymmetryElementIterator& other):$/;"	f	class:psimag::AppliedSymmetryElementIterator
AppliedSymmetryElementIterator	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    explicit AppliedSymmetryElementIterator(const SpaceGroupType& sg, const AppliedSymmetryElementsType& allEl):$/;"	f	class:psimag::AppliedSymmetryElementIterator
AppliedSymmetryElementIterator	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^  class AppliedSymmetryElementIterator:$/;"	c	namespace:psimag
AppliedSymmetryElementIteratorType	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    typedef AppliedSymmetryElementIterator<Field,DIM,Occupant,LatticeTemplate,Algorithms> AppliedSymmetryElementIteratorType;$/;"	t	class:psimag::AppliedSymmetryElementIterator
AppliedSymmetryElementPairType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef std::pair<int,AppliedSymmetryElementType>                         AppliedSymmetryElementPairType;$/;"	t	class:psimag::GroupAction
AppliedSymmetryElementPairType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef std::pair<int,AppliedSymmetryElementType>                               AppliedSymmetryElementPairType;$/;"	t	class:psimag::GroupMultiplicationTable
AppliedSymmetryElementPairType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef std::pair<int,AppliedSymmetryElementType>                         AppliedSymmetryElementPairType;$/;"	t	class:psimag::SymmetryGroup
AppliedSymmetryElementType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> AppliedSymmetryElementType;$/;"	t	class:psimag::AppliedSymmetryElement
AppliedSymmetryElementType	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    typedef AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> AppliedSymmetryElementType;$/;"	t	class:psimag::AppliedSymmetryElementIterator
AppliedSymmetryElementType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> AppliedSymmetryElementType;$/;"	t	class:psimag::GroupAction
AppliedSymmetryElementType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms>       AppliedSymmetryElementType;$/;"	t	class:psimag::GroupMultiplicationTable
AppliedSymmetryElementType	PartialPsimag/Symmetry/Star.h	/^    typedef AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> AppliedSymmetryElementType;$/;"	t	class:psimag::Star
AppliedSymmetryElementType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> AppliedSymmetryElementType;$/;"	t	class:psimag::Symmetry
AppliedSymmetryElementType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> AppliedSymmetryElementType;$/;"	t	class:psimag::SymmetryGroup
AppliedSymmetryElementsPtrType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef std::vector<AppliedSymmetryElementType*>                                AppliedSymmetryElementsPtrType;$/;"	t	class:psimag::GroupMultiplicationTable
AppliedSymmetryElementsPtrType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef std::vector<AppliedSymmetryElementType*>                          AppliedSymmetryElementsPtrType;$/;"	t	class:psimag::SymmetryGroup
AppliedSymmetryElementsType	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    typedef std::vector< AppliedSymmetryElementType >                         AppliedSymmetryElementsType;$/;"	t	class:psimag::AppliedSymmetryElementIterator
AppliedSymmetryElementsType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef std::vector<AppliedSymmetryElementType*>                          AppliedSymmetryElementsType;$/;"	t	class:psimag::GroupAction
AppliedSymmetryElementsType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef std::vector<AppliedSymmetryElementType>                                 AppliedSymmetryElementsType;$/;"	t	class:psimag::GroupMultiplicationTable
AppliedSymmetryElementsType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef std::vector<AppliedSymmetryElementType>                           AppliedSymmetryElementsType;$/;"	t	class:psimag::Symmetry
AppliedSymmetryElementsType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef std::vector<AppliedSymmetryElementType>                           AppliedSymmetryElementsType;$/;"	t	class:psimag::SymmetryGroup
AppliedSymmetryOperation	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    AppliedSymmetryOperation(int index,$/;"	f	class:psimag::AppliedSymmetryElement
ArgType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    typedef NullType ArgType;$/;"	t	class:psimag::CLOSE
ArgType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    typedef NullType ArgType;$/;"	t	class:psimag::EQUAL
ArgType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    typedef NullType ArgType;$/;"	t	class:psimag::L2NORM
ArgType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    typedef NullType ArgType;$/;"	t	class:psimag::MAGNITUDE
ArgType	PartialPsimag/Symmetry/Mat/MatMax.h	/^    typedef NullType ArgType;$/;"	t	class:psimag::MAX
ArrayBegin	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void ArrayBegin() {$/;"	f	class:JsonParser::DefaultContext
ArrayEnd	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void ArrayEnd() {$/;"	f	class:JsonParser::DefaultContext
ArrayType	PartialPsimag/Symmetry/CartesianPosition.h	/^    typedef typename BaseType::ArrayType      ArrayType;$/;"	t	class:psimag::CartesianPosition
ArrayType	PartialPsimag/Symmetry/CartesianTranslation.h	/^    typedef typename BaseType::ArrayType      ArrayType;$/;"	t	class:psimag::CartesianTranslation
ArrayType	PartialPsimag/Symmetry/CellDirection.h	/^    typedef typename BaseType::ArrayType      ArrayType;$/;"	t	class:psimag::CellDirection
ArrayType	PartialPsimag/Symmetry/CellPosition.h	/^    typedef Field      ArrayType[DIM];$/;"	t	class:psimag::CellPosition
ArrayType	PartialPsimag/Symmetry/CellTranslation.h	/^    typedef typename BaseType::ArrayType         ArrayType;$/;"	t	class:psimag::CellTranslation
ArrayType	PartialPsimag/Symmetry/MillerDirection.h	/^    typedef typename BaseType::ArrayType      ArrayType;$/;"	t	class:psimag::MillerDirection
ArrayType	PartialPsimag/Symmetry/SeitzPosition.h	/^    typedef typename BaseType::ArrayType      ArrayType;$/;"	t	class:psimag::SeitzPosition
ArrayType	PartialPsimag/Symmetry/SeitzVector.h	/^    typedef typename TypeComputer<Field>::Result ArrayType;$/;"	t	class:psimag::SeitzVector
AssembleInverse2	PartialPsimag/Symmetry/Mat/MatInverse.h	/^  class AssembleInverse2$/;"	c	namespace:psimag
AssembleInverse3	PartialPsimag/Symmetry/Mat/MatInverse.h	/^  class AssembleInverse3$/;"	c	namespace:psimag
AugmentedStateTranslationTable	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^  class AugmentedStateTranslationTable: $/;"	c	namespace:JsonParser
Axes3D	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^		from mpl_toolkits.mplot3d import Axes3D$/;"	i
Axes3D	PythonScripts/Plot_chiRPA_qxqy.py	/^	from mpl_toolkits.mplot3d import Axes3D$/;"	i
B	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  B() const { return (*this)(1,1); }$/;"	f	class:psimag::MetricTensor
BA	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      BA = -5,  \/* Begin Array *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
BAFEAS_5ORB_H	BaFeAs_5orb.h	/^#define BAFEAS_5ORB_H$/;"	d
BANDSTRUCTURE_H	bandstructure.h	/^#define BANDSTRUCTURE_H$/;"	d
BANDS_H	bands.h	/^#define BANDS_H$/;"	d
BILAYERFESC_H	bilayerFESC.h	/^#define BILAYERFESC_H$/;"	d
BILAYER_H	bilayer.h	/^#define BILAYER_H$/;"	d
BIT_MANIP_H	PsimagLite/src/BitManip.h	/^#define BIT_MANIP_H$/;"	d
BLAS	PartialPsimag/BLAS.h	/^namespace BLAS {$/;"	n	namespace:psimag
BLAS	PsimagLite/src/BLAS.h	/^namespace BLAS {$/;"	n	namespace:psimag
BO	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      BO = -6,  \/* Begin Object *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
BOTTOM_ROW	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      static const bool BOTTOM_ROW = (ROW_ == DIM);$/;"	m	class:psimag::SeitzMatrixTraits::REF
BS	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      BS,  \/* Looking for the begining of a string  *\/$/;"	e	enum:JsonParser::StatesMixin::states
BSCCOBILAYER_H	BSCCObilayer.h	/^#define BSCCOBILAYER_H$/;"	d
BaFeAs	BaFeAs_5orb.h	/^		BaFeAs(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::BaFeAs
BaFeAs	BaFeAs_5orb.h	/^	class BaFeAs {$/;"	c	namespace:rpa
BackSubstitution	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    BackSubstitution(HermiteNormalForm<Field,NROW,NCOL> hnf,$/;"	f	class:psimag::BackSubstitution
BackSubstitution	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^  class BackSubstitution {$/;"	c	namespace:psimag
Bands	bands.h	/^		Bands(const rpa::parameters<Field,MatrixTemplate>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::Bands
Bands	bands.h	/^	class Bands {$/;"	c	namespace:rpa
BaseType	PartialPsimag/MatrixSlice.h	/^    typedef ColSlice<MatrixLikeType>            BaseType;$/;"	t	class:psimag::TransposedColSlice
BaseType	PartialPsimag/MatrixSlice.h	/^    typedef RowSlice<MatrixLikeType>            BaseType;$/;"	t	class:psimag::TransposedRowSlice
BaseType	PartialPsimag/Symmetry/CartesianPosition.h	/^    typedef          SeitzPosition<Field,DIM> BaseType;$/;"	t	class:psimag::CartesianPosition
BaseType	PartialPsimag/Symmetry/CartesianTranslation.h	/^    typedef          SeitzVector<Field,DIM,0> BaseType;$/;"	t	class:psimag::CartesianTranslation
BaseType	PartialPsimag/Symmetry/CellDirection.h	/^    typedef          SeitzVector<Field,DIM,0> BaseType;$/;"	t	class:psimag::CellDirection
BaseType	PartialPsimag/Symmetry/CellPosition.h	/^    typedef            SeitzPosition<Field,DIM> BaseType;$/;"	t	class:psimag::CellPosition
BaseType	PartialPsimag/Symmetry/CellTranslation.h	/^    typedef          SeitzVector<Field,DIM,0>    BaseType;$/;"	t	class:psimag::CellTranslation
BaseType	PartialPsimag/Symmetry/ConventionalCrystal.h	/^    typedef CrystalBase<Field,DIM,Occupant,ConventionalLattice,Algorithms> BaseType;$/;"	t	class:psimag::ConventionalCrystal
BaseType	PartialPsimag/Symmetry/Crystal.h	/^    typedef CrystalBase        <Field,DIM,Occupant,Lattice,    Algorithms> BaseType;$/;"	t	class:psimag::Crystal
BaseType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef Matrix<int>                                                             BaseType;$/;"	t	class:psimag::GroupMultiplicationTable
BaseType	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    typedef SeitzVector<int,DIM,IND>  BaseType;$/;"	t	class:psimag::LatticeCoordinates
BaseType	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    typedef Mat<Field, NROW, NCOL, Traits>               BaseType;$/;"	t	class:psimag::HermiteNormalForm
BaseType	PartialPsimag/Symmetry/MillerDirection.h	/^    typedef          SeitzVector<Field,DIM,0> BaseType;$/;"	t	class:psimag::MillerDirection
BaseType	PartialPsimag/Symmetry/Orbits.h	/^    typedef OrbitSpaceType                                                    BaseType;$/;"	t	class:psimag::Orbits
BaseType	PartialPsimag/Symmetry/ReducedCrystal.h	/^    typedef CrystalBase<Field, DIM, Occupant,ReducedLattice,Algorithms> BaseType;$/;"	t	class:psimag::ReducedCrystal
BaseType	PartialPsimag/Symmetry/SeitzPosition.h	/^    typedef          SeitzVector<Field,DIM,1> BaseType;$/;"	t	class:psimag::SeitzPosition
BaseType	PartialPsimag/Symmetry/SeitzVector.h	/^    typedef Vec<Field, DIM+1, TRAITS>            BaseType;$/;"	t	class:psimag::SeitzVector
BaseType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef CrystalBase<Field,DIM,Occupant,Lattice,Algorithms>            BaseType;$/;"	t	class:psimag::SuperCrystal
BaseType	chi0.h	/^ 		typedef psimag::Matrix<std::complex<Field> > BaseType;$/;"	t	class:rpa::susc
BaseType	chi0.h	/^ 		typedef std::vector<SuscType> BaseType;$/;"	t	class:rpa::chi0q
BaseType	greensFunction.h	/^ 		typedef psimag::Matrix<std::complex<Field> > BaseType;$/;"	t	class:rpa::greensFunction
BasicCrystalAlgorithms	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^class BasicCrystalAlgorithms {$/;"	c	namespace:psimag
BasisVectors	PartialPsimag/Symmetry/Lattice.h	/^    typedef std::vector<CartesianTranslationType>         BasisVectors;$/;"	t	class:psimag::Lattice
BasisVectorsType	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    typedef std::vector<CartesianTranslation<Field,DIM> >  BasisVectorsType;$/;"	t	class:psimag::ReciprocalLattice
BasisVectorsType	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    typedef std::vector<CartesianTranslationType>  BasisVectorsType;$/;"	t	class:psimag::ReciprocalLattice
BeginArray	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      BeginArray,    \/* BeginArray               *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
BeginMatrix	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      BeginMatrix,   \/* BeginMatrix              *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
BeginObject	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      BeginObject,   \/* BeginObject              *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
BiLinear	interpolation.h	/^		void BiLinear(VectorType& q,SuscType& result) const {$/;"	f	class:rpa::interpolation
BiLinearGeneral	interpolation.h	/^		void BiLinearGeneral(VectorType& q,SuscType& result) const {$/;"	f	class:rpa::interpolation
Big	PartialPsimag/Symmetry/TypeManip.h	/^            struct Big { char dummy[2]; };$/;"	s	struct:psimag::TypeManip_Private::ConversionHelper
BitManip	PsimagLite/src/BitManip.h	/^	namespace BitManip {$/;"	n	namespace:PsimagLite
BlockType	PsimagLite/src/Geometry/Geometry.h	/^			typedef std::vector<size_t> BlockType;$/;"	t	class:PsimagLite::Geometry
BravaisType	PartialPsimag/Symmetry/BravaisType.h	/^  template <Field, size_t DIM> class BravaisType {$/;"	c	namespace:psimag
BuilderHelperType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef BuilderHelperTemplate<Field,DIM,Occupant,Algorithms>          BuilderHelperType;$/;"	t	class:psimag::SuperCrystal
C	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  C() const { return (*this)(0,1); }$/;"	f	class:psimag::MetricTensor
C	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  C() const { return (*this)(2,2); }$/;"	f	class:psimag::MetricTensor
C1	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      C1,  \/* \/        *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
C2	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      C2,  \/* \/ *     *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
C3	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      C3,  \/* *        *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
CB	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      CB = -10, \/* comment begin *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
CC	Makefile	/^CC                   = mpicxx$/;"	m
CC	PsimagLite/src/JSON/JsonParser/Makefile	/^CC                   = g++$/;"	m
CE	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      CE = -11, \/* comment end *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
CHAIN	PsimagLite/src/Geometry/GeometryFactory.h	/^		enum {CHAIN,LADDER,LADDERX,LADDERBATH,KTWONIFFOUR};$/;"	e	enum:PsimagLite::GeometryFactory::__anon126
CHAIN_H	PsimagLite/src/Geometry/Chain.h	/^#define CHAIN_H$/;"	d
CHEBYSHEV_FUNCTION_H	PsimagLite/src/ChebyshevFunction.h	/^#define CHEBYSHEV_FUNCTION_H$/;"	d
CHEBYSHEV_SERIALIZER_H	PsimagLite/src/ChebyshevSerializer.h	/^#define CHEBYSHEV_SERIALIZER_H$/;"	d
CHEBYSHEV_SOLVER_H_	PsimagLite/src/ChebyshevSolver.h	/^#define CHEBYSHEV_SOLVER_H_$/;"	d
CHI0OFQ_H	chi0Ofq.h	/^#define CHI0OFQ_H$/;"	d
CHI0_H	chi0.h	/^#define CHI0_H$/;"	d
CLOSE	PartialPsimag/Symmetry/Mat/MatEqual.h	/^  class CLOSE {$/;"	c	namespace:psimag
CM	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      CM = -3,  \/* Comma *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
CN	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      CN = -2,  \/* Colon *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
CO	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      CO,  \/* colon    *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
COL	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static const size_t COL = NCOL - 1;$/;"	m	class:psimag::FOREACH_ELS
COL	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static const size_t COL = NCOL - COLS_LEFT;$/;"	m	class:psimag::FOREACH_ELS
COL	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static const size_t COL = NCOL - 1;$/;"	m	class:psimag::FOREACH2_ELS
COL	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static const size_t COL = NCOL - COLS_LEFT;$/;"	m	class:psimag::FOREACH2_ELS
COL	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    enum { COL = 0 };$/;"	e	enum:psimag::TRANSPOSE_ELS::__anon47
COMBINE	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      static T COMBINE(T lhs, T rhs, ArgType& arg) {$/;"	f	class:psimag::CLOSE::CloseReducerType
COMBINE	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      static T COMBINE(T lhs, T rhs, ArgType& arg) {$/;"	f	class:psimag::EQUAL::EqualReducerType
COMBINE	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      static T COMBINE(T lhs, T rhs, ArgType& arg) {$/;"	f	class:psimag::EQUAL_VAL::EqualReducerType
COMBINE	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      static T COMBINE(T lhs, T rhs, ArgType& arg) {$/;"	f	class:psimag::L2NORM::MagnitudeReducerType
COMBINE	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      static T COMBINE(T lhs, T rhs, ArgType& arg) {$/;"	f	class:psimag::MAGNITUDE::MagnitudeReducerType
COMBINE	PartialPsimag/Symmetry/Mat/MatMax.h	/^      static T COMBINE(T lhs, T rhs, ArgType& arg) {$/;"	f	class:psimag::MAX::MaxReducerType
COMBINE	PartialPsimag/Symmetry/Mat/MatTrace.h	/^      static T COMBINE(T lhs, T rhs) {$/;"	f	class:psimag::TRACE::TraceReducerType
COMM_WORLD	PsimagLite/src/ConcurrencyMpi.h	/^		static const CommType  COMM_WORLD;$/;"	m	class:PsimagLite::ConcurrencyMpi
COMM_WORLD	PsimagLite/src/ConcurrencyMpi.h	/^	ConcurrencyMpi<BogusType>::COMM_WORLD = MPI_COMM_WORLD;$/;"	m	class:PsimagLite::ConcurrencyMpi
COMM_WORLD	PsimagLite/src/ConcurrencySerial.h	/^		static const CommType COMM_WORLD = 0;$/;"	m	class:PsimagLite::ConcurrencySerial
COMM_WORLD	PsimagLite/src/Range.h	/^		static const CommType COMM_WORLD;$/;"	m	class:PsimagLite::Range
COMM_WORLD	PsimagLite/src/Range.h	/^	Range<ConcurrencyType>::COMM_WORLD = ConcurrencyType::COMM_WORLD;$/;"	m	class:PsimagLite::Range
CONCURRENCY_HEADER_H	PsimagLite/src/Concurrency.h	/^#define CONCURRENCY_HEADER_H$/;"	d
CONCURRENCY_MPI_HEADER_H	PsimagLite/src/ConcurrencyMpi.h	/^#define CONCURRENCY_MPI_HEADER_H$/;"	d
CONCURRENCY_SERIAL_HEADER_H	PsimagLite/src/ConcurrencySerial.h	/^#define CONCURRENCY_SERIAL_HEADER_H$/;"	d
CONTINUED_FRACTION_COLL_H	PsimagLite/src/ContinuedFractionCollection.h	/^#define CONTINUED_FRACTION_COLL_H$/;"	d
CONTINUED_FRACTION_H	PsimagLite/src/ContinuedFraction.h	/^#define CONTINUED_FRACTION_H$/;"	d
COPY	PartialPsimag/BLAS.h	/^void COPY(int size,const double* x,int sx,double* y,int sy) {$/;"	f	namespace:psimag::BLAS
COPY	PartialPsimag/BLAS.h	/^void COPY(int size,const float* x,int sx,float* y,int sy) {$/;"	f	namespace:psimag::BLAS
COPY	PartialPsimag/BLAS.h	/^void COPY(int size,const std::complex<double>* x,int sx,std::complex<double>* y,int sy) {$/;"	f	namespace:psimag::BLAS
COPY	PartialPsimag/BLAS.h	/^void COPY(int size,const std::complex<float>* x,int sx,std::complex<float>* y,int sy) {$/;"	f	namespace:psimag::BLAS
COPY	PartialPsimag/Symmetry/Mat/MatCopy.h	/^  class COPY {$/;"	c	namespace:psimag
COPY	PsimagLite/src/BLAS.h	/^void COPY(int size,const double* x,int sx,double* y,int sy) {$/;"	f	namespace:psimag::BLAS
COPY	PsimagLite/src/BLAS.h	/^void COPY(int size,const float* x,int sx,float* y,int sy) {$/;"	f	namespace:psimag::BLAS
COPY	PsimagLite/src/BLAS.h	/^void COPY(int size,const std::complex<double>* x,int sx,std::complex<double>* y,int sy) {$/;"	f	namespace:psimag::BLAS
COPY	PsimagLite/src/BLAS.h	/^void COPY(int size,const std::complex<float>* x,int sx,std::complex<float>* y,int sy) {$/;"	f	namespace:psimag::BLAS
COUPLEDLADDERS_H	coupledLadders.h	/^#define COUPLEDLADDERS_H$/;"	d
CPPFLAGS	PsimagLite/drivers/Makefile	/^CPPFLAGS = -Werror -Wall -I..\/src -I..\/src\/JSON -I..\/src\/JSON\/JsonParser$/;"	m
CRSMATRIX_HEADER_H	PsimagLite/src/CrsMatrix.h	/^#define CRSMATRIX_HEADER_H$/;"	d
CXX	PsimagLite/drivers/Makefile	/^CXX = g++ -g3 -DNDEBUG$/;"	m
C_ABCDF	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_ABCDF,  \/* ABCDF *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_BACKS	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_BACKS,  \/* \\ *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_COLON	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_COLON,  \/* : *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_COMMA	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_COMMA,  \/* , *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_DIGIT	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_DIGIT,  \/* 123456789 *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_E	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_E,      \/* E *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_EOF	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_EOF,    \/* end of file *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_ERR	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_ERR,    \/* error *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_ETC	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_ETC,    \/* everything else *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LCURB	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LCURB,  \/* {  *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_A	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_A,  \/* a *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_B	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_B,  \/* b *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_C	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_C,  \/* c *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_D	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_D,  \/* d *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_E	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_E,  \/* e *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_F	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_F,  \/* f *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_L	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_L,  \/* l *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_N	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_N,  \/* n *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_R	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_R,  \/* r *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_S	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_S,  \/* s *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_T	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_T,  \/* t *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_U	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_U,  \/* u *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LOW_Y	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LOW_Y,  \/* y *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LPARN	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LPARN,  \/* (  *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_LSQRB	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_LSQRB,  \/* [ *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_MINUS	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_MINUS,  \/* - *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_PLUS	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_PLUS,   \/* + *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_POINT	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_POINT,  \/* . *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_QUOTE	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_QUOTE,  \/* " *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_RCURB	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_RCURB,  \/* } *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_RPARN	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_RPARN,  \/* ) *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_RSQRB	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_RSQRB,  \/* ] *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_SLASH	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_SLASH,  \/* \/ *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_SPACE	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_SPACE,  \/* space *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_STAR	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_STAR,   \/* * *\/   $/;"	e	enum:JsonParser::CharacterMapper::classes
C_WHITE	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_WHITE,  \/* other whitespace *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
C_ZERO	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      C_ZERO ,  \/* 0 *\/$/;"	e	enum:JsonParser::CharacterMapper::classes
CartPositionsType	PartialPsimag/Symmetry/Pattern.h	/^    typedef std::vector<CartesianPositionType>         CartPositionsType;$/;"	t	class:psimag::Pattern
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^    CartesianPosition(): BaseType() {}$/;"	f	class:psimag::CartesianPosition
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^    CartesianPosition(const ArrayType& vals):  BaseType(vals) {}$/;"	f	class:psimag::CartesianPosition
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^    CartesianPosition(const BaseType& v): BaseType(v) {}$/;"	f	class:psimag::CartesianPosition
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^    CartesianPosition(const CartesianPosition<Field, DIM>& v): BaseType(v) {}$/;"	f	class:psimag::CartesianPosition
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^    CartesianPosition(const Field& val): BaseType(val) {}$/;"	f	class:psimag::CartesianPosition
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^    CartesianPosition(const SeitzVector<Field,DIM,1>& v): BaseType(v) {}$/;"	f	class:psimag::CartesianPosition
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^    CartesianPosition(const Vec<Field, DIM>& v):  BaseType(v) {}$/;"	f	class:psimag::CartesianPosition
CartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^  class CartesianPosition: public SeitzPosition<Field,DIM> {$/;"	c	namespace:psimag
CartesianPositionType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef CartesianPosition<Field,DIM>                           CartesianPositionType;$/;"	t	class:psimag::AppliedSymmetryElement
CartesianPositionType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef CartesianPosition<Field,DIM>                           CartesianPositionType;$/;"	t	class:psimag::AppliedSymmetryElement
CartesianPositionType	PartialPsimag/Symmetry/CartesianTranslation.h	/^    typedef CartesianPosition<Field,DIM>      CartesianPositionType;$/;"	t	class:psimag::CartesianTranslation
CartesianPositionType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef CartesianPosition<Field,DIM>                                      CartesianPositionType;$/;"	t	class:psimag::FloodTiler
CartesianPositionType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef CartesianPosition<Field,DIM>                          CartesianPositionType;$/;"	t	class:psimag::Glide
CartesianPositionType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef CartesianPosition<Field,DIM>                                      CartesianPositionType;$/;"	t	class:psimag::GroupAction
CartesianPositionType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef CartesianPosition<Field,DIM>                                           CartesianPositionType;$/;"	t	class:psimag::GroupMultiplicationTable
CartesianPositionType	PartialPsimag/Symmetry/IdentityElement2D.h	/^    typedef CartesianPosition<Field,DIM>              CartesianPositionType;$/;"	t	class:psimag::IdentityElement
CartesianPositionType	PartialPsimag/Symmetry/Lattice.h	/^    typedef CartesianPosition<Field,DIM>                  CartesianPositionType;$/;"	t	class:psimag::Lattice
CartesianPositionType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef CartesianPosition<Field,DIM>                       CartesianPositionType;$/;"	t	class:psimag::Mirror
CartesianPositionType	PartialPsimag/Symmetry/OccupantClosure.h	/^    typedef CartesianPosition<Field,DIM>                               CartesianPositionType;$/;"	t	class:psimag::OccupantClosure
CartesianPositionType	PartialPsimag/Symmetry/Pattern.h	/^    typedef CartesianPosition<Field,DIM>               CartesianPositionType;$/;"	t	class:psimag::Pattern
CartesianPositionType	PartialPsimag/Symmetry/Star.h	/^    typedef CartesianPosition<Field,DIM>                                  CartesianPositionType;$/;"	t	class:psimag::Star
CartesianPositionType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef CartesianPosition<Field,DIM>                                      CartesianPositionType;$/;"	t	class:psimag::SymmetryGroup
CartesianRotation	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianRotation() : $/;"	f	class:psimag::CartesianRotation
CartesianRotation	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianRotation(IN_TYPE data [DIM*DIM]) : invSet(false) {$/;"	f	class:psimag::CartesianRotation
CartesianRotation	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianRotation(IN_TYPE data [DIM][DIM]) : invSet(false) {$/;"	f	class:psimag::CartesianRotation
CartesianRotation	PartialPsimag/Symmetry/CartesianRotation.h	/^  class CartesianRotation: public Mat< Field, DIM, DIM > {$/;"	c	namespace:psimag
CartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^    CartesianTranslation(): SeitzVector<Field, DIM, 0>() {}$/;"	f	class:psimag::CartesianTranslation
CartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^    CartesianTranslation(const ArrayType* vals):  SeitzVector<Field, DIM, 0>(vals) {}$/;"	f	class:psimag::CartesianTranslation
CartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^    CartesianTranslation(const CartesianTranslation<Field, DIM>& v): SeitzVector<Field, DIM, 0>(v) {}$/;"	f	class:psimag::CartesianTranslation
CartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^    CartesianTranslation(const Vec<Field, DIM>& v):  SeitzVector<Field, DIM, 0>(v) {}$/;"	f	class:psimag::CartesianTranslation
CartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^    template<typename IN_TYPE> CartesianTranslation(const IN_TYPE& val): SeitzVector<Field, DIM, 0>(val) {}$/;"	f	class:psimag::CartesianTranslation
CartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^  class CartesianTranslation: public SeitzVector<Field, DIM, 0> {$/;"	c	namespace:psimag
CartesianTranslationType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef CartesianTranslation<Field,DIM>                        CartesianTranslationType;$/;"	t	class:psimag::AppliedSymmetryElement
CartesianTranslationType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef CartesianTranslation<Field,DIM>                        CartesianTranslationType;$/;"	t	class:psimag::AppliedSymmetryElement
CartesianTranslationType	PartialPsimag/Symmetry/ConventionalLattice.h	/^    typedef CartesianTranslation<Field,DIM>            CartesianTranslationType;$/;"	t	class:psimag::ConventionalLattice
CartesianTranslationType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef CartesianTranslation<Field,DIM>                                   CartesianTranslationType;$/;"	t	class:psimag::FloodTiler
CartesianTranslationType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef CartesianTranslation<Field,DIM>                       CartesianTranslationType;$/;"	t	class:psimag::Glide
CartesianTranslationType	PartialPsimag/Symmetry/Lattice.h	/^    typedef CartesianTranslation<Field,DIM>               CartesianTranslationType;$/;"	t	class:psimag::Lattice
CartesianTranslationType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef CartesianTranslation<Field,DIM>                    CartesianTranslationType;$/;"	t	class:psimag::Mirror
CartesianTranslationType	PartialPsimag/Symmetry/Pattern.h	/^    typedef CartesianTranslation<Field,DIM>            CartesianTranslationType;$/;"	t	class:psimag::Pattern
CartesianTranslationType	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    typedef CartesianTranslation<Field,DIM+1>      CartesianTranslationType;$/;"	t	class:psimag::ReciprocalLattice
CartesianTranslationType	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    typedef CartesianTranslation<Field,DIM>        CartesianTranslationType;$/;"	t	class:psimag::ReciprocalLattice
CartesianTranslationType	PartialPsimag/Symmetry/ReducedLattice.h	/^    typedef CartesianTranslation<Field,DIM>   CartesianTranslationType;$/;"	t	class:psimag::ReducedLattice
CartesianTranslationType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef CartesianTranslation<Field,DIM>                                CartesianTranslationType;$/;"	t	class:psimag::SymmetryElements
CartesianTranslationType	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    typedef CartesianTranslation<Field,2>                                  CartesianTranslationType;$/;"	t	class:psimag::SymmetryOperations
CartesianTranslationType	PartialPsimag/Symmetry/TestPattern.h	/^    typedef CartesianTranslation<Field,DIM>                                     CartesianTranslationType;$/;"	t	class:psimag::TestPattern
Case	parameters.h	/^		std::string Case;$/;"	m	class:rpa::parameters
Case_	ferminator.h	/^		std::string Case_;$/;"	m	class:rpa::ferminator
CellDirection	PartialPsimag/Symmetry/CellDirection.h	/^    CellDirection(): SeitzVector<Field,DIM,0>() {}$/;"	f	class:psimag::CellDirection
CellDirection	PartialPsimag/Symmetry/CellDirection.h	/^    CellDirection(const ArrayType vals): SeitzVector<Field,DIM,0>(vals) { }$/;"	f	class:psimag::CellDirection
CellDirection	PartialPsimag/Symmetry/CellDirection.h	/^    CellDirection(const IN_TYPE& val): SeitzVector<Field,DIM,0>(val) {}$/;"	f	class:psimag::CellDirection
CellDirection	PartialPsimag/Symmetry/CellDirection.h	/^  class CellDirection: public SeitzVector<Field,DIM,0> {$/;"	c	namespace:psimag
CellParamType	PartialPsimag/Symmetry/Lattice.h	/^    typedef CellParameters<Field,DIM,Algorithms>          CellParamType;$/;"	t	class:psimag::Lattice
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^      CellParameters(In_Type _a) :$/;"	f	class:psimag::CellParameters
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^      CellParameters(In_Type _a,    In_Type _b,    In_Type _c, $/;"	f	class:psimag::CellParameters
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^      CellParameters(In_Type _a, In_Type _b, In_Type _alpha) :$/;"	f	class:psimag::CellParameters
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^    CellParameters():$/;"	f	class:psimag::CellParameters
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^    CellParameters(MetricTensor< Field, 1>& metric) {$/;"	f	class:psimag::CellParameters
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^    CellParameters(MetricTensor< Field, 2 >& metric):$/;"	f	class:psimag::CellParameters
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^    CellParameters(MetricTensor< Field, 3 >& metric):$/;"	f	class:psimag::CellParameters
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^  class CellParameters<Field,1,Algorithms> {$/;"	c	namespace:psimag
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^  class CellParameters<Field,2, Algorithms> {$/;"	c	namespace:psimag
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^  class CellParameters<Field,3, Algorithms> {$/;"	c	namespace:psimag
CellParameters	PartialPsimag/Symmetry/CellParameters.h	/^  template <typename Field, size_t DIM, typename Algorithms> class CellParameters {};$/;"	c	namespace:psimag
CellPosItr	PartialPsimag/Symmetry/PatternData.h	/^    typedef typename CellPositions::const_iterator       CellPosItr;$/;"	t	class:psimag::PatternData
CellPosRef	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef typename PatternDataType::CellPosItr          CellPosRef;$/;"	t	class:psimag::OriginLocator
CellPosition	PartialPsimag/Symmetry/CellPosition.h	/^    CellPosition() : BaseType () {}$/;"	f	class:psimag::CellPosition
CellPosition	PartialPsimag/Symmetry/CellPosition.h	/^    CellPosition(const ArrayType& values): BaseType(values)$/;"	f	class:psimag::CellPosition
CellPosition	PartialPsimag/Symmetry/CellPosition.h	/^    CellPosition(const SeitzVector<Field,DIM,1>& svec): BaseType(svec)$/;"	f	class:psimag::CellPosition
CellPosition	PartialPsimag/Symmetry/CellPosition.h	/^  class CellPosition: public SeitzPosition<Field,DIM>  {$/;"	c	namespace:psimag
CellPositionType	PartialPsimag/Symmetry/CellPosition.h	/^    typedef CellPosition<Field,DIM,Algorithms>  CellPositionType;$/;"	t	class:psimag::CellPosition
CellPositionType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef CellPosition<Field,DIM,Algorithms>                                CellPositionType;$/;"	t	class:psimag::FloodTiler
CellPositionType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef CellPosition<Field,DIM,Algorithms>                    CellPositionType;$/;"	t	class:psimag::Glide
CellPositionType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef CellPosition<Field,DIM, Algorithms>                               CellPositionType;$/;"	t	class:psimag::GroupAction
CellPositionType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef CellPosition<Field,DIM, Algorithms>                                    CellPositionType;$/;"	t	class:psimag::GroupMultiplicationTable
CellPositionType	PartialPsimag/Symmetry/Lattice.h	/^    typedef CellPosition<Field,DIM,Algorithms>            CellPositionType;$/;"	t	class:psimag::Lattice
CellPositionType	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    typedef CellPosition<Field,DIM,Algorithms>                            CellPositionType;$/;"	t	class:psimag::LatticeWithPattern
CellPositionType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef CellPosition<Field,DIM,Algorithms>                 CellPositionType;$/;"	t	class:psimag::Mirror
CellPositionType	PartialPsimag/Symmetry/OccupantClosure.h	/^    typedef typename PatternDataType::CellPositionType                 CellPositionType;$/;"	t	class:psimag::OccupantClosure
CellPositionType	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef typename PatternDataType::CellPositionType    CellPositionType;$/;"	t	class:psimag::OriginLocator
CellPositionType	PartialPsimag/Symmetry/Pattern.h	/^    typedef CellPosition<Field,DIM,Algorithms>         CellPositionType;$/;"	t	class:psimag::Pattern
CellPositionType	PartialPsimag/Symmetry/PatternData.h	/^    typedef CellPosition<Field,DIM, Algorithms>          CellPositionType;$/;"	t	class:psimag::PatternData
CellPositionType	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    typedef CellPosition<Field,DIM,Algorithms>                                CellPositionType; $/;"	t	class:psimag::SpaceGroup
CellPositionType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef CellPosition<Field,DIM,Algorithms>       CellPositionType; $/;"	t	class:psimag::SpaceGroupData
CellPositionType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef CellPosition<Field,DIM,Algorithms>       CellPositionType;$/;"	t	class:psimag::SpaceGroupData
CellPositionType	PartialPsimag/Symmetry/Star.h	/^    typedef CellPosition<Field,DIM, Algorithms>                           CellPositionType;$/;"	t	class:psimag::Star
CellPositionType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef CellPosition<Field,DIM,Algorithms>                            CellPositionType;$/;"	t	class:psimag::Symmetry
CellPositionType	PartialPsimag/Symmetry/SymmetryElement.h	/^    typedef CellPosition<Field,DIM,Algorithms>      CellPositionType;$/;"	t	class:psimag::SymmetryElement
CellPositionType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef CellPosition<Field,DIM, Algorithms>                               CellPositionType;$/;"	t	class:psimag::SymmetryGroup
CellPositions	PartialPsimag/Symmetry/OccupantClosure.h	/^    typedef typename PatternDataType::CellPositions                    CellPositions;$/;"	t	class:psimag::OccupantClosure
CellPositions	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef typename PatternDataType::CellPositions       CellPositions;$/;"	t	class:psimag::OriginLocator
CellPositions	PartialPsimag/Symmetry/PatternData.h	/^    typedef std::set<CellPositionType>                   CellPositions;$/;"	t	class:psimag::PatternData
CellPositionsType	PartialPsimag/Symmetry/Pattern.h	/^    typedef std::vector<CellPositionType>              CellPositionsType;$/;"	t	class:psimag::Pattern
CellRotation	PartialPsimag/Symmetry/CellRotation.h	/^    CellRotation() : $/;"	f	class:psimag::CellRotation
CellRotation	PartialPsimag/Symmetry/CellRotation.h	/^    CellRotation(RotationType t, int sense, const CellDirection<Field, DIM>& axisDirection): invSet(false) {$/;"	f	class:psimag::CellRotation
CellRotation	PartialPsimag/Symmetry/CellRotation.h	/^    CellRotation(const In_Type data [DIM*DIM]) : $/;"	f	class:psimag::CellRotation
CellRotation	PartialPsimag/Symmetry/CellRotation.h	/^    CellRotation(const In_Type& val) : $/;"	f	class:psimag::CellRotation
CellRotation	PartialPsimag/Symmetry/CellRotation.h	/^  class CellRotation: public Mat< Field, DIM, DIM > {$/;"	c	namespace:psimag
CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^    CellTranslation(): BaseType() {}$/;"	f	class:psimag::CellTranslation
CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^    CellTranslation(const ArrayType& vals):  BaseType(vals) {}$/;"	f	class:psimag::CellTranslation
CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^    CellTranslation(const BaseType& v):  BaseType(v) {}$/;"	f	class:psimag::CellTranslation
CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^    CellTranslation(const ThisType& v): BaseType(v) {}$/;"	f	class:psimag::CellTranslation
CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^    CellTranslation(const Vec<Field, DIM>& v):  BaseType(v) {}$/;"	f	class:psimag::CellTranslation
CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^    explicit CellTranslation(const CellPosition<Field,DIM,Algorithms> p):  BaseType(p) {}$/;"	f	class:psimag::CellTranslation
CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^  class CellTranslation: public SeitzVector< Field, DIM, 0 > {$/;"	c	namespace:psimag
CellTranslationType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef CellTranslation<Field,DIM>                             CellTranslationType;$/;"	t	class:psimag::AppliedSymmetryElement
CellTranslationType	PartialPsimag/Symmetry/FourFold2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::FourFold
CellTranslationType	PartialPsimag/Symmetry/FourFoldN2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::FourFoldN
CellTranslationType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef CellTranslation<Field,DIM>                            CellTranslationType;$/;"	t	class:psimag::Glide
CellTranslationType	PartialPsimag/Symmetry/IdentityElement2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::IdentityElement
CellTranslationType	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    typedef CellTranslation<Field,DIM>              CellTranslationType;$/;"	t	class:psimag::InverseLatticeTransformation
CellTranslationType	PartialPsimag/Symmetry/Lattice.h	/^    typedef CellTranslation<Field,DIM>                    CellTranslationType;$/;"	t	class:psimag::Lattice
CellTranslationType	PartialPsimag/Symmetry/LatticeTransformation.h	/^    typedef CellTranslation<Field,DIM>              CellTranslationType;$/;"	t	class:psimag::LatticeTransformation
CellTranslationType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef CellTranslation<Field,DIM>                         CellTranslationType;$/;"	t	class:psimag::Mirror
CellTranslationType	PartialPsimag/Symmetry/Pattern.h	/^    typedef CellTranslation<Field,DIM>                 CellTranslationType;$/;"	t	class:psimag::Pattern
CellTranslationType	PartialPsimag/Symmetry/SixFold2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::SixFold
CellTranslationType	PartialPsimag/Symmetry/SixFoldN2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::SixFoldN
CellTranslationType	PartialPsimag/Symmetry/SymmetryElement.h	/^    typedef CellTranslation<Field,DIM>              CellTranslationType;$/;"	t	class:psimag::SymmetryElement
CellTranslationType	PartialPsimag/Symmetry/ThreeFold2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::ThreeFold
CellTranslationType	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::ThreeFoldN
CellTranslationType	PartialPsimag/Symmetry/TwoFold2D.h	/^    typedef CellTranslation<Field,DIM>                CellTranslationType;$/;"	t	class:psimag::TwoFold
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=1, NumGenerators=1, NumOperations=1};$/;"	e	enum:psimag::SpaceGroupData::__anon82
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=10, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon91
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=11, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon92
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=12, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon93
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=13 , NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon94
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=14 , NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon95
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=15, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon96
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=16, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon97
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=17, NumGenerators=4, NumOperations=12};$/;"	e	enum:psimag::SpaceGroupData::__anon98
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=2, NumGenerators=2, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon83
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=3, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon84
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=4, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon85
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=6, NumGenerators=3, NumOperations=8 };$/;"	e	enum:psimag::SpaceGroupData::__anon87
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=7 , NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon88
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=8, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon89
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=5, NumGenerators=3, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon86
Centered	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=9 , NumGenerators=4, NumOperations=11};$/;"	e	enum:psimag::SpaceGroupData::__anon90
CenteredToPrimitive	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    static const TransformationType CenteredToPrimitive() {$/;"	f	class:psimag::CenteringPointGroup
CenteredToPrimitive	PartialPsimag/Symmetry/Centering2D.h	/^    static const TransformationType CenteredToPrimitive() {$/;"	f	class:psimag::Centering
Centering	PartialPsimag/Symmetry/Centering.h	/^  class Centering: public CenteringBase<Field,DIM> {$/;"	c	namespace:psimag
Centering	PartialPsimag/Symmetry/Centering2D.h	/^  class Centering {$/;"	c	namespace:psimag
Centering	PartialPsimag/Symmetry/Centering2D.h	/^  class Centering<2,0> {$/;"	c	namespace:psimag
Centering	PartialPsimag/Symmetry/Centering2D.h	/^  class Centering<2,1> {$/;"	c	namespace:psimag
CenteringBase	PartialPsimag/Symmetry/Centering.h	/^  class CenteringBase {$/;"	c	namespace:psimag
CenteringPointGroup	PartialPsimag/Symmetry/CeneringPointGroup.h	/^  class CenteringPointGroup {$/;"	c	namespace:psimag
CenteringPointGroup	PartialPsimag/Symmetry/CeneringPointGroup.h	/^  class CenteringPointGroup<2,0,0> {$/;"	c	namespace:psimag
CenteringPointGroup	PartialPsimag/Symmetry/CeneringPointGroup.h	/^  class CenteringPointGroup<2,1,1> {$/;"	c	namespace:psimag
CenteringType	PartialPsimag/Symmetry/ForEachCentering.h	/^    typedef Centering<Field,DIM,NUM> CenteringType;$/;"	t	class:psimag::ForEachCentering_
Centerings	PartialPsimag/Symmetry/Centering.h	/^  class Centerings {$/;"	c	namespace:psimag
Centerings	PartialPsimag/Symmetry/Centering.h	/^  class Centerings<2> {$/;"	c	namespace:psimag
Centerings	PartialPsimag/Symmetry/Centering.h	/^  class Centerings<3> {$/;"	c	namespace:psimag
Centerings	PartialPsimag/Symmetry/Centering2D.h	/^  class Centerings {$/;"	c	namespace:psimag
Centerings	PartialPsimag/Symmetry/Centering2D.h	/^  class Centerings<2> {$/;"	c	namespace:psimag
Centerings	PartialPsimag/Symmetry/Centering2D.h	/^  class Centerings<3> {$/;"	c	namespace:psimag
Chain	PsimagLite/src/Geometry/Chain.h	/^			Chain(size_t linSize) : linSize_(linSize)$/;"	f	class:PsimagLite::Chain
Chain	PsimagLite/src/Geometry/Chain.h	/^	class Chain  {$/;"	c	namespace:PsimagLite
CharacterClass	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    } CharacterClass;$/;"	t	class:JsonParser::CharacterMapper	typeref:enum:JsonParser::CharacterMapper::classes
CharacterMapper	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^  class CharacterMapper {$/;"	c	namespace:JsonParser
ChebyshevFunction	PsimagLite/src/ChebyshevFunction.h	/^	class ChebyshevFunction  {$/;"	c	namespace:PsimagLite
ChebyshevSerializer	PsimagLite/src/ChebyshevSerializer.h	/^		ChebyshevSerializer(IoInputType& io)$/;"	f	class:PsimagLite::ChebyshevSerializer
ChebyshevSerializer	PsimagLite/src/ChebyshevSerializer.h	/^		ChebyshevSerializer(const VectorType& ab,const ParametersType& params)$/;"	f	class:PsimagLite::ChebyshevSerializer
ChebyshevSerializer	PsimagLite/src/ChebyshevSerializer.h	/^	class ChebyshevSerializer  {$/;"	c	namespace:PsimagLite
ChebyshevSolver	PsimagLite/src/ChebyshevSolver.h	/^		ChebyshevSolver(MatrixType const &mat,$/;"	f	class:PsimagLite::ChebyshevSolver
ChebyshevSolver	PsimagLite/src/ChebyshevSolver.h	/^	class ChebyshevSolver {$/;"	c	namespace:PsimagLite
ChiqMatrixType	chi0Ofq.h	/^		typedef std::vector<psimag::Matrix<std::complex<Field> > > ChiqMatrixType;$/;"	t	class:rpa::chi0ofq
Classifier	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  typedef SpaceGroupConstructor<double,2>                          Classifier;$/;"	t	class:psimag::BasicCrystalAlgorithms
Close	PartialPsimag/Symmetry/Mat/MatEqual.h	/^  bool Close (const MatType<T,NROW>&  m, $/;"	f	namespace:psimag
CloseReducerType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    class CloseReducerType {$/;"	c	class:psimag::CLOSE
ColMajorTraits	PartialPsimag/Symmetry/Mat/MatTraits.h	/^  class ColMajorTraits$/;"	c	namespace:psimag
ColSlice	PartialPsimag/MatrixSlice.h	/^    ColSlice(MatrixLikeType& m, size_t colIndex):$/;"	f	class:psimag::ColSlice
ColSlice	PartialPsimag/MatrixSlice.h	/^  class ColSlice {$/;"	c	namespace:psimag
ColumnsType	PsimagLite/src/SparseRow.h	/^		typedef std::vector<size_t> ColumnsType;$/;"	t	class:PsimagLite::SparseRow
CommPairType	PsimagLite/src/ConcurrencyMpi.h	/^		typedef std::pair<CommType,CommType> CommPairType;$/;"	t	class:PsimagLite::ConcurrencyMpi
CommPairType	PsimagLite/src/ConcurrencySerial.h	/^		typedef std::pair<CommType,CommType> CommPairType;$/;"	t	class:PsimagLite::ConcurrencySerial
CommType	PsimagLite/src/ConcurrencyMpi.h	/^		typedef MPI_Comm CommType;$/;"	t	class:PsimagLite::ConcurrencyMpi
CommType	PsimagLite/src/ConcurrencySerial.h	/^		typedef int CommType;$/;"	t	class:PsimagLite::ConcurrencySerial
CommType	PsimagLite/src/Range.h	/^		typedef ConcurrencyType::CommType CommType;$/;"	t	class:PsimagLite::Range
CommType	PsimagLite/src/Range.h	/^		typedef typename ConcurrencyType::CommType CommType;$/;"	t	class:PsimagLite::Range
Comment	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void Comment(std::wstring s) {$/;"	f	class:JsonParser::DefaultContext
Compare	PsimagLite/src/Sort.h	/^			Compare(const std::vector<PairType>& x) : x_(x)$/;"	f	class:Sort::Compare
Compare	PsimagLite/src/Sort.h	/^	class Compare {$/;"	c	class:Sort
CompileTimeError	PartialPsimag/PSIMAGAssert.h	/^template<> struct CompileTimeError<true> { };$/;"	s	namespace:psimag
CompileTimeError	PsimagLite/src/JSON/PSIMAGAssert.h	/^template<> struct CompileTimeError<true> { };$/;"	s	namespace:psimag
ComplexMatrixType	1band_wSpin.h	/^		typedef MatrixTemplate<ComplexType>	ComplexMatrixType;$/;"	t	class:rpa::SingleBand_wSpin
ComplexMatrixType	4Orbital.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::FourOrbital
ComplexMatrixType	BSCCObilayer.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	BaFeAs_5orb.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::BaFeAs
ComplexMatrixType	FourOrbital.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::FourOrbital
ComplexMatrixType	KFe2Se2.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::KFe2Se2
ComplexMatrixType	SrRuO.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::SrRuO
ComplexMatrixType	SrRuO_SO.h	/^		typedef MatrixTemplate<ComplexType>	ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	bands.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::Bands
ComplexMatrixType	bandstructure.h	/^		typedef MatrixTemplate<ComplexType>	ComplexMatrixType;$/;"	t	class:rpa::bandstructure
ComplexMatrixType	bilayer.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	bilayerFESC.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	chi0.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::calcChi0Matrix
ComplexMatrixType	chi0.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::chi0q
ComplexMatrixType	chi0Ofq.h	/^		typedef psimag::Matrix<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::chi0ofq
ComplexMatrixType	coupledLadders.h	/^		typedef MatrixTemplate<ComplexType>	ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	ferminator.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::ferminator
ComplexMatrixType	gap.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::gap
ComplexMatrixType	gaps3D.h	/^        typedef MatrixTemplate<std::complex<Field> >   ComplexMatrixType;$/;"	t	class:rpa::gap3D
ComplexMatrixType	greensFunction.h	/^		typedef psimag::Matrix<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::greensFunction
ComplexMatrixType	interpolation.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::interpolation
ComplexMatrixType	momentumDomain.h	/^		typedef MatrixTemplate<std::complex<Field> >	ComplexMatrixType;$/;"	t	class:rpa::momentumDomain
ComplexMatrixType	orthoIIBilayer.h	/^		typedef MatrixTemplate<ComplexType> ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	pairing.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::pairing
ComplexMatrixType	parameters.h	/^		typedef MatrixTemplate<ComplexType> 		ComplexMatrixType;$/;"	t	class:rpa::parameters
ComplexMatrixType	rpa.h	/^			typedef MatrixTemplate<ComplexType> 		ComplexMatrixType;$/;"	t	class:rpa::interaction
ComplexMatrixType	rpa_CuO.h	/^			typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::interactionEmery
ComplexMatrixType	sepBasis.h	/^			typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::sepBasis
ComplexMatrixType	singleBand.h	/^		typedef MatrixTemplate<ComplexType>	ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	susceptibility.h	/^			typedef MatrixTemplate<ComplexType> 	   ComplexMatrixType;$/;"	t	class:rpa::susceptibility
ComplexMatrixType	tbFromFile.h	/^		typedef MatrixTemplate<ComplexType> 	ComplexMatrixType;$/;"	t	class:rpa::model
ComplexMatrixType	utilities.h	/^typedef psimag::Matrix<std::complex<double> > ComplexMatrixType;$/;"	t
ComplexType	1band_wSpin.h	/^		typedef std::complex<Field>		    ComplexType;$/;"	t	class:rpa::SingleBand_wSpin
ComplexType	4Orbital.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::FourOrbital
ComplexType	BSCCObilayer.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::model
ComplexType	BaFeAs_5orb.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::BaFeAs
ComplexType	FourOrbital.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::FourOrbital
ComplexType	KFe2Se2.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::KFe2Se2
ComplexType	PsimagLite/src/ContinuedFraction.h	/^		typedef typename std::complex<RealType> ComplexType;$/;"	t	class:PsimagLite::ContinuedFraction
ComplexType	PsimagLite/src/ContinuedFractionCollection.h	/^		typedef typename ContinuedFractionType::ComplexType ComplexType;$/;"	t	class:PsimagLite::ContinuedFractionCollection
ComplexType	SrRuO.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::SrRuO
ComplexType	SrRuO_SO.h	/^		typedef std::complex<Field>		    ComplexType;$/;"	t	class:rpa::model
ComplexType	bands.h	/^		typedef std::complex<Field>		ComplexType;$/;"	t	class:rpa::Bands
ComplexType	bandstructure.h	/^		typedef std::complex<Field>		ComplexType;$/;"	t	class:rpa::bandstructure
ComplexType	bilayer.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::model
ComplexType	bilayerFESC.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::model
ComplexType	chi0.h	/^		typedef std::complex<Field>				ComplexType;$/;"	t	class:rpa::calcChi0Matrix
ComplexType	chi0.h	/^		typedef std::complex<Field>				ComplexType;$/;"	t	class:rpa::chi0q
ComplexType	chi0Ofq.h	/^		typedef std::complex<Field> ComplexType;$/;"	t	class:rpa::chi0ofq
ComplexType	coupledLadders.h	/^		typedef std::complex<Field>		    ComplexType;$/;"	t	class:rpa::model
ComplexType	ferminator.h	/^		typedef std::complex<Field>				ComplexType;$/;"	t	class:rpa::ferminator
ComplexType	gap.h	/^		typedef std::complex<Field>		ComplexType;$/;"	t	class:rpa::gap
ComplexType	gaps2D.h	/^		typedef std::complex<Field>		ComplexType;$/;"	t	class:rpa::gap2D
ComplexType	gaps3D.h	/^        typedef std::complex<Field>     ComplexType;$/;"	t	class:rpa::gap3D
ComplexType	greensFunction.h	/^		typedef std::complex<Field> ComplexType;$/;"	t	class:rpa::greensFunction
ComplexType	interpolation.h	/^		typedef std::complex<Field>				ComplexType;$/;"	t	class:rpa::interpolation
ComplexType	momentumDomain.h	/^		typedef std::complex<Field>					ComplexType;$/;"	t	class:rpa::momentumDomain
ComplexType	orthoIIBilayer.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::model
ComplexType	pairing.h	/^		typedef std::complex<Field>				ComplexType;$/;"	t	class:rpa::pairing
ComplexType	parameters.h	/^		typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::parameters
ComplexType	rpa.h	/^			typedef std::complex<Field>			ComplexType;$/;"	t	class:rpa::interaction
ComplexType	rpa_CuO.h	/^			typedef std::complex<Field>				ComplexType;$/;"	t	class:rpa::interactionEmery
ComplexType	sepBasis.h	/^			typedef std::complex<Field>				ComplexType;$/;"	t	class:rpa::sepBasis
ComplexType	singleBand.h	/^		typedef std::complex<Field>		    ComplexType;$/;"	t	class:rpa::model
ComplexType	susceptibility.h	/^			typedef std::complex<Field>		           ComplexType;$/;"	t	class:rpa::susceptibility
ComplexType	tbFromFile.h	/^		typedef std::complex<Field>		ComplexType;$/;"	t	class:rpa::model
ComplexVectorType	bandstructure.h	/^		typedef std::vector<ComplexType>  	ComplexVectorType;$/;"	t	class:rpa::bandstructure
ComplexVectorType	chi0.h	/^		typedef std::vector<ComplexType>      	ComplexVectorType;$/;"	t	class:rpa::calcChi0Matrix
ComplexVectorType	ferminator.h	/^		typedef std::vector<ComplexType>      	ComplexVectorType;$/;"	t	class:rpa::ferminator
ComplexVectorType	momentumDomain.h	/^		typedef std::vector<std::complex<Field> >   ComplexVectorType;$/;"	t	class:rpa::momentumDomain
ComplexVectorType	pairing.h	/^		typedef std::vector<ComplexType>      	ComplexVectorType;$/;"	t	class:rpa::pairing
ComplexVectorType	susceptibility.h	/^			typedef std::vector<std::complex<Field> >  ComplexVectorType;$/;"	t	class:rpa::susceptibility
Concurrency	PsimagLite/src/Concurrency.h	/^	class Concurrency {$/;"	c	namespace:PsimagLite
ConcurrencyMpi	PsimagLite/src/ConcurrencyMpi.h	/^		ConcurrencyMpi(int argc, char *argv[])$/;"	f	class:PsimagLite::ConcurrencyMpi
ConcurrencyMpi	PsimagLite/src/ConcurrencyMpi.h	/^	class ConcurrencyMpi : public Concurrency<BogusType> {$/;"	c	namespace:PsimagLite
ConcurrencySerial	PsimagLite/src/ConcurrencySerial.h	/^		ConcurrencySerial(int argc,char *argv[]) : step_(-1),total_(0)$/;"	f	class:PsimagLite::ConcurrencySerial
ConcurrencySerial	PsimagLite/src/ConcurrencySerial.h	/^	class ConcurrencySerial : public Concurrency<BogusType> {$/;"	c	namespace:PsimagLite
ConcurrencyType	PsimagLite/drivers/concurrencyTest.cpp	/^typedef PsimagLite::ConcurrencyMpi<RealType> ConcurrencyType;$/;"	t	file:
ConcurrencyType	PsimagLite/drivers/concurrencyTest.cpp	/^typedef PsimagLite::ConcurrencySerial<RealType> ConcurrencyType;$/;"	t	file:
ConcurrencyType	PsimagLite/drivers/range.cpp	/^typedef PsimagLite::ConcurrencyMpi <RealType> ConcurrencyType;$/;"	t	file:
ConcurrencyType	PsimagLite/drivers/range.cpp	/^typedef PsimagLite::ConcurrencySerial<> ConcurrencyType;$/;"	t	file:
ConcurrencyType	PsimagLite/src/Range.h	/^		typedef ConcurrencySerial<> ConcurrencyType;$/;"	t	class:PsimagLite::Range
ConcurrencyType	main.cpp	/^typedef PsimagLite::ConcurrencyMpi<double> ConcurrencyType;$/;"	t	file:
ConcurrencyType	main.cpp	/^typedef PsimagLite::ConcurrencySerial<double> ConcurrencyType;$/;"	t	file:
ConstRefType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef ConstType&   ConstRefType;  $/;"	t	class:psimag::ColMajorTraits
ConstRefType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef ConstType&   ConstRefType;  $/;"	t	class:psimag::ConstantTraits
ConstRefType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef ConstType&   ConstRefType;  $/;"	t	class:psimag::RowMajorTraits
ConstType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef const Type   ConstType;$/;"	t	class:psimag::ColMajorTraits
ConstType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef const Type   ConstType;$/;"	t	class:psimag::ConstantTraits
ConstType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef const Type   ConstType;$/;"	t	class:psimag::RowMajorTraits
ConstantMatTraitsType	PartialPsimag/Symmetry/Mat/Mat.h	/^    typedef ConstantTraits<Field,NROW,NCOL>  ConstantMatTraitsType;$/;"	t	class:psimag::Mat
ConstantTraits	PartialPsimag/Symmetry/Mat/MatTraits.h	/^  class ConstantTraits$/;"	c	namespace:psimag
Consume	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      Consume,       \/* Consume the character    *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
ContinuedFraction	PsimagLite/src/ContinuedFraction.h	/^		ContinuedFraction() : progress_("ContinuedFraction",0),$/;"	f	class:PsimagLite::ContinuedFraction
ContinuedFraction	PsimagLite/src/ContinuedFraction.h	/^		ContinuedFraction(IoInputType& io)$/;"	f	class:PsimagLite::ContinuedFraction
ContinuedFraction	PsimagLite/src/ContinuedFraction.h	/^		ContinuedFraction(const TridiagonalMatrixType& ab,const ParametersType& params)$/;"	f	class:PsimagLite::ContinuedFraction
ContinuedFraction	PsimagLite/src/ContinuedFraction.h	/^	class ContinuedFraction  {$/;"	c	namespace:PsimagLite
ContinuedFractionCollection	PsimagLite/src/ContinuedFractionCollection.h	/^		ContinuedFractionCollection()$/;"	f	class:PsimagLite::ContinuedFractionCollection
ContinuedFractionCollection	PsimagLite/src/ContinuedFractionCollection.h	/^		ContinuedFractionCollection(IoInputType& io,size_t level = 0)$/;"	f	class:PsimagLite::ContinuedFractionCollection
ContinuedFractionCollection	PsimagLite/src/ContinuedFractionCollection.h	/^	class ContinuedFractionCollection  {$/;"	c	namespace:PsimagLite
ContinuedFractionCollectionType	PsimagLite/drivers/combineContinuedFraction.cpp	/^	ContinuedFractionCollectionType;$/;"	t	file:
ContinuedFractionCollectionType	PsimagLite/drivers/continuedFractionCollection.cpp	/^	ContinuedFractionCollectionType;$/;"	t	file:
ContinuedFractionType	PsimagLite/drivers/combineContinuedFraction.cpp	/^typedef ContinuedFraction<RealType,TridiagonalMatrixType> ContinuedFractionType;$/;"	t	file:
ContinuedFractionType	PsimagLite/drivers/continuedFraction.cpp	/^typedef ContinuedFraction<RealType,TridiagonalMatrixType> ContinuedFractionType;$/;"	t	file:
ContinuedFractionType	PsimagLite/drivers/continuedFractionCollection.cpp	/^typedef ContinuedFraction<RealType,TridiagonalMatrixType> ContinuedFractionType;$/;"	t	file:
ContinuedFractionType	PsimagLite/src/ContinuedFractionCollection.h	/^		typedef ContinuedFractionType_ ContinuedFractionType;$/;"	t	class:PsimagLite::ContinuedFractionCollection
ConventionalCrystal	PartialPsimag/Symmetry/ConventionalCrystal.h	/^    ConventionalCrystal(ReducedCrystalType& structure):$/;"	f	class:psimag::ConventionalCrystal
ConventionalCrystal	PartialPsimag/Symmetry/ConventionalCrystal.h	/^  class ConventionalCrystal:$/;"	c	namespace:psimag
ConventionalCrystalType	PartialPsimag/Symmetry/ConventionalCrystal.h	/^    typedef ConventionalCrystal<Field,DIM,Occupant,Algorithms>             ConventionalCrystalType;$/;"	t	class:psimag::ConventionalCrystal
ConventionalCrystalType	PartialPsimag/Symmetry/Crystal.h	/^    typedef ConventionalCrystal<Field,DIM,Occupant,            Algorithms> ConventionalCrystalType;$/;"	t	class:psimag::Crystal
ConventionalLattice	PartialPsimag/Symmetry/ConventionalLattice.h	/^    ConventionalLattice(const ReducedLatticeType& reducedLattice): $/;"	f	class:psimag::ConventionalLattice
ConventionalLattice	PartialPsimag/Symmetry/ConventionalLattice.h	/^  class ConventionalLattice: $/;"	c	namespace:psimag
ConventionalLatticeType	PartialPsimag/Symmetry/ConventionalLattice.h	/^    typedef ConventionalLattice<Field,DIM,Algorithms>  ConventionalLatticeType;$/;"	t	class:psimag::ConventionalLattice
Conversion	PartialPsimag/Symmetry/TypeManip.h	/^    class Conversion<void, void>$/;"	c	namespace:psimag
Conversion	PartialPsimag/Symmetry/TypeManip.h	/^    struct Conversion$/;"	s	namespace:psimag
Conversion	PartialPsimag/Symmetry/TypeManip.h	/^    struct Conversion<T, T>$/;"	s	namespace:psimag
Conversion	PartialPsimag/Symmetry/TypeManip.h	/^    struct Conversion<T, void>$/;"	s	namespace:psimag
Conversion	PartialPsimag/Symmetry/TypeManip.h	/^    struct Conversion<void, T>$/;"	s	namespace:psimag
ConversionHelper	PartialPsimag/Symmetry/TypeManip.h	/^        struct ConversionHelper$/;"	s	namespace:psimag::TypeManip_Private
CoordType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef LatticeCoordinates<DIM>                                           CoordType;$/;"	t	class:psimag::FloodTiler
CoordsType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef std::vector<CoordType>                                            CoordsType;$/;"	t	class:psimag::FloodTiler
Copy	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    void Copy (MatType&  m, MatTypeO& other) {$/;"	f	namespace:psimag
Copy	PartialPsimag/Symmetry/STLUtil.h	/^void Copy(T i, std::vector<U>& result)$/;"	f	namespace:psimag
Copy	PartialPsimag/Symmetry/STLUtil.h	/^void Copy(const std::map<K,M>& source, std::vector<U>& result)$/;"	f	namespace:psimag
Copy	PartialPsimag/Symmetry/STLUtil.h	/^void Copy(const std::vector<T>& source, std::vector<U>& result)$/;"	f	namespace:psimag
CopyFunctionType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    class CopyFunctionType {$/;"	c	class:psimag::COPY
CopyMinusFunctionType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    class CopyMinusFunctionType {$/;"	c	class:psimag::COPY
CopyPlusFunctionType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    class CopyPlusFunctionType {$/;"	c	class:psimag::COPY
CopyTimesFunctionType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    class CopyTimesFunctionType {$/;"	c	class:psimag::COPY
CoupledLadders	PythonScripts/CoupledLadders.py	/^class CoupledLadders:$/;"	c
CrsMatrix	PsimagLite/src/CrsMatrix.h	/^		CrsMatrix() { } $/;"	f	class:PsimagLite::CrsMatrix
CrsMatrix	PsimagLite/src/CrsMatrix.h	/^		CrsMatrix(const CrsMatrix<S>& a)$/;"	f	class:PsimagLite::CrsMatrix
CrsMatrix	PsimagLite/src/CrsMatrix.h	/^		CrsMatrix(const CrsMatrix<std::complex<S> >& a)$/;"	f	class:PsimagLite::CrsMatrix
CrsMatrix	PsimagLite/src/CrsMatrix.h	/^		CrsMatrix(const Matrix<T>& a)$/;"	f	class:PsimagLite::CrsMatrix
CrsMatrix	PsimagLite/src/CrsMatrix.h	/^		CrsMatrix(int nrow,int ncol)$/;"	f	class:PsimagLite::CrsMatrix
CrsMatrix	PsimagLite/src/CrsMatrix.h	/^	class CrsMatrix {$/;"	c	namespace:PsimagLite
Crystal	PartialPsimag/Symmetry/Crystal.h	/^    Crystal(LatticeType lat, const Occupant occupant):$/;"	f	class:psimag::Crystal
Crystal	PartialPsimag/Symmetry/Crystal.h	/^    Crystal(LatticeType& lat):$/;"	f	class:psimag::Crystal
Crystal	PartialPsimag/Symmetry/Crystal.h	/^    Crystal(LatticeType& lat, PatternType& pat):$/;"	f	class:psimag::Crystal
Crystal	PartialPsimag/Symmetry/Crystal.h	/^    Crystal(LatticeType& lat, const Occupant& occupant):$/;"	f	class:psimag::Crystal
Crystal	PartialPsimag/Symmetry/Crystal.h	/^    Crystal(LatticeWithPatternType& pat):$/;"	f	class:psimag::Crystal
Crystal	PartialPsimag/Symmetry/Crystal.h	/^    Crystal(ThisType& otherStructure):$/;"	f	class:psimag::Crystal
Crystal	PartialPsimag/Symmetry/Crystal.h	/^    Crystal(const LatticeType& lat, const PatternDataType& patternData):$/;"	f	class:psimag::Crystal
Crystal	PartialPsimag/Symmetry/Crystal.h	/^  class Crystal: $/;"	c	namespace:psimag
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^    CrystalBase(): $/;"	f	class:psimag::CrystalBase
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^    CrystalBase(LatticeType& lat, const Occupant& occupant):$/;"	f	class:psimag::CrystalBase
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^    CrystalBase(const CrystalBase<Field,DIM,Occupant,OtherLatticeTemplate,Algorithms>& other):$/;"	f	class:psimag::CrystalBase
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^    CrystalBase(const LatticeType& lat, const PatternDataType& patternData):$/;"	f	class:psimag::CrystalBase
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^    CrystalBase(const LatticeType& lat, const PatternType& pat):$/;"	f	class:psimag::CrystalBase
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^    CrystalBase(const LatticeWithPatternType& latticeWithPattern):$/;"	f	class:psimag::CrystalBase
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^    CrystalBase(const OtherLatticeTemplate<Field,DIM,Algorithms>& lat, $/;"	f	class:psimag::CrystalBase
CrystalBase	PartialPsimag/Symmetry/CrystalBase.h	/^  class CrystalBase: $/;"	c	namespace:psimag
CrystalBaseType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef CrystalBase<Field,DIM,Occupant,Lattice,Algorithms>                CrystalBaseType;$/;"	t	class:psimag::FloodTiler
CrystalType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef Crystal<Field,DIM,Occupant,Algorithms>                            CrystalType;$/;"	t	class:psimag::FloodTiler
CrystalType	PartialPsimag/Symmetry/PsimagGeometry.h	/^	     typedef Crystal<Field, MatrixTemplate> CrystalType;$/;"	t	class:rpa::PsimagGeometry
CrystalType	PartialPsimag/Symmetry/ReducedCrystal.h	/^    typedef Crystal<Field,DIM,Occupant,Algorithms>                      CrystalType;$/;"	t	class:psimag::ReducedCrystal
CrystalType	PartialPsimag/Symmetry/Simple2DReducer.h	/^    typedef Crystal       <Field,DIM,Occupant,Algorithms>  CrystalType;$/;"	t	class:psimag::Simple2DReducer
CrystalType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef Crystal<Field,DIM,Occupant,Algorithms>                        CrystalType;$/;"	t	class:psimag::SuperCrystal
CurrentContext	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    std::string CurrentContext() {$/;"	f	class:JsonParser::DefaultContext
D	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  D() const { return (*this)(1,2); }$/;"	f	class:psimag::MetricTensor
D1	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      D1,  \/* second UTF-16 character decoding started by \\ *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
D2	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      D2,  \/* second UTF-16 character proceeded by u *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
DCA_CrystalHarmonics_H	CrystalHarmonics.h	/^#define DCA_CrystalHarmonics_H$/;"	d
DCA_CrystalHarmonics_H	CrystalHarmonics2D.h	/^#define DCA_CrystalHarmonics_H$/;"	d
DCA_JSON_READER_HEADER_H	PsimagLite/src/JSON/JsonReader.h	/^#define DCA_JSON_READER_HEADER_H$/;"	d
DE	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      DE = -15, \/* double detected by exponent e E *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
DEBUG	PsimagLite/src/ChebyshevSolver.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::ChebyshevSolver::__anon114
DEBUG	PsimagLite/src/LanczosSolver.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::LanczosSolver::__anon122
DEBUG	PsimagLite/src/LanczosVectors.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::LanczosVectors::__anon113
DET	PartialPsimag/Symmetry/Mat/MatDet.h	/^  class DET $/;"	c	namespace:psimag
DET	PartialPsimag/Symmetry/Mat/MatDet.h	/^  class DET<MatType, Traits, 1> {$/;"	c	namespace:psimag
DET	PartialPsimag/Symmetry/Mat/MatDet.h	/^  class DET<MatType, Traits, 2> {$/;"	c	namespace:psimag
DET	PartialPsimag/Symmetry/Mat/MatDet.h	/^  class DET<MatType, Traits, 3> {$/;"	c	namespace:psimag
DF	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      DF = -16, \/* double detected by fraction . *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
DGETRF	PartialPsimag/LAPACK.h	/^  inline void DGETRF(int ma, int na, double* a, int lda, int* pivot, int& info) {$/;"	f	namespace:psimag::LAPACK
DGETRI	PartialPsimag/LAPACK.h	/^  inline void DGETRI(int na, double* a, int lda, int* pivot, double* work, int lwork, int& info) {$/;"	f	namespace:psimag::LAPACK
DIFFERENCE	PartialPsimag/Symmetry/Mat/MatDifference.h	/^  class DIFFERENCE {$/;"	c	namespace:psimag
DIM	PartialPsimag/Symmetry/FourFold2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::FourFold::__anon2
DIM	PartialPsimag/Symmetry/FourFoldN2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::FourFoldN::__anon63
DIM	PartialPsimag/Symmetry/Glide2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::Glide::__anon70
DIM	PartialPsimag/Symmetry/IdentityElement2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::IdentityElement::__anon64
DIM	PartialPsimag/Symmetry/Mirror2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::Mirror::__anon66
DIM	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    enum {DIM=1};$/;"	e	enum:psimag::ReciprocalLattice::__anon79
DIM	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    enum {DIM=2};$/;"	e	enum:psimag::ReciprocalLattice::__anon80
DIM	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    enum {DIM=3};$/;"	e	enum:psimag::ReciprocalLattice::__anon81
DIM	PartialPsimag/Symmetry/Simple2DReducer.h	/^    enum {DIM=2};$/;"	e	enum:psimag::Simple2DReducer::__anon71
DIM	PartialPsimag/Symmetry/SixFold2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::SixFold::__anon72
DIM	PartialPsimag/Symmetry/SixFoldN2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::SixFoldN::__anon67
DIM	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    enum {DIM=2, NUMGROUPS=17};$/;"	e	enum:psimag::SpaceGroup::__anon107
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=1, NumGenerators=1, NumOperations=1};$/;"	e	enum:psimag::SpaceGroupData::__anon82
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=10, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon91
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=11, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon92
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=12, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon93
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=13 , NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon94
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=14 , NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon95
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=15, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon96
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=16, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon97
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=17, NumGenerators=4, NumOperations=12};$/;"	e	enum:psimag::SpaceGroupData::__anon98
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=2, NumGenerators=2, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon83
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=3, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon84
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=4, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon85
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=6, NumGenerators=3, NumOperations=8 };$/;"	e	enum:psimag::SpaceGroupData::__anon87
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=7 , NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon88
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=8, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon89
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=5, NumGenerators=3, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon86
DIM	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=9 , NumGenerators=4, NumOperations=11};$/;"	e	enum:psimag::SpaceGroupData::__anon90
DIM	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    enum {DIM=2};$/;"	e	enum:psimag::SuperCrystalBuilder::__anon75
DIM	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    enum {DIM=2};$/;"	e	enum:psimag::SymmetryElements::__anon68
DIM	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    enum {DIM=2, NUMOPS=51};$/;"	e	enum:psimag::SymmetryOperations::__anon109
DIM	PartialPsimag/Symmetry/ThreeFold2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::ThreeFold::__anon99
DIM	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::ThreeFoldN::__anon110
DIM	PartialPsimag/Symmetry/TwoFold2D.h	/^    enum { DIM=2 };$/;"	e	enum:psimag::TwoFold::__anon69
DIRECTION_BATH	PsimagLite/src/Geometry/LadderBath.h	/^			enum {DIRECTION_X=LadderType::DIRECTION_X,DIRECTION_Y=LadderType::DIRECTION_Y,DIRECTION_BATH};$/;"	e	enum:PsimagLite::LadderBath::__anon125
DIRECTION_X	PsimagLite/src/Geometry/Chain.h	/^			enum { DIRECTION_X };$/;"	e	enum:PsimagLite::Chain::__anon123
DIRECTION_X	PsimagLite/src/Geometry/Ladder.h	/^		enum {DIRECTION_X,DIRECTION_Y};$/;"	e	enum:PsimagLite::Ladder::__anon131
DIRECTION_X	PsimagLite/src/Geometry/LadderBath.h	/^			enum {DIRECTION_X=LadderType::DIRECTION_X,DIRECTION_Y=LadderType::DIRECTION_Y,DIRECTION_BATH};$/;"	e	enum:PsimagLite::LadderBath::__anon125
DIRECTION_X	PsimagLite/src/Geometry/LadderX.h	/^			enum {DIRECTION_X=LadderType::DIRECTION_X,DIRECTION_Y=LadderType::DIRECTION_Y,DIRECTION_XPY,DIRECTION_XMY};$/;"	e	enum:PsimagLite::LadderX::__anon127
DIRECTION_XMY	PsimagLite/src/Geometry/LadderX.h	/^			enum {DIRECTION_X=LadderType::DIRECTION_X,DIRECTION_Y=LadderType::DIRECTION_Y,DIRECTION_XPY,DIRECTION_XMY};$/;"	e	enum:PsimagLite::LadderX::__anon127
DIRECTION_XPY	PsimagLite/src/Geometry/LadderX.h	/^			enum {DIRECTION_X=LadderType::DIRECTION_X,DIRECTION_Y=LadderType::DIRECTION_Y,DIRECTION_XPY,DIRECTION_XMY};$/;"	e	enum:PsimagLite::LadderX::__anon127
DIRECTION_Y	PsimagLite/src/Geometry/Ladder.h	/^		enum {DIRECTION_X,DIRECTION_Y};$/;"	e	enum:PsimagLite::Ladder::__anon131
DIRECTION_Y	PsimagLite/src/Geometry/LadderBath.h	/^			enum {DIRECTION_X=LadderType::DIRECTION_X,DIRECTION_Y=LadderType::DIRECTION_Y,DIRECTION_BATH};$/;"	e	enum:PsimagLite::LadderBath::__anon125
DIRECTION_Y	PsimagLite/src/Geometry/LadderX.h	/^			enum {DIRECTION_X=LadderType::DIRECTION_X,DIRECTION_Y=LadderType::DIRECTION_Y,DIRECTION_XPY,DIRECTION_XMY};$/;"	e	enum:PsimagLite::LadderX::__anon127
DIRICHLET	PsimagLite/src/ChebyshevSerializer.h	/^		enum {JACKSON,LORENTZ,DIRICHLET};$/;"	e	enum:PsimagLite::KernelPolynomialParameters::__anon121
DIR_X	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {DIR_X,DIR_Y,DIR_XPY,DIR_XMY};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon130
DIR_XMY	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {DIR_X,DIR_Y,DIR_XPY,DIR_XMY};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon130
DIR_XPY	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {DIR_X,DIR_Y,DIR_XPY,DIR_XMY};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon130
DIR_Y	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {DIR_X,DIR_Y,DIR_XPY,DIR_XMY};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon130
DIVIDE	PartialPsimag/OperationClosure.h	/^    typedef enum{FourierTransform,PLUS,MINUS,TIMES,DIVIDE,INV} Type;$/;"	e	enum:psimag::OP::__anon112
DIVIDE	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
DOT	PsimagLite/src/BLAS.h	/^inline double DOT(int n,double* dx,int incx,double* dy,int incy)$/;"	f	namespace:psimag::BLAS
DataArray	PartialPsimag/Symmetry/SeitzMatrix.h	/^      typedef IN_TYPE DataArray[DIM+1*DIM+1];$/;"	t	class:psimag::SeitzMatrix::TypeComputer
DataArray2D	PartialPsimag/Symmetry/SeitzMatrix.h	/^      typedef IN_TYPE DataArray2D[DIM+1][DIM+1];$/;"	t	class:psimag::SeitzMatrix::TypeComputer
DefaultContext	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    DefaultContext():$/;"	f	class:JsonParser::DefaultContext
DefaultContext	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^  class DefaultContext {$/;"	c	namespace:JsonParser
Delta0	parameters.h	/^		Field Delta0;$/;"	m	class:rpa::parameters
DenseMatrixType	PsimagLite/src/LanczosVectors.h	/^		typedef PsimagLite::Matrix<VectorElementType> DenseMatrixType;$/;"	t	class:PsimagLite::LanczosVectors
Det	PartialPsimag/Symmetry/CellRotation.h	/^  Field Det(const CellRotation<Field, DIM>& cellRotation) {$/;"	f	namespace:psimag
Det	PartialPsimag/Symmetry/Mat/MatDet.h	/^  inline  T Det(const MatType<T,NROW,NCOL,Traits>& m) {$/;"	f	namespace:psimag
Det	PartialPsimag/Symmetry/Mat/MatDet.h	/^  inline  double Det(ColMajorTraits<double,2>::ConstRefType m) { $/;"	f	namespace:psimag
Det	PartialPsimag/Symmetry/Mat/MatDet.h	/^  inline  double Det(ColMajorTraits<double,3>::ConstRefType m) { $/;"	f	namespace:psimag
Det	PartialPsimag/Symmetry/Mat/MatDet.h	/^  inline  int Det(ColMajorTraits<int,2>::ConstRefType m) { $/;"	f	namespace:psimag
Det	PartialPsimag/Symmetry/Mat/MatDet.h	/^  inline  int Det(ColMajorTraits<int,3>::ConstRefType m) { $/;"	f	namespace:psimag
Det	PartialPsimag/Symmetry/SeitzMatrix.h	/^inline  Field Det(const SeitzMatrix<Field, DIM>& m) {$/;"	f	namespace:psimag
DifferenceFunctionType	PartialPsimag/Symmetry/Mat/MatDifference.h	/^    class DifferenceFunctionType {$/;"	c	class:psimag::DIFFERENCE
DirectionVectorType	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    typedef std::vector<CellDirection<Field,DIM> > DirectionVectorType;$/;"	t	class:psimag::CenteringPointGroup
DirectionVectorType	PartialPsimag/Symmetry/Centering2D.h	/^    typedef std::vector<CellDirection<Field,DIM> > DirectionVectorType;$/;"	t	class:psimag::Centering
DoNext	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      DoNext,        \/* DoNext                 *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
DocType	PartialPsimag/XMLHeading.h	/^    typedef enum { XHTML, SVG} DocType;$/;"	t	class:psimag::XMLHeading	typeref:enum:psimag::XMLHeading::__anon1
DoubleIndexTraits	PartialPsimag/Symmetry/Mat/MatTraits.h	/^  class DoubleIndexTraits$/;"	c	namespace:psimag
DoubleVectorType	PartialPsimag/MatrixLike.h	/^      typedef std::vector<VectorLikeType>        DoubleVectorType;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
DoubleVectorType	PsimagLite/src/JSON/MatrixLike.h	/^      typedef std::vector<VectorLikeType>        DoubleVectorType;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
DoubleVectorWrap	PartialPsimag/MatrixLike.h	/^      DoubleVectorWrap(DoubleVectorType& dv):$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
DoubleVectorWrap	PartialPsimag/MatrixLike.h	/^    class DoubleVectorWrap {$/;"	c	namespace:psimag::MatrixLike
DoubleVectorWrap	PsimagLite/src/JSON/MatrixLike.h	/^      DoubleVectorWrap(DoubleVectorType& dv):$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
DoubleVectorWrap	PsimagLite/src/JSON/MatrixLike.h	/^    class DoubleVectorWrap {$/;"	c	namespace:psimag::MatrixLike
DummyType	PsimagLite/src/GslWrapper.h	/^		typedef int DummyType;$/;"	t	class:PsimagLite::GslWrapper
E	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  E() const { return (*this)(0,2); }$/;"	f	class:psimag::MetricTensor
E1	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      E1,  \/* e        *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
E2	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      E2,  \/* ex       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
E3	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      E3,  \/* exp      *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
EA	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      EA = -7,  \/* End Array *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
EE	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      EE = -8,  \/* End Empty Object *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
END	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      END,  \/* END of Parsing               *\/$/;"	e	enum:JsonParser::StatesMixin::states
EO	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      EO = -9,  \/* End Object *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
EQUAL	PartialPsimag/Symmetry/Mat/MatEqual.h	/^  class EQUAL {$/;"	c	namespace:psimag
EQUAL_VAL	PartialPsimag/Symmetry/Mat/MatEqual.h	/^  class EQUAL_VAL {$/;"	c	namespace:psimag
ES	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      ES,  \/* escape   *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
EType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef typename Traits::ElType  EType;$/;"	t	class:psimag::CLOSE::CloseReducerType
EType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef typename Traits::ElType  EType;$/;"	t	class:psimag::EQUAL::EqualReducerType
EType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef typename Traits::ElType  EType;$/;"	t	class:psimag::EQUAL_VAL::EqualReducerType
EType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      typedef typename Traits::ElType  EType;$/;"	t	class:psimag::L2NORM::MagnitudeReducerType
EType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      typedef typename Traits::ElType  EType;$/;"	t	class:psimag::MAGNITUDE::MagnitudeReducerType
EType	PartialPsimag/Symmetry/Mat/MatMax.h	/^      typedef typename Traits::ElType  EType;$/;"	t	class:psimag::MAX::MaxReducerType
EV	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      EV,  \/* Looking after a value  *\/$/;"	e	enum:JsonParser::StatesMixin::states
EX	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      EX = -21, \/* next char is escaped *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
EX	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      EX,  \/* Looking for the exponent *\/$/;"	e	enum:JsonParser::StatesMixin::states
EX2	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      EX2, \/* Looking for the integer part of the exponent *\/$/;"	e	enum:JsonParser::StatesMixin::states
EXEC	PartialPsimag/Symmetry/ForEachCentering.h	/^    static bool EXEC(ArgType& arg) {$/;"	f	class:psimag::ForEachCentering
EXEC	PartialPsimag/Symmetry/ForEachCentering.h	/^    static bool EXEC(ArgType& arg) {$/;"	f	class:psimag::ForEachCentering_
EXEC	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      static void EXEC(LHSType& lhs, const RHSType& rhs) {$/;"	f	class:psimag::COPY::CopyFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      static void EXEC(LHSType& lhs, const RHSType& rhs) {$/;"	f	class:psimag::COPY::CopyMinusFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      static void EXEC(LHSType& lhs, const RHSType& rhs) {$/;"	f	class:psimag::COPY::CopyPlusFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      static void EXEC(LHSType& lhs, const RHSType& rhs) {$/;"	f	class:psimag::COPY::CopyTimesFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    static void EXEC(MatTypeLHS& lhs, const MatTypeRHS& rhs) { $/;"	f	class:psimag::COPY
EXEC	PartialPsimag/Symmetry/Mat/MatDifference.h	/^      static void EXEC(const LHSType& lhs, const RHSType& rhs, ResultType& result) {$/;"	f	class:psimag::DIFFERENCE::DifferenceFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatDifference.h	/^    static void EXEC(const MatTypeLHS& lhs, const MatTypeRHS& rhs, MatTypeResult& result) { $/;"	f	class:psimag::DIFFERENCE
EXEC	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    static bool EXEC(const MatType& m, const ArgType& arg) { $/;"	f	class:psimag::EQUAL_VAL
EXEC	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    static bool EXEC(const MatType& m, const MatTypeO& other) { $/;"	f	class:psimag::CLOSE
EXEC	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    static bool EXEC(const MatType& m, const MatTypeO& other) { $/;"	f	class:psimag::EQUAL
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC( MatType& lhs, ArgType& arg) {$/;"	f	class:psimag::FOREACH_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC( MatType& lhs, ArgType& arg) {$/;"	f	class:psimag::FOREACH_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC(MatType& lhs, ArgType& arg) { $/;"	f	class:psimag::FOREACH_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC(MatType& lhs, ArgType& arg) {$/;"	f	class:psimag::FOREACH
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC(MatType& lhs, ArgType& arg) {$/;"	f	class:psimag::FOREACH_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC(const MatType& lhs, ArgType& arg) { $/;"	f	class:psimag::FOREACH_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC(const MatType& lhs, ArgType& arg) {$/;"	f	class:psimag::FOREACH
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC(const MatType& lhs, ArgType& arg) {$/;"	f	class:psimag::FOREACH_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static void EXEC(const MatType& lhs, ArgType& arg) {$/;"	f	class:psimag::FOREACH_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static void EXEC(MatType& lhs, const MatTypeRHS& rhs) { $/;"	f	class:psimag::FOREACH2_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static void EXEC(MatType& lhs, const MatTypeRHS& rhs) {$/;"	f	class:psimag::FOREACH2
EXEC	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static void EXEC(MatType& lhs, const MatTypeRHS& rhs) {$/;"	f	class:psimag::FOREACH2_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static void EXEC(MatType& lhs, const MatTypeRHS& rhs) {$/;"	f	class:psimag::FOREACH2_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    static void EXEC(const MatTypeLHS& lhs, const MatTypeRHS& rhs, MatTypeResult& result) { $/;"	f	class:psimag::FOREACH3_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    static void EXEC(const MatTypeLHS& lhs, const MatTypeRHS& rhs, MatTypeResult& result) {$/;"	f	class:psimag::FOREACH3
EXEC	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    static void EXEC(const MatTypeLHS& lhs, const MatTypeRHS& rhs, MatTypeResult& result) {$/;"	f	class:psimag::FOREACH3_
EXEC	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    static void EXEC(const MatTypeLHS& lhs, const MatTypeRHS& rhs, MatTypeResult& result) {$/;"	f	class:psimag::FOREACH3_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    static void EXEC(MatType& m) {$/;"	f	class:psimag::FOREACH_DIAG
EXEC	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    static void EXEC(MatType& m) {$/;"	f	class:psimag::FOREACH_DIAG_
EXEC	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    static void EXEC(const MatType& m) {$/;"	f	class:psimag::FOREACH_DIAG
EXEC	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    static void EXEC(const MatType& m) {$/;"	f	class:psimag::FOREACH_DIAG_
EXEC	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^    static void EXEC(MatType& m) { $/;"	f	class:psimag::MakeIDENTITY
EXEC	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    static void EXEC(const M& m, MR& im)$/;"	f	class:psimag::AssembleInverse2
EXEC	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    static void EXEC(const MatType<T,3,3,MT>& m, MatTypeR<T,3,3,MRT>& im)$/;"	f	class:psimag::AssembleInverse3
EXEC	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    static typename Traits::ElType EXEC(const MatType& m, const MatTypeO& other) { $/;"	f	class:psimag::L2NORM
EXEC	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    static typename Traits::ElType EXEC(const MatType& m, const MatTypeO& other) { $/;"	f	class:psimag::MAGNITUDE
EXEC	PartialPsimag/Symmetry/Mat/MatMax.h	/^    static T EXEC(const MatType& m, const MatTypeO& other) { $/;"	f	class:psimag::MAX
EXEC	PartialPsimag/Symmetry/Mat/MatMult.h	/^    static T EXEC(const MatType& lhs, const MatTypeO& rhs) {$/;"	f	class:psimag::MatMultVecPos
EXEC	PartialPsimag/Symmetry/Mat/MatMult.h	/^    static void EXEC(const MatType& m, const MatTypeO& mo, MatTypeR& result) {$/;"	f	class:psimag::MatMultVec
EXEC	PartialPsimag/Symmetry/Mat/MatMult.h	/^    static void EXEC(const MatType& m, const MatTypeO& v, MatTypeR& result) {$/;"	f	class:psimag::MatMultVecCol
EXEC	PartialPsimag/Symmetry/Mat/MatMult.h	/^    static void EXEC(const MatType& m, const MatTypeO& v, MatTypeR& result) {$/;"	f	class:psimag::MatMultVecRow
EXEC	PartialPsimag/Symmetry/Mat/MatPrint.h	/^      static void EXEC(const LHSType& lhs, size_t row, size_t col, std::ostream& os) {$/;"	f	class:psimag::PRINT_FUNCTOR::FlatPrintFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatPrint.h	/^      static void EXEC(const LHSType& lhs, size_t row, size_t col, std::ostream& os) {$/;"	f	class:psimag::PRINT_FUNCTOR::PrintFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    static void EXEC(const MatType& m, std::ostream& os, bool flat=false) {$/;"	f	class:psimag::MAT_PRINT
EXEC	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    static void EXEC(const MatTypeLHS& lhs, std::ostream& os, bool flat=false) { $/;"	f	class:psimag::PRINT_FUNCTOR
EXEC	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    static ReturnType EXEC(const MatType& m, ArgType& arg) { $/;"	f	class:psimag::REDUCE_
EXEC	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    static ReturnType EXEC(const MatType& m, ArgType& arg) {$/;"	f	class:psimag::REDUCE
EXEC	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    static ReturnType EXEC(const MatType& m, ArgType& arg) {$/;"	f	class:psimag::REDUCE_
EXEC	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    static ReturnType EXEC(const MatType& m, ArgType& arg) {$/;"	f	class:psimag::REDUCE_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    static ReturnType EXEC(const MatType& m, const MatTypeOther& other, ArgType& arg) { $/;"	f	class:psimag::REDUCE2_
EXEC	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    static ReturnType EXEC(const MatType& m, const MatTypeOther& other, ArgType& arg) {$/;"	f	class:psimag::REDUCE2
EXEC	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    static ReturnType EXEC(const MatType& m, const MatTypeOther& other, ArgType& arg) {$/;"	f	class:psimag::REDUCE2_
EXEC	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    static ReturnType EXEC(const MatType& m, const MatTypeOther& other, ArgType& arg) {$/;"	f	class:psimag::REDUCE2_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    static ReturnType EXEC(const MatType& m) {$/;"	f	class:psimag::REDUCE_DIAG
EXEC	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    static ReturnType EXEC(const MatType& m) {$/;"	f	class:psimag::REDUCE_DIAG_
EXEC	PartialPsimag/Symmetry/Mat/MatSum.h	/^      static void EXEC(const LHSType& lhs, const RHSType& rhs, ResultType& result) {$/;"	f	class:psimag::SUM::SumFunctionType
EXEC	PartialPsimag/Symmetry/Mat/MatSum.h	/^    static void EXEC(const MatTypeLHS& lhs, const MatTypeRHS& rhs, MatTypeResult& result) { $/;"	f	class:psimag::SUM
EXEC	PartialPsimag/Symmetry/Mat/MatTrace.h	/^    static T EXEC(const MatType& m) { $/;"	f	class:psimag::TRACE
EXEC	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    static void EXEC(const MatType& m, MatType& result) {$/;"	f	class:psimag::TRANSPOSE
EXEC	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    static void EXEC(const MatType& m, MatType& result) {$/;"	f	class:psimag::TRANSPOSE_ELS
EXEC	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    static void EXEC(const MatType& m, MatTypeR& result) {$/;"	f	class:psimag::TRANSPOSE
EXEC	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    static void EXEC(const MatType& m, MatTypeR& result) {$/;"	f	class:psimag::TRANSPOSE_ELS
EXEC_MINUS	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    static void EXEC_MINUS(MatTypeLHS& lhs, const MatTypeRHS& rhs) { $/;"	f	class:psimag::COPY
EXEC_PLUS	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    static void EXEC_PLUS(MatTypeLHS& lhs, const MatTypeRHS& rhs) { $/;"	f	class:psimag::COPY
EXEC_TIMES	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    static void EXEC_TIMES(MatTypeLHS& lhs, const MatTypeRHS& rhs) { $/;"	f	class:psimag::COPY
EXENAME	Makefile	/^EXENAME		         = mrpapp$/;"	m
EXENAME	PsimagLite/src/JSON/JsonParser/Makefile	/^EXENAME		     = parseTest$/;"	m
Eg	PsimagLite/src/ParametersForSolver.h	/^		RealType Eg;$/;"	m	struct:PsimagLite::ParametersForSolver
Eg_	PsimagLite/src/ContinuedFraction.h	/^		RealType Eg_;$/;"	m	class:PsimagLite::ContinuedFraction
ElType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            ElType;$/;"	t	class:psimag::ColMajorTraits
ElType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            ElType;$/;"	t	class:psimag::ConstantTraits
ElType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            ElType;$/;"	t	class:psimag::DoubleIndexTraits
ElType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            ElType;$/;"	t	class:psimag::ReverseDoubleIndexTraits
ElType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            ElType;$/;"	t	class:psimag::RowMajorTraits
ElType	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^    typedef T ElType;$/;"	t	class:psimag::SeitzMatrixTraits
Elements	PartialPsimag/Tag.h	/^    class Elements: public std::vector<Tag> {$/;"	c	class:psimag::Tag
End	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void End(size_t numChars, size_t numLines) {$/;"	f	class:JsonParser::DefaultContext
EndArray	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      EndArray,      \/* EndArray               *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
EndFile	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      EndFile,       \/* EndFile               *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
EndMatrix	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      EndMatrix,      \/* EndMatrix               *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
EndObject	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      EndObject,     \/* endObject              *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
EqualReducerType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    class EqualReducerType {$/;"	c	class:psimag::EQUAL
EqualReducerType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    class EqualReducerType {$/;"	c	class:psimag::EQUAL_VAL
Explorer	PartialPsimag/Symmetry/SpaceGroupConstructor2D.h	/^  class Explorer {$/;"	c	namespace:psimag
ExtRetriever	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      class ExtRetriever {$/;"	c	class:psimag::SeitzMatrixTraits::REF
F	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  F() const { return (*this)(0,1); }$/;"	f	class:psimag::MetricTensor
F	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      F,   \/* Looking for _alse (false)   *\/$/;"	e	enum:JsonParser::StatesMixin::states
F1	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      F1,  \/* fa       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
F2	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      F2,  \/* fal      *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
F3	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      F3,  \/* fals     *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
F4	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      F4,  \/* false    *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
FA	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      FA = -12, \/* false *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
FA	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      FA,  \/* Looking for __lse (false)   *\/$/;"	e	enum:JsonParser::StatesMixin::states
FAL	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      FAL, \/* Looking for ___se (false)   *\/$/;"	e	enum:JsonParser::StatesMixin::states
FALS	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      FALS,\/* Looking for ____e (false)   *\/$/;"	e	enum:JsonParser::StatesMixin::states
FERMINATOR_H	ferminator.h	/^#define FERMINATOR_H$/;"	d
FERMI_H_	PsimagLite/src/Fermi.h	/^#define FERMI_H_$/;"	d
FETCHGEOMETRY_HEADER_H	PartialPsimag/Symmetry/fetchGeometry2D.h	/^#define  FETCHGEOMETRY_HEADER_H$/;"	d
FETCHMESH_HEADER_H	PartialPsimag/Symmetry/fetchMesh.h	/^#define FETCHMESH_HEADER_H$/;"	d
FETCHMESH_HEADER_H	PartialPsimag/Symmetry/fetchMeshWignerSeitz.h	/^#define FETCHMESH_HEADER_H$/;"	d
FETCH_GEOMETRY_1D_HEADER_H	PartialPsimag/Symmetry/fetchGeometry1D.h	/^#define  FETCH_GEOMETRY_1D_HEADER_H$/;"	d
FLAGS	Makefile	/^FLAGS        = $(MatrixBoundsChecking)  -O2 -Wall  -Werror -DUSE_MPI -DUSE_SCGAP3D -DUSE_TBFILE$/;"	m
FLAGS	PsimagLite/src/JSON/JsonParser/Makefile	/^FLAGS        = $(MatrixBoundsChecking) -g  -Wall  -Werror  $/;"	m
FLAGSC	Makefile	/^FLAGSC	     = $(MatrixBoundsChecking) $/;"	m
FLAGSC	PsimagLite/src/JSON/JsonParser/Makefile	/^FLAGSC	     = $(MatrixBoundsChecking) $/;"	m
FOREACH	PartialPsimag/Symmetry/Mat/MatForEach.h	/^  class FOREACH {$/;"	c	namespace:psimag
FOREACH2	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^  class FOREACH2 {$/;"	c	namespace:psimag
FOREACH2_	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^  class FOREACH2_ {$/;"	c	namespace:psimag
FOREACH2_	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^  class FOREACH2_<FunctorType, MatType, MatTypeRHS, TraitsLHS, TraitsRHS, 1> {$/;"	c	namespace:psimag
FOREACH2_ELS	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^  class FOREACH2_ELS {$/;"	c	namespace:psimag
FOREACH2_ELS	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^  class FOREACH2_ELS<FunctorType, MatType, MatTypeRHS, TraitsLHS, TraitsRHS, ROW, 1> {$/;"	c	namespace:psimag
FOREACH3	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^  class FOREACH3 {$/;"	c	namespace:psimag
FOREACH3_	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^  class FOREACH3_ {$/;"	c	namespace:psimag
FOREACH3_	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^  class FOREACH3_<FunctorType, MatTypeResult, MatTypeLHS, MatTypeRHS, TraitsResult, TraitsLHS, TraitsRHS, 0> {$/;"	c	namespace:psimag
FOREACH3_ELS	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^  class FOREACH3_ELS {$/;"	c	namespace:psimag
FOREACH3_ELS	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^  class FOREACH3_ELS<FunctorType, MatTypeResult, MatTypeLHS, MatTypeRHS, TraitsResult, TraitsLHS, TraitsRHS, ROW, 0> {$/;"	c	namespace:psimag
FOREACH_	PartialPsimag/Symmetry/Mat/MatForEach.h	/^  class FOREACH_ {$/;"	c	namespace:psimag
FOREACH_	PartialPsimag/Symmetry/Mat/MatForEach.h	/^  class FOREACH_<FunctorType, MatType, Traits, ArgType, 1> {$/;"	c	namespace:psimag
FOREACH_DIAG	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^  class FOREACH_DIAG {$/;"	c	namespace:psimag
FOREACH_DIAG_	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^  class FOREACH_DIAG_<Functor, MatType, Traits, 0> {$/;"	c	namespace:psimag
FOREACH_DIAG_	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^  class FOREACH_DIAG_{$/;"	c	namespace:psimag
FOREACH_ELS	PartialPsimag/Symmetry/Mat/MatForEach.h	/^  class FOREACH_ELS {$/;"	c	namespace:psimag
FOREACH_ELS	PartialPsimag/Symmetry/Mat/MatForEach.h	/^  class FOREACH_ELS<FunctorType, MatType, Traits, ArgType, ROW, 1> {$/;"	c	namespace:psimag
FOURORBITAL_H	4Orbital.h	/^#define FOURORBITAL_H$/;"	d
FOURORBITAL_H	FourOrbital.h	/^#define FOURORBITAL_H$/;"	d
FR	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      FR,  \/* fraction *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
FR	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      FR,  \/* Looking for the integer after the point *\/$/;"	e	enum:JsonParser::StatesMixin::states
FS	PythonScripts/MayaVi_Plot_of_FS.py	/^	FS = bands[:,i].min()*bands[:,i].max()$/;"	v
FSBand	ferminator.h	/^		std::vector<size_t> FSBand;$/;"	m	class:rpa::ferminator
FSCenters	ferminator.h	/^		std::vector<std::vector<FieldType> > FSCenters;$/;"	m	class:rpa::ferminator
FSnkz	parameters.h	/^		size_t FSnkz;$/;"	m	class:rpa::parameters
FSpoints	pairing.h	/^		ferminator<FieldType,BandsType,MatrixTemplate,ModelType,ConcurrencyType> FSpoints;$/;"	m	class:rpa::pairing
FX	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      FX,  \/* *.* *eE* *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
False	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void False() {$/;"	f	class:JsonParser::DefaultContext
FieldParser	PartialPsimag/Symmetry/FieldParser.h	/^    FieldParser(const char* value):       input(value) { parseInput(); }$/;"	f	class:psimag::FieldParser
FieldParser	PartialPsimag/Symmetry/FieldParser.h	/^    FieldParser(const std::string value): input(value) { parseInput(); }$/;"	f	class:psimag::FieldParser
FieldParser	PartialPsimag/Symmetry/FieldParser.h	/^  class FieldParser {$/;"	c	namespace:psimag
FieldType	1band_wSpin.h	/^		typedef Field 				        FieldType;$/;"	t	class:rpa::SingleBand_wSpin
FieldType	4Orbital.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::FourOrbital
FieldType	BSCCObilayer.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::model
FieldType	BaFeAs_5orb.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::BaFeAs
FieldType	FourOrbital.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::FourOrbital
FieldType	KFe2Se2.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::KFe2Se2
FieldType	PartialPsimag/IndexedMatrix.h	/^    typedef typename MatrixLikeType::value_type FieldType;$/;"	t	class:psimag::IndexedMatrix
FieldType	PartialPsimag/MatrixLike.h	/^      typedef typename InnerVectorType::value_type  FieldType;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
FieldType	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type FieldType;$/;"	t	class:psimag::ColSlice
FieldType	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type FieldType;$/;"	t	class:psimag::RowSlice
FieldType	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type FieldType;$/;"	t	class:psimag::TransposedColSlice
FieldType	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type FieldType;$/;"	t	class:psimag::TransposedRowSlice
FieldType	PartialPsimag/RealPart.h	/^    typedef value_type                                              FieldType;$/;"	t	class:psimag::RealPart
FieldType	PsimagLite/drivers/akimaSpline.cpp	/^typedef double FieldType;$/;"	t	file:
FieldType	PsimagLite/drivers/linearPrediction.cpp	/^typedef double FieldType;$/;"	t	file:
FieldType	PsimagLite/drivers/minimizer.cpp	/^	typedef double FieldType;$/;"	t	class:MyFunctionTest	file:
FieldType	PsimagLite/src/ChebyshevSerializer.h	/^		typedef typename VectorType::value_type FieldType;$/;"	t	class:PsimagLite::ChebyshevSerializer
FieldType	PsimagLite/src/ContinuedFraction.h	/^		typedef typename TridiagonalMatrixType::value_type FieldType;$/;"	t	class:PsimagLite::ContinuedFraction
FieldType	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    typedef typename MatrixLikeType::value_type FieldType;$/;"	t	class:JsonParser::MatrixParser
FieldType	PsimagLite/src/JSON/MatrixLike.h	/^      typedef typename InnerVectorType::value_type  FieldType;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
FieldType	PsimagLite/src/JSON/Transposer.h	/^    typedef value_type                          FieldType;$/;"	t	class:psimag::Transposed
FieldType	PsimagLite/src/JSON/Transposer.h	/^    typedef value_type                          FieldType;$/;"	t	class:psimag::Transposer
FieldType	PsimagLite/src/Minimizer.h	/^		typedef typename FunctionType::FieldType FieldType;$/;"	t	class:PsimagLite::Minimizer
FieldType	PsimagLite/src/Sort.h	/^	typedef typename ContainerType::value_type FieldType;$/;"	t	class:Sort
FieldType	SrRuO.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::SrRuO
FieldType	SrRuO_SO.h	/^		typedef Field 				        FieldType;$/;"	t	class:rpa::model
FieldType	bands.h	/^		typedef Field 					FieldType;$/;"	t	class:rpa::Bands
FieldType	bandstructure.h	/^		typedef Field				FieldType;$/;"	t	class:rpa::bandstructure
FieldType	bilayer.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::model
FieldType	bilayerFESC.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::model
FieldType	chi0.h	/^		typedef Field 							FieldType;$/;"	t	class:rpa::calcChi0Matrix
FieldType	chi0.h	/^		typedef Field 							FieldType;$/;"	t	class:rpa::chi0q
FieldType	coupledLadders.h	/^		typedef Field 				        FieldType;$/;"	t	class:rpa::model
FieldType	ferminator.h	/^		typedef Field 							FieldType;$/;"	t	class:rpa::ferminator
FieldType	gap.h	/^		typedef Field 					FieldType;$/;"	t	class:rpa::gap
FieldType	gaps2D.h	/^		typedef Field 				    FieldType;$/;"	t	class:rpa::gap2D
FieldType	gaps3D.h	/^        typedef Field                   FieldType;$/;"	t	class:rpa::gap3D
FieldType	interpolation.h	/^		typedef Field 						    FieldType;$/;"	t	class:rpa::interpolation
FieldType	main.cpp	/^typedef double FieldType;$/;"	t	file:
FieldType	momentumDomain.h	/^		typedef Field 								FieldType;$/;"	t	class:rpa::momentumDomain
FieldType	orthoIIBilayer.h	/^		typedef Field 						FieldType;$/;"	t	class:rpa::model
FieldType	pairing.h	/^		typedef Field 							FieldType;$/;"	t	class:rpa::pairing
FieldType	rpa.h	/^			typedef Field					FieldType;$/;"	t	class:rpa::interaction
FieldType	singleBand.h	/^		typedef Field 				        FieldType;$/;"	t	class:rpa::model
FieldType	susceptibility.h	/^			typedef Field 				               FieldType;$/;"	t	class:rpa::susceptibility
FieldType	tbFromFile.h	/^		typedef Field 				FieldType;$/;"	t	class:rpa::model
FiniteGroup	PartialPsimag/Symmetry/FiniteGroup.h	/^  class FiniteGroup {$/;"	c	namespace:psimag
First	PsimagLite/src/JSON/JSN_Writer.h	/^    typedef enum {First,Middle,Last} Position;$/;"	e	enum:dca::JSN::__anon119
FlatMapType	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    typedef std::map<std::wstring,const JsonParser::Whatever*> FlatMapType;$/;"	t	class:JsonParser::Whatever
FlatMapType	PsimagLite/src/JSON/JsonReader.h	/^    typedef JsonParser::Whatever::FlatMapType          FlatMapType;$/;"	t	class:dca::JsonReader
FlatPrintFunctionType	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    class FlatPrintFunctionType {$/;"	c	class:psimag::PRINT_FUNCTOR
Float	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void Float(ParseBuffer& s) {$/;"	f	class:JsonParser::DefaultContext
FloodTiler	PartialPsimag/Symmetry/FloodTiler.h	/^    FloodTiler(const CoordsType&             subLatticeVectors,$/;"	f	class:psimag::FloodTiler
FloodTiler	PartialPsimag/Symmetry/FloodTiler.h	/^    FloodTiler(const LatticeType&            subLat,$/;"	f	class:psimag::FloodTiler
FloodTiler	PartialPsimag/Symmetry/FloodTiler.h	/^  class FloodTiler {$/;"	c	namespace:psimag
FloodTilerType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef FloodTiler<Field,DIM,Occupant,Lattice,Algorithms>             FloodTilerType;$/;"	t	class:psimag::SuperCrystal
ForCentering	PartialPsimag/Symmetry/SpaceGroupConstructor2D.h	/^    static bool ForCentering(ArgType& arg) {$/;"	f	class:psimag::Explorer
ForEachCentering	PartialPsimag/Symmetry/ForEachCentering.h	/^  class ForEachCentering {$/;"	c	namespace:psimag
ForEachCentering_	PartialPsimag/Symmetry/ForEachCentering.h	/^  class ForEachCentering_ {$/;"	c	namespace:psimag
ForEachCentering_	PartialPsimag/Symmetry/ForEachCentering.h	/^  class ForEachCentering_<Field,DIM,0,Functor,ArgType> {$/;"	c	namespace:psimag
FourFold	PartialPsimag/Symmetry/FourFold2D.h	/^    FourFold():$/;"	f	class:psimag::FourFold
FourFold	PartialPsimag/Symmetry/FourFold2D.h	/^    FourFold(IN_TYPE p1, IN_TYPE p2):$/;"	f	class:psimag::FourFold
FourFold	PartialPsimag/Symmetry/FourFold2D.h	/^    FourFold(const CellTranslationType&    offset):$/;"	f	class:psimag::FourFold
FourFold	PartialPsimag/Symmetry/FourFold2D.h	/^  class FourFold<Field,2,Algorithms>: $/;"	c	namespace:psimag
FourFold	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class FourFold  {};$/;"	c	namespace:psimag
FourFoldN	PartialPsimag/Symmetry/FourFoldN2D.h	/^    FourFoldN():$/;"	f	class:psimag::FourFoldN
FourFoldN	PartialPsimag/Symmetry/FourFoldN2D.h	/^    FourFoldN(IN_TYPE p1, IN_TYPE p2):$/;"	f	class:psimag::FourFoldN
FourFoldN	PartialPsimag/Symmetry/FourFoldN2D.h	/^    FourFoldN(const CellTranslationType&    offset):$/;"	f	class:psimag::FourFoldN
FourFoldN	PartialPsimag/Symmetry/FourFoldN2D.h	/^  class FourFoldN<Field,2,Algorithms>: $/;"	c	namespace:psimag
FourFoldN	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class FourFoldN {};$/;"	c	namespace:psimag
FourFoldNType	PartialPsimag/Symmetry/FourFoldN2D.h	/^    typedef FourFoldN<Field,DIM,Algorithms>           FourFoldNType;$/;"	t	class:psimag::FourFoldN
FourFoldNType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef FourFoldN<Field,DIM,Algorithms>                                FourFoldNType;$/;"	t	class:psimag::SymmetryElements
FourFoldType	PartialPsimag/Symmetry/FourFold2D.h	/^    typedef FourFold<Field,DIM,Algorithms>             FourFoldType;$/;"	t	class:psimag::FourFold
FourFoldType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef FourFold<Field,DIM,Algorithms>                                 FourFoldType;$/;"	t	class:psimag::SymmetryElements
FourOrbital	4Orbital.h	/^		FourOrbital(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::FourOrbital
FourOrbital	4Orbital.h	/^	class FourOrbital {$/;"	c	namespace:rpa
FourOrbital	FourOrbital.h	/^		FourOrbital(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::FourOrbital
FourOrbital	FourOrbital.h	/^	class FourOrbital {$/;"	c	namespace:rpa
FourierTransform	PartialPsimag/OperationClosure.h	/^    typedef enum{FourierTransform,PLUS,MINUS,TIMES,DIVIDE,INV} Type;$/;"	e	enum:psimag::OP::__anon112
FourierTransform	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
Fraction	PartialPsimag/Symmetry/SymmetryElementName.h	/^  class Fraction {$/;"	c	namespace:psimag
FunctionParsing	PsimagLite/scripts/FunctionParsing.pm	/^package FunctionParsing;$/;"	p
GAPS2D_H	gaps2D.h	/^#define GAPS2D_H$/;"	d
GAPS3D_H	gaps3D.h	/^#define GAPS3D_H$/;"	d
GAP_H	gap.h	/^#define GAP_H$/;"	d
GBMV	PartialPsimag/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku, const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
GBMV	PartialPsimag/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku,const double &alpha,const double *A,$/;"	f	namespace:psimag::BLAS
GBMV	PartialPsimag/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku,const float &alpha,const float *A,$/;"	f	namespace:psimag::BLAS
GBMV	PartialPsimag/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
GBMV	PsimagLite/src/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku, const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
GBMV	PsimagLite/src/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku,const double &alpha,const double *A,$/;"	f	namespace:psimag::BLAS
GBMV	PsimagLite/src/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku,const float &alpha,const float *A,$/;"	f	namespace:psimag::BLAS
GBMV	PsimagLite/src/BLAS.h	/^inline void GBMV(char trans,int m,int n,int kl,int ku,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
GEEV	bands.h	/^	inline void GEEV(char jobvl,char jobvr,int n,psimag::Matrix<std::complex<double> > &A, int lda,$/;"	f	namespace:rpa
GEEV	pairing.h	/^	inline void GEEV(char jobvl,char jobvr,int n,psimag::Matrix<double> &A, int lda,$/;"	f	namespace:rpa
GEEV	utilities.h	/^inline void GEEV(char jobvl,char jobvr,int n,psimag::Matrix<std::complex<double> > &A, int lda,$/;"	f
GEMM	PartialPsimag/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const double &a,$/;"	f	namespace:psimag::BLAS
GEMM	PartialPsimag/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const float &a,$/;"	f	namespace:psimag::BLAS
GEMM	PartialPsimag/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const std::complex<double> &a,$/;"	f	namespace:psimag::BLAS
GEMM	PartialPsimag/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const std::complex<float> &a,$/;"	f	namespace:psimag::BLAS
GEMM	PartialPsimag/Matrix.h	/^  void GEMM(const Matrix<T>& A, const Matrix<T>& B, Matrix<T>& C, $/;"	f	namespace:psimag
GEMM	PsimagLite/src/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const double &a,$/;"	f	namespace:psimag::BLAS
GEMM	PsimagLite/src/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const float &a,$/;"	f	namespace:psimag::BLAS
GEMM	PsimagLite/src/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const std::complex<double> &a,$/;"	f	namespace:psimag::BLAS
GEMM	PsimagLite/src/BLAS.h	/^inline void GEMM(char c1,char c2,int sX,int sY,int sZ,const std::complex<float> &a,$/;"	f	namespace:psimag::BLAS
GEMM	rpa.h	/^	inline void GEMM(char transa,char transb,int m,int n,int k,$/;"	f	namespace:rpa
GEMV	PartialPsimag/BLAS.h	/^inline void GEMV(char c, int M, int N, $/;"	f	namespace:psimag::BLAS
GEMV	PsimagLite/src/BLAS.h	/^inline void GEMV(char c, int M, int N, $/;"	f	namespace:psimag::BLAS
GEOMETRY_DIR_H	PsimagLite/src/Geometry/GeometryDirection.h	/^#define GEOMETRY_DIR_H$/;"	d
GEOMETRY_FACTORY_H	PsimagLite/src/Geometry/GeometryFactory.h	/^#define GEOMETRY_FACTORY_H$/;"	d
GEOMETRY_H	PsimagLite/src/Geometry/Geometry.h	/^#define GEOMETRY_H$/;"	d
GEOMETRY_TERM_H	PsimagLite/src/Geometry/GeometryTerm.h	/^#define GEOMETRY_TERM_H$/;"	d
GEOMETRY_UTILS_H	PsimagLite/src/Geometry/GeometryUtils.h	/^#define GEOMETRY_UTILS_H$/;"	d
GER	PartialPsimag/BLAS.h	/^inline void GER(int m,int n,const double &alpha,const double *x,int incx,const double *y,$/;"	f	namespace:psimag::BLAS
GER	PartialPsimag/BLAS.h	/^inline void GER(int m,int n,const float &alpha,const float *x,int incx,const float *y,$/;"	f	namespace:psimag::BLAS
GER	PsimagLite/src/BLAS.h	/^inline void GER(int m,int n,const double &alpha,const double *x,int incx,const double *y,$/;"	f	namespace:psimag::BLAS
GER	PsimagLite/src/BLAS.h	/^inline void GER(int m,int n,const float &alpha,const float *x,int incx,const float *y,$/;"	f	namespace:psimag::BLAS
GERC	PartialPsimag/BLAS.h	/^inline void GERC(int m,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
GERC	PartialPsimag/BLAS.h	/^inline void GERC(int m,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
GERC	PsimagLite/src/BLAS.h	/^inline void GERC(int m,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
GERC	PsimagLite/src/BLAS.h	/^inline void GERC(int m,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
GERU	PartialPsimag/BLAS.h	/^inline void GERU(int m,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
GERU	PartialPsimag/BLAS.h	/^inline void GERU(int m,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
GERU	PsimagLite/src/BLAS.h	/^inline void GERU(int m,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
GERU	PsimagLite/src/BLAS.h	/^inline void GERU(int m,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
GESV	PartialPsimag/LAPACK.h	/^  inline void GESV(int ma,int mb,double* a,int lda,int* pivot,$/;"	f	namespace:psimag::LAPACK
GESV	PartialPsimag/LAPACK.h	/^  inline void GESV(int ma,int mb,float* a,int lda,int* pivot,$/;"	f	namespace:psimag::LAPACK
GESV	PartialPsimag/LAPACK.h	/^  inline void GESV(int ma,int mb,std::complex<double>* a,int lda,int* pivot,$/;"	f	namespace:psimag::LAPACK
GESV	PartialPsimag/LAPACK.h	/^  inline void GESV(int ma,int mb,std::complex<float>* a,int lda,int* pivot,$/;"	f	namespace:psimag::LAPACK
GESV	PartialPsimag/Matrix.h	/^  class GESV {$/;"	c	namespace:psimag
GET	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static T&  GET(MatType& m) {$/;"	f	class:psimag::ColMajorTraits::REF
GET	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static T&  GET(MatType& m) {$/;"	f	class:psimag::ConstantTraits::REF
GET	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static T&  GET(MatType& m) {$/;"	f	class:psimag::DoubleIndexTraits::REF
GET	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static T&  GET(MatType& m) {$/;"	f	class:psimag::ReverseDoubleIndexTraits::REF
GET	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static T&  GET(MatType& m) {$/;"	f	class:psimag::RowMajorTraits::REF
GET	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	static T& GET(SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF::ExtRetriever
GET	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	static T& GET(SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF::RotRetriever
GET	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	static T& GET(SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF::TransRetriever
GET	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      static T&  GET(SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF
GET	PartialPsimag/Symmetry/SymmetryElementName.h	/^    static std::string GET(Field value) {$/;"	f	class:psimag::Fraction
GETCONST	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static const T&  GETCONST(const MatType& m) {$/;"	f	class:psimag::ColMajorTraits::REF
GETCONST	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static const T&  GETCONST(const MatType& m) {$/;"	f	class:psimag::ConstantTraits::REF
GETCONST	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static const T&  GETCONST(const MatType& m) {$/;"	f	class:psimag::DoubleIndexTraits::REF
GETCONST	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static const T&  GETCONST(const MatType& m) {$/;"	f	class:psimag::ReverseDoubleIndexTraits::REF
GETCONST	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      static const T&  GETCONST(const MatType& m) {$/;"	f	class:psimag::RowMajorTraits::REF
GETCONST	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	static const T& GETCONST(const SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF::ExtRetriever
GETCONST	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	static const T& GETCONST(const SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF::RotRetriever
GETCONST	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	static const T& GETCONST(const SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF::TransRetriever
GETCONST	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      static const T&  GETCONST(const SeitzMatrixType& m) {$/;"	f	class:psimag::SeitzMatrixTraits::REF
GETRF	rpa.h	/^	inline void GETRF(int m, int n, $/;"	f	namespace:rpa
GETRF	utilities.h	/^inline void GETRF(int m, int n, $/;"	f
GETRI	rpa.h	/^	inline void GETRI(int m, $/;"	f	namespace:rpa
GETRI	utilities.h	/^inline void GETRI(int m, $/;"	f
GO	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      GO,  \/* start    *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
GO	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      GO,  \/* start    *\/$/;"	e	enum:JsonParser::StatesMixin::states
GREENSFUNCTION_H	greensFunction.h	/^#define GREENSFUNCTION_H$/;"	d
GSL_WRAPPER_H_	PsimagLite/src/GslWrapper.h	/^#define GSL_WRAPPER_H_$/;"	d
GapType	susceptibility.h	/^			typedef rpa::gap2D<FieldType,psimag::Matrix,ConcurrencyType> GapType;$/;"	t	class:rpa::susceptibility
GapType	susceptibility.h	/^			typedef rpa::gap3D<FieldType,psimag::Matrix, ModelType, ConcurrencyType> GapType;$/;"	t	class:rpa::susceptibility
Geometry	PsimagLite/src/Geometry/Geometry.h	/^			Geometry(IoInputter& io,bool debug=false)$/;"	f	class:PsimagLite::Geometry
Geometry	PsimagLite/src/Geometry/Geometry.h	/^	class Geometry {$/;"	c	namespace:PsimagLite
GeometryDirection	PsimagLite/src/Geometry/GeometryDirection.h	/^			GeometryDirection(IoInputter& io,size_t dirId,size_t edof,$/;"	f	class:PsimagLite::GeometryDirection
GeometryDirection	PsimagLite/src/Geometry/GeometryDirection.h	/^	class GeometryDirection {$/;"	c	namespace:PsimagLite
GeometryDirectionType	PsimagLite/src/Geometry/GeometryTerm.h	/^			typedef GeometryDirection<RealType,GeometryFactory> GeometryDirectionType;$/;"	t	class:PsimagLite::GeometryTerm
GeometryFactory	PsimagLite/src/Geometry/GeometryFactory.h	/^		GeometryFactory() $/;"	f	class:PsimagLite::GeometryFactory
GeometryFactory	PsimagLite/src/Geometry/GeometryFactory.h	/^		GeometryFactory(const GeometryFactory& g)$/;"	f	class:PsimagLite::GeometryFactory
GeometryFactory	PsimagLite/src/Geometry/GeometryFactory.h	/^	class GeometryFactory {$/;"	c	namespace:PsimagLite
GeometryTerm	PsimagLite/src/Geometry/GeometryTerm.h	/^			GeometryTerm(IoInputter& io,size_t termId,size_t linSize,bool debug=false) :$/;"	f	class:PsimagLite::GeometryTerm
GeometryTerm	PsimagLite/src/Geometry/GeometryTerm.h	/^	class GeometryTerm {$/;"	c	namespace:PsimagLite
GeometryTermType	PsimagLite/src/Geometry/Geometry.h	/^			typedef GeometryTerm<RealType> GeometryTermType;$/;"	t	class:PsimagLite::Geometry
GeometryUtils	PsimagLite/src/Geometry/GeometryUtils.h	/^	namespace GeometryUtils {$/;"	n	namespace:PsimagLite
Glide	PartialPsimag/Symmetry/Glide2D.h	/^    Glide():$/;"	f	class:psimag::Glide
Glide	PartialPsimag/Symmetry/Glide2D.h	/^    Glide(const LatticeCoordinatesType&  orientation,$/;"	f	class:psimag::Glide
Glide	PartialPsimag/Symmetry/Glide2D.h	/^    Glide(const LatticeCoordinatesType& orientation,$/;"	f	class:psimag::Glide
Glide	PartialPsimag/Symmetry/Glide2D.h	/^  class Glide<Field,2,Algorithms>: $/;"	c	namespace:psimag
Glide	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class Glide     {};$/;"	c	namespace:psimag
GlideType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef Glide<Field,DIM,Algorithms>                           GlideType;$/;"	t	class:psimag::Glide
GlideType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef Glide<Field,DIM,Algorithms>                                    GlideType;$/;"	t	class:psimag::SymmetryElements
GroupAction	PartialPsimag/Symmetry/GroupAction.h	/^    GroupAction(const AppliedSymmetryElementsType&  applied,$/;"	f	class:psimag::GroupAction
GroupAction	PartialPsimag/Symmetry/GroupAction.h	/^  class GroupAction: $/;"	c	namespace:psimag
GroupActionType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef GroupAction<Field,DIM,Occupant,LatticeTemplate,Algorithms>        GroupActionType;$/;"	t	class:psimag::SymmetryGroup
GroupMultiplicationTable	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    GroupMultiplicationTable(const LatticeWithPatternType&      lpat):$/;"	f	class:psimag::GroupMultiplicationTable
GroupMultiplicationTable	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^  class GroupMultiplicationTable:$/;"	c	namespace:psimag
GroupMultiplicationTableType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef GroupMultiplicationTable<Field,DIM,Occupant,LatticeTemplate,Algorithms> GroupMultiplicationTableType;$/;"	t	class:psimag::SymmetryGroup
GroupType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef std::map<std::string,AppliedSymmetryElementPairType>              GroupType;$/;"	t	class:psimag::GroupAction
GroupType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef std::map<std::string,AppliedSymmetryElementPairType>                    GroupType;$/;"	t	class:psimag::GroupMultiplicationTable
GroupType	PartialPsimag/Symmetry/Star.h	/^    typedef std::map<std::string,AppliedSymmetryElementPairType>              GroupType;$/;"	t	class:psimag::Star
GroupType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef std::map<std::string,AppliedSymmetryElementPairType>              GroupType;$/;"	t	class:psimag::SymmetryGroup
GslWrapper	PsimagLite/src/GslWrapper.h	/^	class GslWrapper {$/;"	c	namespace:PsimagLite
GslWrapperFunctionType	PsimagLite/src/GslWrapper.h	/^		typedef double (* GslWrapperFunctionType) (double, void * );$/;"	t	class:PsimagLite::GslWrapper
H	PartialPsimag/Symmetry/TypeManip.h	/^        typedef typename TypeManip_Private::ConversionHelper<T, U> H;$/;"	t	struct:psimag::Conversion
HBMV	PartialPsimag/BLAS.h	/^inline void HBMV(char uplo,int n,int k,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HBMV	PartialPsimag/BLAS.h	/^inline void HBMV(char uplo,int n,int k,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HBMV	PsimagLite/src/BLAS.h	/^inline void HBMV(char uplo,int n,int k,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HBMV	PsimagLite/src/BLAS.h	/^inline void HBMV(char uplo,int n,int k,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HEADERSH	PsimagLite/drivers/Makefile	/^HEADERSH = ..\/src\/AkimaSpline.h ..\/src\/Vector.h ..\/src\/SampleCRSMatrix.h ..\/src\/Minimizer.h$/;"	m
HEMM	PartialPsimag/BLAS.h	/^inline void HEMM(char c1,char c2,int sX,int sY, const std::complex<float> &a,$/;"	f	namespace:psimag::BLAS
HEMM	PartialPsimag/BLAS.h	/^inline void HEMM(char c1,char c2,int sX,int sY,const std::complex<double> &a,$/;"	f	namespace:psimag::BLAS
HEMM	PsimagLite/src/BLAS.h	/^inline void HEMM(char c1,char c2,int sX,int sY, const std::complex<float> &a,$/;"	f	namespace:psimag::BLAS
HEMM	PsimagLite/src/BLAS.h	/^inline void HEMM(char c1,char c2,int sX,int sY,const std::complex<double> &a,$/;"	f	namespace:psimag::BLAS
HEMV	PartialPsimag/BLAS.h	/^inline void HEMV(char uplo,int n,const std::complex<double> &alpha,const std::complex<double> *a,$/;"	f	namespace:psimag::BLAS
HEMV	PartialPsimag/BLAS.h	/^inline void HEMV(char uplo,int n,const std::complex<float> &alpha,const std::complex<float> *a,$/;"	f	namespace:psimag::BLAS
HEMV	PsimagLite/src/BLAS.h	/^inline void HEMV(char uplo,int n,const std::complex<double> &alpha,const std::complex<double> *a,$/;"	f	namespace:psimag::BLAS
HEMV	PsimagLite/src/BLAS.h	/^inline void HEMV(char uplo,int n,const std::complex<float> &alpha,const std::complex<float> *a,$/;"	f	namespace:psimag::BLAS
HER	PartialPsimag/BLAS.h	/^inline void HER(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HER	PartialPsimag/BLAS.h	/^inline void HER(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HER	PsimagLite/src/BLAS.h	/^inline void HER(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HER	PsimagLite/src/BLAS.h	/^inline void HER(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HER2	PartialPsimag/BLAS.h	/^inline void HER2(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HER2	PartialPsimag/BLAS.h	/^inline void HER2(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HER2	PsimagLite/src/BLAS.h	/^inline void HER2(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HER2	PsimagLite/src/BLAS.h	/^inline void HER2(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HER2k	PartialPsimag/BLAS.h	/^inline void HER2k(char uplo,char trans,int n,int k,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HER2k	PartialPsimag/BLAS.h	/^inline void HER2k(char uplo,char trans,int n,int k,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HER2k	PsimagLite/src/BLAS.h	/^inline void HER2k(char uplo,char trans,int n,int k,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HER2k	PsimagLite/src/BLAS.h	/^inline void HER2k(char uplo,char trans,int n,int k,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HERK	PartialPsimag/BLAS.h	/^inline void HERK(char UPLO,char TRANS,int N,int K,const std::complex<double> &ALPHA,$/;"	f	namespace:psimag::BLAS
HERK	PartialPsimag/BLAS.h	/^inline void HERK(char UPLO,char TRANS,int N,int K,const std::complex<float> &ALPHA,$/;"	f	namespace:psimag::BLAS
HERK	PsimagLite/src/BLAS.h	/^inline void HERK(char UPLO,char TRANS,int N,int K,const std::complex<double> &ALPHA,$/;"	f	namespace:psimag::BLAS
HERK	PsimagLite/src/BLAS.h	/^inline void HERK(char UPLO,char TRANS,int N,int K,const std::complex<float> &ALPHA,$/;"	f	namespace:psimag::BLAS
HOST_INFO_H	PsimagLite/src/HostInfo.h	/^#define HOST_INFO_H$/;"	d
HPMV	PartialPsimag/BLAS.h	/^inline void HPMV(char uplo,int n,const std::complex<double> &alpha,const std::complex<double> *ap,$/;"	f	namespace:psimag::BLAS
HPMV	PartialPsimag/BLAS.h	/^inline void HPMV(char uplo,int n,const std::complex<float> &alpha,const std::complex<float> *ap,$/;"	f	namespace:psimag::BLAS
HPMV	PsimagLite/src/BLAS.h	/^inline void HPMV(char uplo,int n,const std::complex<double> &alpha,const std::complex<double> *ap,$/;"	f	namespace:psimag::BLAS
HPMV	PsimagLite/src/BLAS.h	/^inline void HPMV(char uplo,int n,const std::complex<float> &alpha,const std::complex<float> *ap,$/;"	f	namespace:psimag::BLAS
HPR	PartialPsimag/BLAS.h	/^inline void HPR(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HPR	PartialPsimag/BLAS.h	/^inline void HPR(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HPR	PsimagLite/src/BLAS.h	/^inline void HPR(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HPR	PsimagLite/src/BLAS.h	/^inline void HPR(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HPR2	PartialPsimag/BLAS.h	/^inline void HPR2(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HPR2	PartialPsimag/BLAS.h	/^inline void HPR2(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HPR2	PsimagLite/src/BLAS.h	/^inline void HPR2(char uplo,int n,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
HPR2	PsimagLite/src/BLAS.h	/^inline void HPR2(char uplo,int n,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
HermiteNormalForm	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    HermiteNormalForm():$/;"	f	class:psimag::HermiteNormalForm
HermiteNormalForm	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    HermiteNormalForm(const BaseType& origional):$/;"	f	class:psimag::HermiteNormalForm
HermiteNormalForm	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^  class HermiteNormalForm: public Mat< Field, NROW, NCOL, Traits> {$/;"	c	namespace:psimag
HermiteNormalFormType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef HermiteNormalForm<Field, DIM+1, DIM+1>  HermiteNormalFormType;$/;"	t	class:psimag::SymmetryOperation
HostInfo	PsimagLite/src/HostInfo.h	/^	class HostInfo {$/;"	c	namespace:PsimagLite
INCLUDES	Makefile	/^INCLUDES =  -I. \\$/;"	m
INCLUDES	PsimagLite/src/JSON/JsonParser/Makefile	/^INCLUDES =  -I. -I$(SRC_DIR) $/;"	m
IND	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    enum{ IND=0 };$/;"	e	enum:psimag::LatticeCoordinates::__anon103
INTERPOLATION_H	interpolation.h	/^#define INTERPOLATION_H$/;"	d
INV	PartialPsimag/Matrix.h	/^  INV(const psimag::Matrix<T>& mat)$/;"	f	namespace:psimag
INV	PartialPsimag/OperationClosure.h	/^    typedef enum{FourierTransform,PLUS,MINUS,TIMES,DIVIDE,INV} Type;$/;"	e	enum:psimag::OP::__anon112
INV	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
INVERT	PartialPsimag/Matrix.h	/^  class INVERT {$/;"	c	namespace:psimag
INVERT	PartialPsimag/MatrixLike.h	/^    class INVERT {$/;"	c	namespace:psimag::MatrixLike
INVERT	PsimagLite/src/JSON/MatrixLike.h	/^    class INVERT {$/;"	c	namespace:psimag::MatrixLike
IOSIMPLE_HEADER_H	PsimagLite/src/IoSimple.h	/^#define IOSIMPLE_HEADER_H$/;"	d
IT	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      IT,  \/* integer  *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
IT	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      IT,  \/* Looking for an integer  *\/$/;"	e	enum:JsonParser::StatesMixin::states
IX	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      IX = -20, \/* integer detected by 1-9 *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
IdentityElement	PartialPsimag/Symmetry/IdentityElement2D.h	/^    IdentityElement():$/;"	f	class:psimag::IdentityElement
IdentityElement	PartialPsimag/Symmetry/IdentityElement2D.h	/^  class IdentityElement<Field,2,Algorithms>: $/;"	c	namespace:psimag
IdentityElement	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class IdentityElement {};$/;"	c	namespace:psimag
IdentityElementType	PartialPsimag/Symmetry/IdentityElement2D.h	/^    typedef IdentityElement<Field,DIM,Algorithms>     IdentityElementType;$/;"	t	class:psimag::IdentityElement
IdentityElementType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef IdentityElement<Field,DIM,Algorithms>                          IdentityElementType;$/;"	t	class:psimag::SymmetryElements
IdentityReducerType	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^    class IdentityReducerType {$/;"	c	class:psimag::MakeIDENTITY
In	PsimagLite/src/IoSimple.h	/^				In() { }$/;"	f	class:PsimagLite::IoSimple::In
In	PsimagLite/src/IoSimple.h	/^				In(std::string const &fn) : filename_(fn), fin_(fn.c_str())$/;"	f	class:PsimagLite::IoSimple::In
In	PsimagLite/src/IoSimple.h	/^		class In {$/;"	c	class:PsimagLite::IoSimple
Index	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class Index { $/;"	c	class:psimag::ConstantTraits
Index	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class Index { public: enum { VAL=COL_*NROW_+ROW_ }; };$/;"	c	class:psimag::ColMajorTraits
Index	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class Index {public: enum { VAL=ROW_*NROW_+COL_ }; };$/;"	c	class:psimag::RowMajorTraits
IndexedMatrix	PartialPsimag/IndexedMatrix.h	/^    IndexedMatrix(const MatrixLikeType& m, $/;"	f	class:psimag::IndexedMatrix
IndexedMatrix	PartialPsimag/IndexedMatrix.h	/^  class IndexedMatrix {$/;"	c	namespace:psimag
InnerVectorType	PartialPsimag/MatrixLike.h	/^      typedef typename DoubleVectorType::value_type InnerVectorType;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
InnerVectorType	PsimagLite/src/JSON/MatrixLike.h	/^      typedef typename DoubleVectorType::value_type InnerVectorType;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
Int2Type	PartialPsimag/Symmetry/TypeManip.h	/^    struct Int2Type$/;"	s	namespace:psimag
IntMatrixType	pairing.h	/^		typedef MatrixTemplate<size_t> 			IntMatrixType;$/;"	t	class:rpa::pairing
IntMatrixType	parameters.h	/^		typedef MatrixTemplate<size_t> 			IntMatrixType;$/;"	t	class:rpa::parameters
IntPairType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef const std::pair<int,int>                                          IntPairType;$/;"	t	class:psimag::GroupAction
IntPairType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef const std::pair<int,int>                                                IntPairType;$/;"	t	class:psimag::GroupMultiplicationTable
IntPairType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef const std::pair<int,int>                                          IntPairType;$/;"	t	class:psimag::SymmetryGroup
Integer	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void Integer(ParseBuffer& s) {$/;"	f	class:JsonParser::DefaultContext
IntegerType	PartialPsimag/Symmetry/rational.h	/^  typedef Int            IntegerType;$/;"	t	class:rational
Integrate	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
InternalMatrix	PsimagLite/src/ChebyshevSolver.h	/^			InternalMatrix(const MatrixType& mat)$/;"	f	class:PsimagLite::ChebyshevSolver::InternalMatrix
InternalMatrix	PsimagLite/src/ChebyshevSolver.h	/^		class InternalMatrix {$/;"	c	class:PsimagLite::ChebyshevSolver
IntervalType	PsimagLite/drivers/akimaSpline.cpp	/^typedef AkimaSplineType::IntervalType IntervalType;$/;"	t	file:
IntervalType	PsimagLite/src/AkimaSpline.h	/^		typedef std::pair<RealType,RealType> IntervalType;$/;"	t	class:AkimaSpline
Inverse	PartialPsimag/Symmetry/CellRotation.h	/^  void Inverse(const CellRotation<Field, DIM>& cellRotation,$/;"	f	namespace:psimag
Inverse	PartialPsimag/Symmetry/Mat/MatInverse.h	/^  inline void Inverse(const MatType<T,2,2,Traits>& m, $/;"	f	namespace:psimag
Inverse	PartialPsimag/Symmetry/Mat/MatInverse.h	/^  inline void Inverse(const MatType<T,3,3,Traits>& m, $/;"	f	namespace:psimag
Inverse	PartialPsimag/Symmetry/Mat/MatInverse.h	/^  inline void Inverse(const MatType<T,NROW,NCOL,Traits>& m, $/;"	f	namespace:psimag
Inverse	PartialPsimag/Symmetry/SeitzMatrix.h	/^  void Inverse(SeitzMatrix<Field, DIM>& m, SeitzMatrix<Field, DIM>& inv) {$/;"	f	namespace:psimag
InverseLatticeTransformation	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    InverseLatticeTransformation(const LatticeTransformationType& latticeTransformation): $/;"	f	class:psimag::InverseLatticeTransformation
InverseLatticeTransformation	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^  class InverseLatticeTransformation {$/;"	c	namespace:psimag
InverseLatticeTransformationType	PartialPsimag/Symmetry/LatticeTransformation.h	/^    typedef InverseLatticeTransformation<Field,DIM> InverseLatticeTransformationType;$/;"	t	class:psimag::LatticeTransformation
IoSimple	PsimagLite/src/IoSimple.h	/^	class IoSimple {$/;"	c	namespace:PsimagLite
IoSimpleIn	PsimagLite/src/IoSimple.h	/^		IoSimpleIn(const char* fn) : PsimagLite::IoSimple::In(std::string(fn)) { } $/;"	f	class:Spf::IoSimpleIn
IoSimpleIn	PsimagLite/src/IoSimple.h	/^	class IoSimpleIn : public PsimagLite::IoSimple::In {$/;"	c	namespace:Spf
J	PythonScripts/plotChiRPAAlongHighSym.py	/^		J  = float(sys.argv[3])$/;"	v
J	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
J	rpa.h	/^			Field U,Up,J,Jp;$/;"	m	class:rpa::interaction
JACKSON	PsimagLite/src/ChebyshevSerializer.h	/^		enum {JACKSON,LORENTZ,DIRICHLET};$/;"	e	enum:PsimagLite::KernelPolynomialParameters::__anon121
JSN	PsimagLite/src/JSON/JSN_Writer.h	/^    JSN(size_t offset_=0):$/;"	f	class:dca::JSN
JSN	PsimagLite/src/JSON/JSN_Writer.h	/^  class JSN {$/;"	c	namespace:dca
JSON_T_ARRAY_BEGIN	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_ARRAY_BEGIN,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_ARRAY_END	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_ARRAY_END,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_FALSE	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_FALSE,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_FLOAT	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_FLOAT,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_INTEGER	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_INTEGER,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_KEY	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_KEY,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_MAX	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_MAX$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_NONE	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_NONE = 0,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_NULL	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_NULL,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_OBJECT_BEGIN	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_OBJECT_BEGIN,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_OBJECT_END	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_OBJECT_END,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_STRING	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_STRING,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JSON_T_TRUE	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^      JSON_T_TRUE,$/;"	e	enum:JsonParser::TypesMixin::__anon116
JUST_NUMBERS	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    static void JUST_NUMBERS(const MatType& m, std::ostream& os, bool flat=false) {$/;"	f	class:psimag::MAT_PRINT
Jp	PythonScripts/plotChiRPAAlongHighSym.py	/^		Jp = float(sys.argv[4])$/;"	v
Jp	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
Jp	rpa.h	/^			Field U,Up,J,Jp;$/;"	m	class:rpa::interaction
JsonAccessor	PsimagLite/src/JSON/JsonReader.h	/^    typedef JsonParser::Whatever                       JsonAccessor;$/;"	t	class:dca::JsonReader
JsonDataType	PsimagLite/src/JSON/JsonReader.h	/^    typedef JsonParser::DefaultContext                 JsonDataType;$/;"	t	class:dca::JsonReader
JsonParser	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    JsonParser():$/;"	f	class:JsonParser::JsonParser
JsonParser	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^  class JsonParser: $/;"	c	namespace:JsonParser
JsonParser	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/StateTranslationTable.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^namespace JsonParser {$/;"	n
JsonParser	PsimagLite/src/JSON/JsonParser/Whatever.h	/^namespace JsonParser {$/;"	n
JsonParser_ActionsMixin_H	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^#define  JsonParser_ActionsMixin_H$/;"	d
JsonParser_AugmentedStateTranslationTable_H	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^#define  JsonParser_AugmentedStateTranslationTable_H$/;"	d
JsonParser_CharacterMapper_H	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^#define  JsonParser_CharacterMapper_H$/;"	d
JsonParser_DefaultContext_H	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^#define  JsonParser_DefaultContext_H$/;"	d
JsonParser_H	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^#define  JsonParser_H$/;"	d
JsonParser_MAIN_H	PsimagLite/src/JSON/JsonParser/main.cpp	/^#define  JsonParser_MAIN_H$/;"	d	file:
JsonParser_MatrixParser_H	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^#define  JsonParser_MatrixParser_H$/;"	d
JsonParser_ModesMixin_H	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^#define  JsonParser_ModesMixin_H$/;"	d
JsonParser_ParseBuffer_H	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^#define  JsonParser_ParseBuffer_H$/;"	d
JsonParser_StateTranslationTable_H	PsimagLite/src/JSON/JsonParser/StateTranslationTable.h	/^#define  JsonParser_StateTranslationTable_H$/;"	d
JsonParser_StatesAndActionsMixin_H	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^#define  JsonParser_StatesAndActionsMixin_H$/;"	d
JsonParser_StatesMixin_H	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^#define  JsonParser_StatesMixin_H$/;"	d
JsonParser_TypesMixin_H	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^#define  JsonParser_TypesMixin_H$/;"	d
JsonParser_Whatever_H	PsimagLite/src/JSON/JsonParser/Whatever.h	/^#define  JsonParser_Whatever_H$/;"	d
JsonReader	PsimagLite/src/JSON/JsonReader.h	/^    JsonReader(std::string inputFileName):$/;"	f	class:dca::JsonReader
JsonReader	PsimagLite/src/JSON/JsonReader.h	/^  class JsonReader$/;"	c	namespace:dca
JsonType	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^    } JsonType;$/;"	t	class:JsonParser::TypesMixin	typeref:enum:JsonParser::TypesMixin::__anon116
KE	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      KE,  \/* key      *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
KFE2SE2_H	KFe2Se2.h	/^#define KFE2SE2_H$/;"	d
KFe2Se2	KFe2Se2.h	/^		KFe2Se2(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::KFe2Se2
KFe2Se2	KFe2Se2.h	/^	class KFe2Se2 {$/;"	c	namespace:rpa
KISS	PartialPsimag/KISS.h	/^    explicit KISS(seed_type s=1) : _small(217), _fixed(20030711)$/;"	f	class:psimag::KISS
KISS	PartialPsimag/KISS.h	/^class KISS {$/;"	c	namespace:psimag
KTWONIFFOUR	PsimagLite/src/Geometry/GeometryFactory.h	/^		enum {CHAIN,LADDER,LADDERX,LADDERBATH,KTWONIFFOUR};$/;"	e	enum:PsimagLite::GeometryFactory::__anon126
KTWONIFFOUR_H	PsimagLite/src/Geometry/KTwoNiFFour.h	/^#define KTWONIFFOUR_H$/;"	d
KTwoNiFFour	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		KTwoNiFFour(size_t linSize,int signChange) $/;"	f	class:PsimagLite::KTwoNiFFour
KTwoNiFFour	PsimagLite/src/Geometry/KTwoNiFFour.h	/^	class KTwoNiFFour  {$/;"	c	namespace:PsimagLite
KernelParametersType	PsimagLite/src/ChebyshevSerializer.h	/^		typedef KernelPolynomialParameters<RealType> KernelParametersType;$/;"	t	class:PsimagLite::ChebyshevSerializer
KernelPolynomialParameters	PsimagLite/src/ChebyshevSerializer.h	/^		KernelPolynomialParameters(size_t type1,size_t cutoff1,const RealType& lambda1)$/;"	f	struct:PsimagLite::KernelPolynomialParameters
KernelPolynomialParameters	PsimagLite/src/ChebyshevSerializer.h	/^	struct KernelPolynomialParameters {$/;"	s	namespace:PsimagLite
Key	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void Key(const std::wstring& s) {$/;"	f	class:JsonParser::DefaultContext
KeyReference	PsimagLite/src/JSON/JSN_Writer.h	/^      KeyReference(std::string k, JSN& w):$/;"	f	class:dca::JSN::KeyReference
KeyReference	PsimagLite/src/JSON/JSN_Writer.h	/^    class KeyReference {$/;"	c	class:dca::JSN
L1Norm	PartialPsimag/Vec.h	/^  T L1Norm(const Vec <T,DIM> &a )$/;"	f	namespace:psimag
L1Norm	PartialPsimag/Vec.h	/^  template < typename T > T L1Norm(const Vec<T,2>& a)$/;"	f	namespace:psimag
L1Norm	PartialPsimag/Vec.h	/^  template < typename T > T L1Norm(const Vec<T,3>& a)$/;"	f	namespace:psimag
L2NORM	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^  class L2NORM {$/;"	c	namespace:psimag
L2Norm	PartialPsimag/Vec.h	/^  T L2Norm(const Vec <T,DIM> &a)$/;"	f	namespace:psimag
L2Norm	PartialPsimag/Vec.h	/^  template < typename T > T L2Norm(const Vec<T,2>& a)$/;"	f	namespace:psimag
L2Norm	PartialPsimag/Vec.h	/^  template < typename T > T L2Norm(const Vec<T,3>& a)$/;"	f	namespace:psimag
L2Norm	PartialPsimag/Vec.h	/^  template<typename T> T L2Norm(T a) { return std::abs(a); }$/;"	f	namespace:psimag
LADDER	PsimagLite/src/Geometry/GeometryFactory.h	/^		enum {CHAIN,LADDER,LADDERX,LADDERBATH,KTWONIFFOUR};$/;"	e	enum:PsimagLite::GeometryFactory::__anon126
LADDERBATH	PsimagLite/src/Geometry/GeometryFactory.h	/^		enum {CHAIN,LADDER,LADDERX,LADDERBATH,KTWONIFFOUR};$/;"	e	enum:PsimagLite::GeometryFactory::__anon126
LADDERX	PsimagLite/src/Geometry/GeometryFactory.h	/^		enum {CHAIN,LADDER,LADDERX,LADDERBATH,KTWONIFFOUR};$/;"	e	enum:PsimagLite::GeometryFactory::__anon126
LADDERX_H	PsimagLite/src/Geometry/LadderX.h	/^#define LADDERX_H$/;"	d
LADDER_BATH_H	PsimagLite/src/Geometry/LadderBath.h	/^#define LADDER_BATH_H$/;"	d
LADDER_H	PsimagLite/src/Geometry/Ladder.h	/^#define LADDER_H$/;"	d
LANCZOSSOLVER_HEADER_H	PsimagLite/src/LanczosSolver.h	/^#define LANCZOSSOLVER_HEADER_H$/;"	d
LANCZOS_VECTORS_HEADER_H	PsimagLite/src/LanczosVectors.h	/^#define LANCZOS_VECTORS_HEADER_H$/;"	d
LAPACK	PartialPsimag/LAPACK.h	/^namespace LAPACK {$/;"	n	namespace:psimag
LAPACK_H_	PsimagLite/src/Lapack.h	/^#define LAPACK_H_$/;"	d
LAST_COL	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      static const bool LAST_COL   = (COL_ == DIM);$/;"	m	class:psimag::SeitzMatrixTraits::REF
LAST_INSTANCE	PsimagLite/src/IoSimple.h	/^				static const int LAST_INSTANCE=-1;$/;"	m	class:PsimagLite::IoSimple::In
LCOL	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { LCOL=0, RROW=LCOL };$/;"	e	enum:psimag::MatMultVecPos::__anon4
LCOL	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { LCOL=0, RROW=LCOL };$/;"	e	enum:psimag::MatMultVecRow::__anon6
LDFLAGS	PsimagLite/drivers/Makefile	/^LDFLAGS =       -lm  -lpthread -lblas -llapack$/;"	m
LENGTH	PartialPsimag/Symmetry/Mat/Mat.h	/^    enum { LENGTH=NCOL*NROW };$/;"	e	enum:psimag::Mat::__anon17
LHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsLHS::ElType LHSType;$/;"	t	class:psimag::COPY::CopyFunctionType
LHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsLHS::ElType LHSType;$/;"	t	class:psimag::COPY::CopyMinusFunctionType
LHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsLHS::ElType LHSType;$/;"	t	class:psimag::COPY::CopyPlusFunctionType
LHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsLHS::ElType LHSType;$/;"	t	class:psimag::COPY::CopyTimesFunctionType
LHSType	PartialPsimag/Symmetry/Mat/MatDifference.h	/^      typedef typename TraitsLHS::ElType    LHSType;$/;"	t	class:psimag::DIFFERENCE::DifferenceFunctionType
LHSType	PartialPsimag/Symmetry/Mat/MatPrint.h	/^      typedef typename TraitsLHS::ElType LHSType;$/;"	t	class:psimag::PRINT_FUNCTOR::FlatPrintFunctionType
LHSType	PartialPsimag/Symmetry/Mat/MatPrint.h	/^      typedef typename TraitsLHS::ElType LHSType;$/;"	t	class:psimag::PRINT_FUNCTOR::PrintFunctionType
LHSType	PartialPsimag/Symmetry/Mat/MatSum.h	/^      typedef typename TraitsLHS::ElType    LHSType;$/;"	t	class:psimag::SUM::SumFunctionType
LINEAR_PREDICTION_H	PsimagLite/src/LinearPrediction.h	/^#define LINEAR_PREDICTION_H$/;"	d
LINE_MARKER_H	PsimagLite/src/LineMarker.h	/^#define LINE_MARKER_H$/;"	d
LORENTZ	PsimagLite/src/ChebyshevSerializer.h	/^		enum {JACKSON,LORENTZ,DIRICHLET};$/;"	e	enum:PsimagLite::KernelPolynomialParameters::__anon121
LROW	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { LROW=0, NLCOL=Traits::NCOL};$/;"	e	enum:psimag::MatMultVecRow::__anon7
LS	parameters.h	/^		bool LS;$/;"	m	class:rpa::parameters
Ladder	PsimagLite/src/Geometry/Ladder.h	/^		Ladder(size_t linSize,size_t leg) : linSize_(linSize),leg_(leg)$/;"	f	class:PsimagLite::Ladder
Ladder	PsimagLite/src/Geometry/Ladder.h	/^	class Ladder  {$/;"	c	namespace:PsimagLite
LadderBath	PsimagLite/src/Geometry/LadderBath.h	/^			LadderBath(size_t linSize,size_t leg,size_t bathSitesPerSite) :$/;"	f	class:PsimagLite::LadderBath
LadderBath	PsimagLite/src/Geometry/LadderBath.h	/^	class LadderBath  {$/;"	c	namespace:PsimagLite
LadderType	PsimagLite/src/Geometry/LadderBath.h	/^			typedef Ladder LadderType;$/;"	t	class:PsimagLite::LadderBath
LadderType	PsimagLite/src/Geometry/LadderX.h	/^			typedef Ladder LadderType;$/;"	t	class:PsimagLite::LadderX
LadderX	PsimagLite/src/Geometry/LadderX.h	/^			LadderX(size_t linSize,size_t leg) : ladder_(linSize,leg),linSize_(linSize),leg_(leg)$/;"	f	class:PsimagLite::LadderX
LadderX	PsimagLite/src/Geometry/LadderX.h	/^	class LadderX  {$/;"	c	namespace:PsimagLite
LanczosMatrixType	PsimagLite/src/ChebyshevSolver.h	/^		typedef MatrixType LanczosMatrixType;$/;"	t	class:PsimagLite::ChebyshevSolver
LanczosMatrixType	PsimagLite/src/LanczosSolver.h	/^		typedef MatrixType LanczosMatrixType;$/;"	t	class:PsimagLite::LanczosSolver
LanczosSolver	PsimagLite/src/LanczosSolver.h	/^		LanczosSolver(MatrixType const &mat,$/;"	f	class:PsimagLite::LanczosSolver
LanczosSolver	PsimagLite/src/LanczosSolver.h	/^	class LanczosSolver {$/;"	c	namespace:PsimagLite
LanczosVectors	PsimagLite/src/LanczosVectors.h	/^		LanczosVectors(const MatrixType& mat,$/;"	f	class:PsimagLite::LanczosVectors
LanczosVectors	PsimagLite/src/LanczosVectors.h	/^	class LanczosVectors {$/;"	c	namespace:PsimagLite
LanczosVectorsType	PsimagLite/src/ChebyshevSolver.h	/^		typedef LanczosVectors<RealType,MatrixType,VectorType> LanczosVectorsType;$/;"	t	class:PsimagLite::ChebyshevSolver
LanczosVectorsType	PsimagLite/src/LanczosSolver.h	/^		typedef LanczosVectors<RealType,MatrixType,VectorType> LanczosVectorsType;$/;"	t	class:PsimagLite::LanczosSolver
Last	PsimagLite/src/JSON/JSN_Writer.h	/^    typedef enum {First,Middle,Last} Position;$/;"	e	enum:dca::JSN::__anon119
LastColRetriever	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^			      RotRetriever >::Result  LastColRetriever;$/;"	t	class:psimag::SeitzMatrixTraits::REF
LastRowType	PartialPsimag/Symmetry/SeitzMatrix.h	/^    typedef Vec<Field, DIM+1>                     LastRowType;$/;"	t	class:psimag::SeitzMatrix
Lattice	PartialPsimag/Symmetry/Lattice.h	/^    Lattice(): $/;"	f	class:psimag::Lattice
Lattice	PartialPsimag/Symmetry/Lattice.h	/^    Lattice(const BasisVectors& translations):$/;"	f	class:psimag::Lattice
Lattice	PartialPsimag/Symmetry/Lattice.h	/^    Lattice(const CellParamType& cellParameters): $/;"	f	class:psimag::Lattice
Lattice	PartialPsimag/Symmetry/Lattice.h	/^    Lattice(const Lattice& lat):$/;"	f	class:psimag::Lattice
Lattice	PartialPsimag/Symmetry/Lattice.h	/^  class Lattice: public SeitzMatrix<Field,DIM> {$/;"	c	namespace:psimag
LatticeCoordType	PartialPsimag/Symmetry/Lattice.h	/^    typedef LatticeCoordinates<DIM>                       LatticeCoordType;$/;"	t	class:psimag::Lattice
LatticeCoordinates	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    LatticeCoordinates(): BaseType() {}$/;"	f	class:psimag::LatticeCoordinates
LatticeCoordinates	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    LatticeCoordinates(const BaseType& v): BaseType(v) {}$/;"	f	class:psimag::LatticeCoordinates
LatticeCoordinates	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    LatticeCoordinates(const ThisType& v): BaseType(v) {}$/;"	f	class:psimag::LatticeCoordinates
LatticeCoordinates	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    LatticeCoordinates(int val): BaseType(val) {}$/;"	f	class:psimag::LatticeCoordinates
LatticeCoordinates	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  class LatticeCoordinates: public SeitzVector< int, DIM, 0 > {$/;"	c	namespace:psimag
LatticeCoordinatesType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef LatticeCoordinates<DIM>                                LatticeCoordinatesType;$/;"	t	class:psimag::AppliedSymmetryElement
LatticeCoordinatesType	PartialPsimag/Symmetry/FourFold2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::FourFold
LatticeCoordinatesType	PartialPsimag/Symmetry/FourFoldN2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::FourFoldN
LatticeCoordinatesType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef LatticeCoordinates<DIM>                               LatticeCoordinatesType;$/;"	t	class:psimag::Glide
LatticeCoordinatesType	PartialPsimag/Symmetry/IdentityElement2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::IdentityElement
LatticeCoordinatesType	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    typedef LatticeCoordinates<DIM>                 LatticeCoordinatesType;$/;"	t	class:psimag::InverseLatticeTransformation
LatticeCoordinatesType	PartialPsimag/Symmetry/LatticeTransformation.h	/^    typedef LatticeCoordinates<DIM>                 LatticeCoordinatesType;$/;"	t	class:psimag::LatticeTransformation
LatticeCoordinatesType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef LatticeCoordinates<DIM>                            LatticeCoordinatesType;$/;"	t	class:psimag::Mirror
LatticeCoordinatesType	PartialPsimag/Symmetry/SixFold2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::SixFold
LatticeCoordinatesType	PartialPsimag/Symmetry/SixFoldN2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::SixFoldN
LatticeCoordinatesType	PartialPsimag/Symmetry/SymmetryElement.h	/^    typedef LatticeCoordinates<DIM>                 LatticeCoordinatesType;$/;"	t	class:psimag::SymmetryElement
LatticeCoordinatesType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef LatticeCoordinates<DIM>                                        LatticeCoordinatesType;$/;"	t	class:psimag::SymmetryElements
LatticeCoordinatesType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef LatticeCoordinates<DIM>                 LatticeCoordinatesType;$/;"	t	class:psimag::SymmetryOperation
LatticeCoordinatesType	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    typedef LatticeCoordinates<DIM>                                        LatticeCoordinatesType;$/;"	t	class:psimag::SymmetryOperations
LatticeCoordinatesType	PartialPsimag/Symmetry/ThreeFold2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::ThreeFold
LatticeCoordinatesType	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::ThreeFoldN
LatticeCoordinatesType	PartialPsimag/Symmetry/TwoFold2D.h	/^    typedef LatticeCoordinates<DIM>                   LatticeCoordinatesType;$/;"	t	class:psimag::TwoFold
LatticeCoordsType	PartialPsimag/Symmetry/Lattice.h	/^    typedef std::vector<LatticeCoordType>                 LatticeCoordsType;$/;"	t	class:psimag::Lattice
LatticeTransformation	PartialPsimag/Symmetry/LatticeTransformation.h	/^    LatticeTransformation<Field,DIM>(): MatrixType() {}$/;"	f	class:psimag::LatticeTransformation
LatticeTransformation	PartialPsimag/Symmetry/LatticeTransformation.h	/^    LatticeTransformation<Field,DIM>(const Vec<int,DIM>& bcoords): $/;"	f	class:psimag::LatticeTransformation
LatticeTransformation	PartialPsimag/Symmetry/LatticeTransformation.h	/^  class LatticeTransformation: $/;"	c	namespace:psimag
LatticeTransformationType	PartialPsimag/Symmetry/ConventionalLattice.h	/^    typedef LatticeTransformation<Field,DIM>           LatticeTransformationType;$/;"	t	class:psimag::ConventionalLattice
LatticeTransformationType	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    typedef LatticeTransformation<Field,DIM>        LatticeTransformationType;$/;"	t	class:psimag::InverseLatticeTransformation
LatticeTransformationType	PartialPsimag/Symmetry/Lattice.h	/^    typedef LatticeTransformation<Field,DIM>              LatticeTransformationType;$/;"	t	class:psimag::Lattice
LatticeTransformationType	PartialPsimag/Symmetry/Pattern.h	/^    typedef LatticeTransformation<Field,DIM>           LatticeTransformationType;$/;"	t	class:psimag::Pattern
LatticeTransformationType	PartialPsimag/Symmetry/PatternWithLattice.h	/^    typedef LatticeTransformation<Field,DIM>                       LatticeTransformationType;$/;"	t	class:psimag::PatternWithLattice
LatticeTransformationType	PartialPsimag/Symmetry/ReducedLattice.h	/^    typedef LatticeTransformation<Field,DIM>  LatticeTransformationType;$/;"	t	class:psimag::ReducedLattice
LatticeTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^    LatticeTranslation(): SeitzVector<int, DIM, 0>() {}$/;"	f	class:psimag::LatticeTranslation
LatticeTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^    LatticeTranslation(const LatticeTranslation<DIM>& v): SeitzVector<int, DIM, 0>(v) {}$/;"	f	class:psimag::LatticeTranslation
LatticeTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^    LatticeTranslation(int val): SeitzVector<int, DIM, 0>(val) {}$/;"	f	class:psimag::LatticeTranslation
LatticeTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^  class LatticeTranslation: public SeitzVector< int, DIM, 0 > {$/;"	c	namespace:psimag
LatticeType	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                             LatticeType;$/;"	t	class:psimag::AppliedSymmetryElementIterator
LatticeType	PartialPsimag/Symmetry/ConventionalLattice.h	/^    typedef Lattice<Field,DIM,Algorithms>              LatticeType;$/;"	t	class:psimag::ConventionalLattice
LatticeType	PartialPsimag/Symmetry/Crystal.h	/^    typedef Lattice            <Field,DIM,                     Algorithms> LatticeType;$/;"	t	class:psimag::Crystal
LatticeType	PartialPsimag/Symmetry/CrystalBase.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                         LatticeType;$/;"	t	class:psimag::CrystalBase
LatticeType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                             LatticeType;$/;"	t	class:psimag::FloodTiler
LatticeType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef Lattice<Field,DIM,Algorithms>                         LatticeType;$/;"	t	class:psimag::Glide
LatticeType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                             LatticeType;$/;"	t	class:psimag::GroupAction
LatticeType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                                   LatticeType;$/;"	t	class:psimag::GroupMultiplicationTable
LatticeType	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>  LatticeType;$/;"	t	class:psimag::ReciprocalLattice
LatticeType	PartialPsimag/Symmetry/ReducedLattice.h	/^    typedef Lattice<Field,DIM,Algorithms>     LatticeType;$/;"	t	class:psimag::ReducedLattice
LatticeType	PartialPsimag/Symmetry/Star.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                         LatticeType;$/;"	t	class:psimag::Star
LatticeType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef Lattice<Field,DIM,Algorithms>                                 LatticeType;$/;"	t	class:psimag::SuperCrystal
LatticeType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                         LatticeType;$/;"	t	class:psimag::Symmetry
LatticeType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef LatticeTemplate<Field,DIM,Algorithms>                             LatticeType;$/;"	t	class:psimag::SymmetryGroup
LatticeType	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    typedef Lattice<Field,DIM,Algorithms>                                  LatticeType;$/;"	t	class:psimag::SymmetryOperations
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    LatticeWithPattern(): $/;"	f	class:psimag::LatticeWithPattern
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    LatticeWithPattern(LatticeType& lat, const Occupant& occupant):$/;"	f	class:psimag::LatticeWithPattern
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    LatticeWithPattern(const LatticeType& lat, const PatternDataType& patternData):$/;"	f	class:psimag::LatticeWithPattern
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    LatticeWithPattern(const LatticeType& lat, const PatternType& pat):$/;"	f	class:psimag::LatticeWithPattern
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    LatticeWithPattern(const LatticeWithPattern& latticeWithPattern):$/;"	f	class:psimag::LatticeWithPattern
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    LatticeWithPattern(const LatticeWithPattern<Field,DIM,Occupant,OtherLatticeType,Algorithms>& other):$/;"	f	class:psimag::LatticeWithPattern
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    LatticeWithPattern(const OtherLatticeTemplate<Field,DIM,Algorithms>& lat, $/;"	f	class:psimag::LatticeWithPattern
LatticeWithPattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^  class LatticeWithPattern: $/;"	c	namespace:psimag
LatticeWithPatternType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms> LatticeWithPatternType;$/;"	t	class:psimag::AppliedSymmetryElement
LatticeWithPatternType	PartialPsimag/Symmetry/Crystal.h	/^    typedef LatticeWithPattern <Field,DIM,Occupant,LatticeType,Algorithms> LatticeWithPatternType;$/;"	t	class:psimag::Crystal
LatticeWithPatternType	PartialPsimag/Symmetry/CrystalBase.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms> LatticeWithPatternType;$/;"	t	class:psimag::CrystalBase
LatticeWithPatternType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>     LatticeWithPatternType;$/;"	t	class:psimag::FloodTiler
LatticeWithPatternType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>     LatticeWithPatternType;$/;"	t	class:psimag::GroupAction
LatticeWithPatternType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>           LatticeWithPatternType;$/;"	t	class:psimag::GroupMultiplicationTable
LatticeWithPatternType	PartialPsimag/Symmetry/Star.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms> LatticeWithPatternType;$/;"	t	class:psimag::Star
LatticeWithPatternType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms> LatticeWithPatternType;$/;"	t	class:psimag::SuperCrystal
LatticeWithPatternType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms> LatticeWithPatternType;$/;"	t	class:psimag::Symmetry
LatticeWithPatternType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>     LatticeWithPatternType;$/;"	t	class:psimag::SymmetryGroup
LatticeWithPatternType	PartialPsimag/Symmetry/TestPattern.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>       LatticeWithPatternType;$/;"	t	class:psimag::TestPattern
LimitedType	PartialPsimag/Symmetry/SeitzVector.h	/^    typedef ColMajorTraits<Field,DIM,1>          LimitedType;$/;"	t	class:psimag::SeitzVector
LineCollection	PythonScripts/Bandstructure.py	/^from matplotlib.collections import LineCollection$/;"	i
LineCollection	PythonScripts/Plot_chiRPA_w.py	/^from matplotlib.collections import LineCollection$/;"	i
LineMarker	PsimagLite/src/LineMarker.h	/^		LineMarker(IoInputType& io,const std::string& name,size_t level = 0)$/;"	f	class:PsimagLite::LineMarker
LineMarker	PsimagLite/src/LineMarker.h	/^		LineMarker(const std::string& name) : name_(name+"=0")$/;"	f	class:PsimagLite::LineMarker
LineMarker	PsimagLite/src/LineMarker.h	/^	class LineMarker  {$/;"	c	namespace:PsimagLite
LinearPrediction	PsimagLite/src/LinearPrediction.h	/^		LinearPrediction(const std::vector<FieldType>& y)$/;"	f	class:PsimagLite::LinearPrediction
LinearPrediction	PsimagLite/src/LinearPrediction.h	/^	class LinearPrediction {$/;"	c	namespace:PsimagLite
LinearPredictionType	PsimagLite/drivers/linearPrediction.cpp	/^typedef PsimagLite::LinearPrediction<FieldType> LinearPredictionType;$/;"	t	file:
LinearSegmentedColormap	PythonScripts/Bandstructure.py	/^	from matplotlib.colors import LinearSegmentedColormap$/;"	i
LinearSegmentedColormap	PythonScripts/Plot_chiRPA_w.py	/^	from matplotlib.colors import LinearSegmentedColormap$/;"	i
Lm	bandstructure.h	/^		ComplexMatrixType Lm;$/;"	m	class:rpa::bandstructure
Lm	tbFromFile.h	/^		ComplexMatrixType Lm;$/;"	m	class:rpa::model
LocalType	PartialPsimag/Symmetry/Mat/Mat.h	/^    typedef Field LocalType[LENGTH];$/;"	t	class:psimag::Mat
LongIntegerType	PsimagLite/src/IoSimple.h	/^				typedef int long long LongIntegerType;$/;"	t	class:PsimagLite::IoSimple::In
LongSizeType	PsimagLite/src/IoSimple.h	/^				typedef unsigned int long long LongSizeType;$/;"	t	class:PsimagLite::IoSimple::In
LongType	PsimagLite/src/Random48.h	/^		typedef long int LongType;$/;"	t	class:PsimagLite::Random48
LongType	PsimagLite/src/RandomForTests.h	/^		typedef long int LongType;$/;"	t	class:PsimagLite::RandomForTests
M	PartialPsimag/Symmetry/Mat/MatDet.h	/^    typedef MatType              M;$/;"	t	class:psimag::DET
M	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef MatType<T,2,2,Traits>   M;$/;"	t	class:psimag::AssembleInverse2
M	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef MatType<T,3,3,Traits>   M;$/;"	t	class:psimag::AssembleInverse3
M	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    typedef MatType              M;$/;"	t	class:psimag::TRANSPOSE_ELS
MAGNITUDE	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^  class MAGNITUDE {$/;"	c	namespace:psimag
MATRICES	PsimagLite/src/Geometry/GeometryDirection.h	/^			enum {NUMBERS,MATRICES};$/;"	e	enum:PsimagLite::GeometryDirection::__anon124
MATRIX_H_	PsimagLite/src/Matrix.h	/^#define MATRIX_H_$/;"	d
MAT_PRINT	PartialPsimag/Symmetry/Mat/MatPrint.h	/^  class MAT_PRINT {$/;"	c	namespace:psimag
MAX	PartialPsimag/Symmetry/Mat/MatMax.h	/^  class MAX {$/;"	c	namespace:psimag
MEMORY_USAGE_H	PsimagLite/src/MemoryUsage.h	/^#define MEMORY_USAGE_H$/;"	d
MI	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      MI,  \/* minus    *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
MINIMIZER_H	PsimagLite/src/Minimizer.h	/^#define MINIMIZER_H$/;"	d
MINUS	PartialPsimag/OperationClosure.h	/^    typedef enum{FourierTransform,PLUS,MINUS,TIMES,DIVIDE,INV} Type;$/;"	e	enum:psimag::OP::__anon112
MINUS	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
MODEL_H	model.h	/^#define MODEL_H$/;"	d
MODE_ARRAY	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^      MODE_ARRAY = 1, $/;"	e	enum:JsonParser::ModesMixin::modes
MODE_DONE	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^      MODE_DONE = 2,  $/;"	e	enum:JsonParser::ModesMixin::modes
MODE_KEY	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^      MODE_KEY = 3,   $/;"	e	enum:JsonParser::ModesMixin::modes
MODE_OBJECT	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^      MODE_OBJECT = 4$/;"	e	enum:JsonParser::ModesMixin::modes
MR	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef MatTypeR<T,2,2,RTraits> MR;$/;"	t	class:psimag::AssembleInverse2
MR	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef MatTypeR<T,3,3,RTraits> MR;$/;"	t	class:psimag::AssembleInverse3
MR	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    typedef MatTypeR             MR;$/;"	t	class:psimag::TRANSPOSE_ELS
MRT	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef RTraits MRT;$/;"	t	class:psimag::AssembleInverse2
MRT	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef RTraits MRT;$/;"	t	class:psimag::AssembleInverse3
MRT	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    typedef TraitsR              MRT;$/;"	t	class:psimag::TRANSPOSE_ELS
MS	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      MS,    \/* Skipping matrix chars     *\/$/;"	e	enum:JsonParser::StatesMixin::states
MT	PartialPsimag/Symmetry/Mat/MatDet.h	/^    typedef Traits               MT;$/;"	t	class:psimag::DET
MT	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef Traits   MT;$/;"	t	class:psimag::AssembleInverse2
MT	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    typedef Traits   MT;$/;"	t	class:psimag::AssembleInverse3
MT	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    typedef Traits               MT;$/;"	t	class:psimag::TRANSPOSE_ELS
MX	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      MX = -18, \/* integer detected by minus *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
MY_MAX_LINE	PsimagLite/src/MemoryUsage.h	/^		static const size_t MY_MAX_LINE = 40240;$/;"	m	class:PsimagLite::MemoryUsage
MY_SELF_FILE	PsimagLite/src/MemoryUsage.h	/^		static const char *MY_SELF_FILE;$/;"	m	class:PsimagLite::MemoryUsage
MY_SELF_FILE	PsimagLite/src/MemoryUsage.h	/^	const char *MemoryUsage::MY_SELF_FILE = "\/proc\/self\/status";$/;"	m	class:PsimagLite::MemoryUsage
Magnitude	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^  T Magnitude(const MatType<T,NCOL,NROW, TraitsTemplate<T, NCOL,NROW> >&  m) {$/;"	f	namespace:psimag
Magnitude	PartialPsimag/Symmetry/SeitzVector.h	/^  Field Magnitude (const SeitzVector<Field,2,IND>& v)$/;"	f	namespace:psimag
MagnitudeReducerType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    class MagnitudeReducerType {$/;"	c	class:psimag::L2NORM
MagnitudeReducerType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    class MagnitudeReducerType {$/;"	c	class:psimag::MAGNITUDE
MakeIDENTITY	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^  class MakeIDENTITY {$/;"	c	namespace:psimag
MakeIdentity	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^  void MakeIdentity(MatType<T,NROW,NCOL,TraitsTemplate<T,NROW,NCOL> >& m) {$/;"	f	namespace:psimag
Mat	PartialPsimag/Symmetry/Mat/Mat.h	/^    Mat() { $/;"	f	class:psimag::Mat
Mat	PartialPsimag/Symmetry/Mat/Mat.h	/^    Mat(const In_Type* const data, size_t ldim=NROW)$/;"	f	class:psimag::Mat
Mat	PartialPsimag/Symmetry/Mat/Mat.h	/^    Mat(const ThisType& m) $/;"	f	class:psimag::Mat
Mat	PartialPsimag/Symmetry/Mat/Mat.h	/^    explicit Mat(const Field& a) { $/;"	f	class:psimag::Mat
Mat	PartialPsimag/Symmetry/Mat/Mat.h	/^  class Mat {$/;"	c	namespace:psimag
MatMultVec	PartialPsimag/Symmetry/Mat/MatMult.h	/^  class MatMultVec {$/;"	c	namespace:psimag
MatMultVecCol	PartialPsimag/Symmetry/Mat/MatMult.h	/^  class MatMultVecCol {$/;"	c	namespace:psimag
MatMultVecCol	PartialPsimag/Symmetry/Mat/MatMult.h	/^  class MatMultVecCol<MatType, Traits, MatTypeO, TraitsO, MatTypeR, TraitsR, 0> {$/;"	c	namespace:psimag
MatMultVecPos	PartialPsimag/Symmetry/Mat/MatMult.h	/^  class MatMultVecPos {$/;"	c	namespace:psimag
MatMultVecPos	PartialPsimag/Symmetry/Mat/MatMult.h	/^  class MatMultVecPos<MatType, Traits, MatTypeO, TraitsO, LROW, 0, RCOL > {$/;"	c	namespace:psimag
MatMultVecRow	PartialPsimag/Symmetry/Mat/MatMult.h	/^  class MatMultVecRow {$/;"	c	namespace:psimag
MatMultVecRow	PartialPsimag/Symmetry/Mat/MatMult.h	/^  class MatMultVecRow<MatType, Traits, MatTypeO, TraitsO, MatTypeR, TraitsR, 0, RCOL> {$/;"	c	namespace:psimag
MatTraitsType	PartialPsimag/Symmetry/Lattice.h	/^    typedef typename MatType::Traits                      MatTraitsType;$/;"	t	class:psimag::Lattice
MatType	PartialPsimag/Symmetry/Lattice.h	/^    typedef SeitzMatrix<Field,DIM>                        MatType;$/;"	t	class:psimag::Lattice
MatType	PartialPsimag/Symmetry/MetricTensor.h	/^    typedef  Mat<Field,2,2> MatType;$/;"	t	class:psimag::MetricTensor
MatType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef SuperClass                              MatType;$/;"	t	class:psimag::SymmetryOperation
Mat_Print	PartialPsimag/Symmetry/Mat/MatPrint.h	/^  void Mat_Print(const MatType<T,NROW,NCOL>& m, std::ostream& os, bool flat=true) {$/;"	f	namespace:psimag
Mat_Print_OP_Template	PartialPsimag/Symmetry/Mat/MatPrint.h	/^#define Mat_Print_OP_Template(/;"	d
Mat_Print_Template	PartialPsimag/Symmetry/Mat/MatPrint.h	/^#define Mat_Print_Template(/;"	d
Matrix	PartialPsimag/Matrix.h	/^    Matrix() : nRow(0), nCol(0), lDim(0), owner(true), data(0),col(0) {};$/;"	f	class:psimag::Matrix
Matrix	PartialPsimag/Matrix.h	/^    Matrix(const Matrix<T> & mat) $/;"	f	class:psimag::Matrix
Matrix	PartialPsimag/Matrix.h	/^    Matrix(const MatrixLikeType& mat):$/;"	f	class:psimag::Matrix
Matrix	PartialPsimag/Matrix.h	/^    Matrix(size_type nRows, size_type nCols, T* dat, size_type ldim=0) $/;"	f	class:psimag::Matrix
Matrix	PartialPsimag/Matrix.h	/^    Matrix(size_type nRows, size_type nCols, const T* dat, size_type ldim=0) $/;"	f	class:psimag::Matrix
Matrix	PartialPsimag/Matrix.h	/^    Matrix(size_type nRows,size_type nCols,size_type ldim=0,const T& val=T()) {$/;"	f	class:psimag::Matrix
Matrix	PartialPsimag/Matrix.h	/^  class Matrix {$/;"	c	namespace:psimag
Matrix	PsimagLite/src/Matrix.h	/^		Matrix()$/;"	f	class:PsimagLite::Matrix
Matrix	PsimagLite/src/Matrix.h	/^		Matrix(const Matrix<RealType>& m)$/;"	f	class:PsimagLite::Matrix
Matrix	PsimagLite/src/Matrix.h	/^		Matrix(const Matrix<T>& m)$/;"	f	class:PsimagLite::Matrix
Matrix	PsimagLite/src/Matrix.h	/^		Matrix(const SomeMatrixType& m)$/;"	f	class:PsimagLite::Matrix
Matrix	PsimagLite/src/Matrix.h	/^		Matrix(size_t nrow,size_t ncol) $/;"	f	class:PsimagLite::Matrix
Matrix	PsimagLite/src/Matrix.h	/^	class  Matrix  {$/;"	c	namespace:PsimagLite
MatrixBegin	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void MatrixBegin(std::string filename, size_t charNum) {$/;"	f	class:JsonParser::DefaultContext
MatrixBoundsChecking	Makefile	/^MatrixBoundsChecking = -DNDEBUG $/;"	m
MatrixBoundsChecking	PsimagLite/src/JSON/JsonParser/Makefile	/^MatrixBoundsChecking = -DNDEBUG $/;"	m
MatrixElementType	PsimagLite/src/CrsMatrix.h	/^    	typedef T MatrixElementType;$/;"	t	class:PsimagLite::CrsMatrix
MatrixEnd	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void MatrixEnd(size_t charNum) {$/;"	f	class:JsonParser::DefaultContext
MatrixIntType	momentumDomain.h	/^		typedef MatrixTemplate<size_t> 				MatrixIntType;$/;"	t	class:rpa::momentumDomain
MatrixLike	PartialPsimag/MatrixLike.h	/^  namespace MatrixLike {$/;"	n	namespace:psimag
MatrixLike	PsimagLite/src/JSON/MatrixLike.h	/^  namespace MatrixLike {$/;"	n	namespace:psimag
MatrixParser	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    MatrixParser(std::wifstream& is, $/;"	f	class:JsonParser::MatrixParser
MatrixParser	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^  class MatrixParser: public CharacterMapper {$/;"	c	namespace:JsonParser
MatrixScalarPrinter	PartialPsimag/Matrix.h	/^  class MatrixScalarPrinter {$/;"	c	namespace:psimag
MatrixScalarPrinter	PartialPsimag/Matrix.h	/^  class MatrixScalarPrinter<std::complex<ScalarType> > {$/;"	c	namespace:psimag
MatrixType	1band_wSpin.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::SingleBand_wSpin
MatrixType	4Orbital.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::FourOrbital
MatrixType	BSCCObilayer.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	BaFeAs_5orb.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::BaFeAs
MatrixType	FourOrbital.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::FourOrbital
MatrixType	KFe2Se2.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::KFe2Se2
MatrixType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef SeitzMatrix< Field, DIM >                              MatrixType;$/;"	t	class:psimag::AppliedSymmetryElement
MatrixType	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    typedef SeitzMatrix<Field,DIM>                  MatrixType;$/;"	t	class:psimag::InverseLatticeTransformation
MatrixType	PartialPsimag/Symmetry/LatticeTransformation.h	/^    typedef SeitzMatrix<Field,DIM>                  MatrixType;$/;"	t	class:psimag::LatticeTransformation
MatrixType	PartialPsimag/Symmetry/PsimagGeometry.h	/^	     typedef MatrixTemplate<Field>          MatrixType;$/;"	t	class:rpa::PsimagGeometry
MatrixType	PsimagLite/src/ChebyshevSerializer.h	/^		typedef Matrix<FieldType> MatrixType;$/;"	t	class:PsimagLite::ChebyshevSerializer
MatrixType	PsimagLite/src/ContinuedFraction.h	/^		typedef Matrix<FieldType> MatrixType;$/;"	t	class:PsimagLite::ContinuedFraction
MatrixType	PsimagLite/src/ContinuedFractionCollection.h	/^		typedef typename ContinuedFractionType::MatrixType MatrixType;$/;"	t	class:PsimagLite::ContinuedFractionCollection
MatrixType	PsimagLite/src/Geometry/GeometryDirection.h	/^		typedef Matrix<RealType> MatrixType;$/;"	t	class:PsimagLite::GeometryDirection
MatrixType	PsimagLite/src/LinearPrediction.h	/^		typedef Matrix<FieldType> MatrixType;$/;"	t	class:PsimagLite::LinearPrediction
MatrixType	SrRuO.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::SrRuO
MatrixType	SrRuO_SO.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	bands.h	/^		typedef MatrixTemplate<Field> 	MatrixType;$/;"	t	class:rpa::Bands
MatrixType	bandstructure.h	/^		typedef MatrixTemplate<Field>		MatrixType;$/;"	t	class:rpa::bandstructure
MatrixType	bilayer.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	bilayerFESC.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	chi0.h	/^		typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::calcChi0Matrix
MatrixType	chi0.h	/^		typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::chi0q
MatrixType	coupledLadders.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	ferminator.h	/^		typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::ferminator
MatrixType	gap.h	/^		typedef MatrixTemplate<Field> 	MatrixType;$/;"	t	class:rpa::gap
MatrixType	gaps3D.h	/^        typedef MatrixTemplate<Field>   MatrixType;$/;"	t	class:rpa::gap3D
MatrixType	interpolation.h	/^		typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::interpolation
MatrixType	momentumDomain.h	/^		typedef MatrixTemplate<Field>			 	MatrixType;$/;"	t	class:rpa::momentumDomain
MatrixType	orthoIIBilayer.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	pairing.h	/^		typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::pairing
MatrixType	parameters.h	/^		typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::parameters
MatrixType	rpa.h	/^			typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::interaction
MatrixType	rpa_CuO.h	/^			typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::interactionEmery
MatrixType	sepBasis.h	/^			typedef MatrixTemplate<Field> 			MatrixType;$/;"	t	class:rpa::sepBasis
MatrixType	singleBand.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	susceptibility.h	/^			typedef MatrixTemplate<Field> 			   MatrixType;$/;"	t	class:rpa::susceptibility
MatrixType	tbFromFile.h	/^		typedef MatrixTemplate<Field> 		MatrixType;$/;"	t	class:rpa::model
MatrixType	utilities.h	/^typedef psimag::Matrix<double>  MatrixType;$/;"	t
Max	PartialPsimag/Symmetry/Mat/MatMax.h	/^  T Max(const MatType<T,NCOL,NROW>&  m) {$/;"	f	namespace:psimag
Max	PartialPsimag/Symmetry/SeitzMatrix.h	/^  Field Max(const SeitzMatrix<Field,DIM>& m) {$/;"	f	namespace:psimag
Max	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void Max(std::string s) {$/;"	f	class:JsonParser::DefaultContext
MaxReducerType	PartialPsimag/Symmetry/Mat/MatMax.h	/^    class MaxReducerType {$/;"	c	class:psimag::MAX
MaybeConstValueType	PartialPsimag/ValueTypeFunction.h	/^    typedef const typename MatrixOrVectorLikeType::value_type  MaybeConstValueType;$/;"	t	class:psimag::ValueTypeFunction
MaybeConstValueType	PartialPsimag/ValueTypeFunction.h	/^    typedef typename MatrixOrVectorLikeType::value_type MaybeConstValueType;$/;"	t	class:psimag::ValueTypeFunction
MazinKFe2Se2	CrystalHarmonics2D.h	/^	FieldType MazinKFe2Se2(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
MazinKFe2Se2_wZ	CrystalHarmonics2D.h	/^	FieldType MazinKFe2Se2_wZ(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
MemoryUsage	PsimagLite/src/MemoryUsage.h	/^		MemoryUsage() : data_("")$/;"	f	class:PsimagLite::MemoryUsage
MemoryUsage	PsimagLite/src/MemoryUsage.h	/^	class MemoryUsage {$/;"	c	namespace:PsimagLite
MetricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^    MetricTensor(): Mat<Field,2,2>() {}$/;"	f	class:psimag::MetricTensor
MetricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^    MetricTensor(): Mat<Field,3,3>() {}$/;"	f	class:psimag::MetricTensor
MetricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^    MetricTensor(): Mat<Field,DIM,DIM>() {}$/;"	f	class:psimag::MetricTensor
MetricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^  class MetricTensor: public Mat<Field,DIM,DIM>  {$/;"	c	namespace:psimag
MetricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^  class MetricTensor<Field,2>: public Mat<Field,2,2>  {$/;"	c	namespace:psimag
MetricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^  class MetricTensor<Field,3>: public Mat<Field,3,3>  {$/;"	c	namespace:psimag
MetricTensorSortHelper	PartialPsimag/Symmetry/MetricTensor.h	/^    MetricTensorSortHelper(const MetricTensor<Field,DIM>& mt): metricTensor(mt) {}$/;"	f	class:psimag::MetricTensorSortHelper
MetricTensorSortHelper	PartialPsimag/Symmetry/MetricTensor.h	/^  class MetricTensorSortHelper {$/;"	c	namespace:psimag
MetricType	PartialPsimag/Symmetry/Lattice.h	/^    typedef MetricTensor<Field,DIM>                       MetricType;$/;"	t	class:psimag::Lattice
Middle	PsimagLite/src/JSON/JSN_Writer.h	/^    typedef enum {First,Middle,Last} Position;$/;"	e	enum:dca::JSN::__anon119
MillerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^    MillerDirection(): SeitzVector<Field, DIM, 0>() {}$/;"	f	class:psimag::MillerDirection
MillerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^    MillerDirection(const ArrayType& vals):  SeitzVector<Field, DIM, 0>(vals) {}$/;"	f	class:psimag::MillerDirection
MillerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^    MillerDirection(const MillerDirection<Field, DIM>& v): SeitzVector<Field, DIM, 0>(v) {}$/;"	f	class:psimag::MillerDirection
MillerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^    MillerDirection(const Vec<Field, DIM>& v):  SeitzVector<Field, DIM, 0>(v) {}$/;"	f	class:psimag::MillerDirection
MillerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^    template<typename IN_TYPE> MillerDirection(const IN_TYPE& val): SeitzVector<Field, DIM, 0>(val) {}$/;"	f	class:psimag::MillerDirection
MillerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^  class MillerDirection: public SeitzVector< Field, DIM, 0 > {$/;"	c	namespace:psimag
Minimizer	PsimagLite/src/Minimizer.h	/^		Minimizer(FunctionType& function,size_t maxIter)$/;"	f	class:PsimagLite::Minimizer
Minimizer	PsimagLite/src/Minimizer.h	/^	class Minimizer {$/;"	c	namespace:PsimagLite
Mirror	PartialPsimag/Symmetry/Mirror2D.h	/^    Mirror():$/;"	f	class:psimag::Mirror
Mirror	PartialPsimag/Symmetry/Mirror2D.h	/^    Mirror(const LatticeCoordinatesType&  orientation,$/;"	f	class:psimag::Mirror
Mirror	PartialPsimag/Symmetry/Mirror2D.h	/^    Mirror(const LatticeCoordinatesType& orientation,$/;"	f	class:psimag::Mirror
Mirror	PartialPsimag/Symmetry/Mirror2D.h	/^  class Mirror<Field,2,Algorithms>: $/;"	c	namespace:psimag
Mirror	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class Mirror    {};$/;"	c	namespace:psimag
MirrorType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef Mirror<Field,DIM,Algorithms>                          MirrorType;$/;"	t	class:psimag::Glide
MirrorType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef Mirror<Field,DIM,Algorithms>                       MirrorType;$/;"	t	class:psimag::Mirror
MirrorType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef Mirror<Field,DIM,Algorithms>                                   MirrorType;$/;"	t	class:psimag::SymmetryElements
Mk	bandstructure.h	/^		std::vector<ComplexMatrixType> Mk;$/;"	m	class:rpa::bandstructure
MkFF	bandstructure.h	/^		std::vector<ComplexMatrixType> MkFF;$/;"	m	class:rpa::bandstructure
Mkq	bandstructure.h	/^		std::vector<ComplexMatrixType> Mkq;$/;"	m	class:rpa::bandstructure
MkqFF	bandstructure.h	/^		std::vector<ComplexMatrixType> MkqFF;$/;"	m	class:rpa::bandstructure
MockVector	PsimagLite/src/Minimizer.h	/^		MockVector(const gsl_vector *v) : v_(v)$/;"	f	class:PsimagLite::MockVector
MockVector	PsimagLite/src/Minimizer.h	/^	class MockVector {$/;"	c	namespace:PsimagLite
ModeType	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    } ModeType;$/;"	t	class:JsonParser::ModesMixin	typeref:enum:JsonParser::ModesMixin::modes
ModelType	main.cpp	/^typedef rpa::model<FieldType, psimag::Matrix, ConcurrencyType> ModelType;$/;"	t	file:
ModesMixin	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    ModesMixin():$/;"	f	class:JsonParser::ModesMixin
ModesMixin	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^  class ModesMixin {$/;"	c	namespace:JsonParser
MultiplicationTable	PartialPsimag/Symmetry/FiniteGroup.h	/^  typedef std::map<pair<SymmetryOperation*, SymmetryOperation*>, SymmetryOperation*> MultiplicationTable;$/;"	t	namespace:psimag
MultiplicationTableMapType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef std::map<IntPairType,int>                                         MultiplicationTableMapType;$/;"	t	class:psimag::GroupAction
MultiplicationTableMapType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef std::map<IntPairType,int>                                               MultiplicationTableMapType;$/;"	t	class:psimag::GroupMultiplicationTable
MultiplicationTableMapType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef std::map<IntPairType,int>                                         MultiplicationTableMapType;$/;"	t	class:psimag::SymmetryGroup
Multiply	PartialPsimag/Symmetry/Mat/MatMult.h	/^      inline void Multiply(const MatType& m,$/;"	f	namespace:psimag
Multiply	PartialPsimag/Symmetry/SeitzMatrix.h	/^  void Multiply(const SeitzMatrix<Field,DIM>& lhs,$/;"	f	namespace:psimag
Multiply	PartialPsimag/Symmetry/SeitzMatrix.h	/^  void Multiply(const SeitzMatrix<T,DIM>&            m,$/;"	f	namespace:psimag
Multiply	PartialPsimag/Symmetry/SeitzVector.h	/^  void Multiply(MatType<MatField,DIM,DIM> m,$/;"	f	namespace:psimag
MyFunctionTest	PsimagLite/drivers/minimizer.cpp	/^class MyFunctionTest$/;"	c	file:
N	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      N,   \/* Looking for _ull (null)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
N1	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      N1,  \/* nu       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
N2	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      N2,  \/* nul      *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
N3	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      N3,  \/* null     *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
NCOL	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::COPY::__anon27
NCOL	PartialPsimag/Symmetry/Mat/MatDifference.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::DIFFERENCE::__anon60
NCOL	PartialPsimag/Symmetry/Mat/MatEqual.h	/^	   NCOL = Traits::NCOL };$/;"	e	enum:psimag::CLOSE::__anon35
NCOL	PartialPsimag/Symmetry/Mat/MatEqual.h	/^	   NCOL = Traits::NCOL };$/;"	e	enum:psimag::EQUAL::__anon34
NCOL	PartialPsimag/Symmetry/Mat/MatEqual.h	/^	   NCOL = Traits::NCOL };$/;"	e	enum:psimag::EQUAL_VAL::__anon36
NCOL	PartialPsimag/Symmetry/Mat/MatForEach.h	/^	   NCOL=Traits::NCOL };$/;"	e	enum:psimag::FOREACH_::__anon14
NCOL	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::FOREACH_::__anon15
NCOL	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::FOREACH_ELS::__anon12
NCOL	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::FOREACH_ELS::__anon13
NCOL	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^	   NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH2_::__anon30
NCOL	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH2_::__anon31
NCOL	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH2_ELS::__anon28
NCOL	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH2_ELS::__anon29
NCOL	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_::__anon39
NCOL	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_::__anon40
NCOL	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_ELS::__anon37
NCOL	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_ELS::__anon38
NCOL	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::MakeIDENTITY::__anon33
NCOL	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^	   NCOL=Traits::NCOL };$/;"	e	enum:psimag::L2NORM::__anon20
NCOL	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^	   NCOL=Traits::NCOL };$/;"	e	enum:psimag::MAGNITUDE::__anon19
NCOL	PartialPsimag/Symmetry/Mat/MatMax.h	/^	   NCOL=Traits::NCOL };$/;"	e	enum:psimag::MAX::__anon18
NCOL	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::PRINT_FUNCTOR::__anon61
NCOL	PartialPsimag/Symmetry/Mat/MatReduce.h	/^	   NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE::__anon26
NCOL	PartialPsimag/Symmetry/Mat/MatReduce.h	/^	   NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE_::__anon24
NCOL	PartialPsimag/Symmetry/Mat/MatReduce.h	/^	   NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE_::__anon25
NCOL	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE_ELS::__anon22
NCOL	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE_ELS::__anon23
NCOL	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2::__anon46
NCOL	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_::__anon44
NCOL	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_::__anon45
NCOL	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_ELS::__anon42
NCOL	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_ELS::__anon43
NCOL	PartialPsimag/Symmetry/Mat/MatSum.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::SUM::__anon11
NCOL	PartialPsimag/Symmetry/Mat/MatTrace.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::TRACE::__anon51
NCOL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NCOL        = NCOL_  };$/;"	e	enum:psimag::ColMajorTraits::__anon54
NCOL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NCOL        = NCOL_  };$/;"	e	enum:psimag::ConstantTraits::__anon56
NCOL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NCOL        = NCOL_  };$/;"	e	enum:psimag::DoubleIndexTraits::__anon58
NCOL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NCOL        = NCOL_  };$/;"	e	enum:psimag::ReverseDoubleIndexTraits::__anon59
NCOL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NCOL        = NCOL_  };$/;"	e	enum:psimag::RowMajorTraits::__anon52
NCOL	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    enum { NCOL = Traits::NCOL };$/;"	e	enum:psimag::TRANSPOSE::__anon48
NCOL	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    enum { ROW=0, NCOL = Traits::NCOL };$/;"	e	enum:psimag::TRANSPOSE::__anon49
NCOL	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	   NCOL        = NCOL_ };$/;"	e	enum:psimag::SeitzMatrixTraits::__anon74
NInt	PythonScripts/Sr2RuO4.py	/^        NInt = nkIntlin*nkIntlin$/;"	v	class:RPA
NLCOL	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { LROW=0, NLCOL=Traits::NCOL};$/;"	e	enum:psimag::MatMultVecRow::__anon7
NLCOL	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { NLCOL=Traits::NCOL};$/;"	e	enum:psimag::MatMultVecRow::__anon5
NLROW	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { NLROW=Traits::NROW};$/;"	e	enum:psimag::MatMultVecCol::__anon8
NLROW	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { RCOL= 0, NLROW=Traits::NROW};$/;"	e	enum:psimag::MatMultVecCol::__anon9
NORM	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
NO_PTHREADS_HEADER_H	PsimagLite/src/NoPthreads.h	/^#define NO_PTHREADS_HEADER_H$/;"	d
NRCOL	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { NRCOL =TraitsO::NCOL};$/;"	e	enum:psimag::MatMultVec::__anon10
NROW	PartialPsimag/Symmetry/Mat/MatCopy.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::COPY::__anon27
NROW	PartialPsimag/Symmetry/Mat/MatDifference.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::DIFFERENCE::__anon60
NROW	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    enum { NROW = Traits::NROW, $/;"	e	enum:psimag::CLOSE::__anon35
NROW	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    enum { NROW = Traits::NROW, $/;"	e	enum:psimag::EQUAL::__anon34
NROW	PartialPsimag/Symmetry/Mat/MatEqual.h	/^    enum { NROW = Traits::NROW, $/;"	e	enum:psimag::EQUAL_VAL::__anon36
NROW	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW };$/;"	e	enum:psimag::FOREACH::__anon16
NROW	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW, $/;"	e	enum:psimag::FOREACH_::__anon14
NROW	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::FOREACH_::__anon15
NROW	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::FOREACH_ELS::__anon12
NROW	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::FOREACH_ELS::__anon13
NROW	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW };$/;"	e	enum:psimag::FOREACH2::__anon32
NROW	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW, $/;"	e	enum:psimag::FOREACH2_::__anon30
NROW	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH2_::__anon31
NROW	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH2_ELS::__anon28
NROW	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH2_ELS::__anon29
NROW	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW };$/;"	e	enum:psimag::FOREACH3::__anon41
NROW	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_::__anon39
NROW	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_::__anon40
NROW	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_ELS::__anon37
NROW	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::FOREACH3_ELS::__anon38
NROW	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    enum { NROW=Traits::NROW };$/;"	e	enum:psimag::FOREACH_DIAG::__anon50
NROW	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::MakeIDENTITY::__anon33
NROW	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    enum { NROW=Traits::NROW, $/;"	e	enum:psimag::L2NORM::__anon20
NROW	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^    enum { NROW=Traits::NROW, $/;"	e	enum:psimag::MAGNITUDE::__anon19
NROW	PartialPsimag/Symmetry/Mat/MatMax.h	/^    enum { NROW=Traits::NROW, $/;"	e	enum:psimag::MAX::__anon18
NROW	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::PRINT_FUNCTOR::__anon61
NROW	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    enum { NROW=Traits::NROW, $/;"	e	enum:psimag::REDUCE::__anon26
NROW	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    enum { NROW=Traits::NROW, $/;"	e	enum:psimag::REDUCE_::__anon24
NROW	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    enum { NROW=Traits::NROW, $/;"	e	enum:psimag::REDUCE_::__anon25
NROW	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE_ELS::__anon22
NROW	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE_ELS::__anon23
NROW	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2::__anon46
NROW	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_::__anon44
NROW	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_::__anon45
NROW	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_ELS::__anon42
NROW	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::REDUCE2_ELS::__anon43
NROW	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    enum { NROW=Traits::NROW };$/;"	e	enum:psimag::REDUCE_DIAG::__anon21
NROW	PartialPsimag/Symmetry/Mat/MatSum.h	/^    enum { NROW=TraitsLHS::NROW, NCOL=TraitsLHS::NCOL };$/;"	e	enum:psimag::SUM::__anon11
NROW	PartialPsimag/Symmetry/Mat/MatTrace.h	/^    enum { NROW=Traits::NROW, NCOL=Traits::NCOL };$/;"	e	enum:psimag::TRACE::__anon51
NROW	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NROW        = NROW_, $/;"	e	enum:psimag::ColMajorTraits::__anon54
NROW	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NROW        = NROW_, $/;"	e	enum:psimag::ConstantTraits::__anon56
NROW	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NROW        = NROW_, $/;"	e	enum:psimag::DoubleIndexTraits::__anon58
NROW	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NROW        = NROW_, $/;"	e	enum:psimag::ReverseDoubleIndexTraits::__anon59
NROW	PartialPsimag/Symmetry/Mat/MatTraits.h	/^	   NROW        = NROW_, $/;"	e	enum:psimag::RowMajorTraits::__anon52
NROW	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^	   NROW        = NROW_, $/;"	e	enum:psimag::SeitzMatrixTraits::__anon74
NROWS	PartialPsimag/Symmetry/Pattern.h	/^    enum { NROWS=DIM+1};$/;"	e	enum:psimag::Pattern::__anon73
NROWS	PartialPsimag/Symmetry/PatternWithLattice.h	/^    enum { NROWS=DIM+1};$/;"	e	enum:psimag::PatternWithLattice::__anon104
NR_ACTIONS	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      NR_ACTIONS$/;"	e	enum:JsonParser::ActionsMixin::actions
NR_CLASSES	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^      NR_CLASSES$/;"	e	enum:JsonParser::CharacterMapper::classes
NR_STATES	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      NR_STATES,$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
NR_STATES	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      NR_STATES$/;"	e	enum:JsonParser::StatesMixin::states
NU	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      NU = -14, \/* null *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
NU	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      NU,  \/* Looking for __ll (null)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
NUL	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      NUL, \/* Looking for ___l (null)     *\/$/;"	e	enum:JsonParser::StatesMixin::states
NUM	PartialPsimag/Symmetry/ForEachCentering.h	/^    enum { NUM=Centerings<2>::NumCenterings };$/;"	e	enum:psimag::ForEachCentering::__anon106
NUM	PartialPsimag/Symmetry/ForEachCentering.h	/^    enum {NUM=0};$/;"	e	enum:psimag::ForEachCentering_::__anon105
NUMBERS	PsimagLite/src/Geometry/GeometryDirection.h	/^			enum {NUMBERS,MATRICES};$/;"	e	enum:PsimagLite::GeometryDirection::__anon124
NUMGROUPS	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    enum {DIM=2, NUMGROUPS=17};$/;"	e	enum:psimag::SpaceGroup::__anon107
NUMGROUPS	PartialPsimag/Symmetry/Symmetry.h	/^    enum { NUMGROUPS= SpaceGroupType::NUMGROUPS};$/;"	e	enum:psimag::Symmetry::__anon111
NUMOPS	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    enum {DIM=2, NUMOPS=51};$/;"	e	enum:psimag::SymmetryOperations::__anon109
NUMPOS	PartialPsimag/Symmetry/Pattern.h	/^    size_t                  NUMPOS;$/;"	m	class:psimag::Pattern
Name	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    static const std::string Name() { return "BodyCentered"; }$/;"	f	class:psimag::CenteringPointGroup
Name	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    static const std::string Name() { return "mmm"; }$/;"	f	class:psimag::CenteringPointGroup
Name	PartialPsimag/Symmetry/Centering2D.h	/^    static const std::string Name() { return "BodyCentered"; }$/;"	f	class:psimag::Centering
Name	PartialPsimag/Symmetry/Centering2D.h	/^    static const std::string Name() { return "Primitive"; }$/;"	f	class:psimag::Centering
NoPthreads	PsimagLite/src/NoPthreads.h	/^	class NoPthreads : public Concurrency<typename PthreadFunctionHolderType::RealType> {$/;"	c	namespace:PsimagLite
None	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void None() {$/;"	f	class:JsonParser::DefaultContext
Null	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void Null( ) {$/;"	f	class:JsonParser::DefaultContext
NullType	PartialPsimag/Symmetry/NullType.h	/^  class NullType {};$/;"	c	namespace:psimag
NumCenterings	PartialPsimag/Symmetry/Centering.h	/^    enum{ NumCenterings=0 };$/;"	e	enum:psimag::Centerings::__anon76
NumCenterings	PartialPsimag/Symmetry/Centering.h	/^    enum{ NumCenterings=2 };$/;"	e	enum:psimag::Centerings::__anon77
NumCenterings	PartialPsimag/Symmetry/Centering.h	/^    enum{ NumCenterings=6 }; \/\/ Probably more check this.$/;"	e	enum:psimag::Centerings::__anon78
NumCenterings	PartialPsimag/Symmetry/Centering2D.h	/^    enum{ NumCenterings=0 };$/;"	e	enum:psimag::Centerings::__anon100
NumCenterings	PartialPsimag/Symmetry/Centering2D.h	/^    enum{ NumCenterings=2 };$/;"	e	enum:psimag::Centerings::__anon101
NumCenterings	PartialPsimag/Symmetry/Centering2D.h	/^    enum{ NumCenterings=6 }; \/\/ Probably more check this.$/;"	e	enum:psimag::Centerings::__anon102
NumElements	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    enum { NumElements = NROW_*NCOL_, $/;"	e	enum:psimag::ColMajorTraits::__anon54
NumElements	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    enum { NumElements = NROW_*NCOL_, $/;"	e	enum:psimag::ConstantTraits::__anon56
NumElements	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    enum { NumElements = NROW_*NCOL_, $/;"	e	enum:psimag::DoubleIndexTraits::__anon58
NumElements	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    enum { NumElements = NROW_*NCOL_, $/;"	e	enum:psimag::ReverseDoubleIndexTraits::__anon59
NumElements	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    enum { NumElements = NROW_*NCOL_, $/;"	e	enum:psimag::RowMajorTraits::__anon52
NumElements	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^    enum { NumElements = NROW_*NCOL_, $/;"	e	enum:psimag::SeitzMatrixTraits::__anon74
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=1, NumGenerators=1, NumOperations=1};$/;"	e	enum:psimag::SpaceGroupData::__anon82
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=10, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon91
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=11, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon92
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=12, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon93
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=13 , NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon94
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=14 , NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon95
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=15, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon96
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=16, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon97
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=17, NumGenerators=4, NumOperations=12};$/;"	e	enum:psimag::SpaceGroupData::__anon98
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=2, NumGenerators=2, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon83
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=3, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon84
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=4, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon85
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=6, NumGenerators=3, NumOperations=8 };$/;"	e	enum:psimag::SpaceGroupData::__anon87
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=7 , NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon88
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=8, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon89
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=5, NumGenerators=3, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon86
NumGenerators	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=9 , NumGenerators=4, NumOperations=11};$/;"	e	enum:psimag::SpaceGroupData::__anon90
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=1, NumGenerators=1, NumOperations=1};$/;"	e	enum:psimag::SpaceGroupData::__anon82
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=10, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon91
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=11, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon92
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=12, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon93
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=13 , NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon94
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=14 , NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon95
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=15, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon96
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=16, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon97
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=17, NumGenerators=4, NumOperations=12};$/;"	e	enum:psimag::SpaceGroupData::__anon98
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=2, NumGenerators=2, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon83
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=3, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon84
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=4, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon85
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=6, NumGenerators=3, NumOperations=8 };$/;"	e	enum:psimag::SpaceGroupData::__anon87
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=7 , NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon88
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=8, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon89
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=5, NumGenerators=3, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon86
NumOperations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=9 , NumGenerators=4, NumOperations=11};$/;"	e	enum:psimag::SpaceGroupData::__anon90
NumPointGroups	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    enum { NumPointGroups:2 }$/;"	e	enum:psimag::CenteringPointGroup::__anon108
OB	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      OB,  \/* object   *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
OBJECTS	Makefile	/^OBJECTS      =  main.o$/;"	m
OBJECTS	PsimagLite/src/JSON/JsonParser/Makefile	/^OBJECTS      = main.o$/;"	m
OCCUPANT_CLOSURE_H	PartialPsimag/Symmetry/OccupantClosure.h	/^#define OCCUPANT_CLOSURE_H$/;"	d
OK	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      OK,  \/* ok       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
OP	PartialPsimag/OperationClosure.h	/^  class OP {$/;"	c	namespace:psimag
OP	PsimagLite/src/JSON/OperationClosure.h	/^  class OP {$/;"	c	namespace:psimag
OPERATE	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^      static void OPERATE(T& el) {$/;"	f	class:psimag::MakeIDENTITY::IdentityReducerType
ORIGIN_LOCATOR_H	PartialPsimag/Symmetry/OriginLocator.h	/^#define ORIGIN_LOCATOR_H$/;"	d
ORTHOIIBILAYER_H	orthoIIBilayer.h	/^#define ORTHOIIBILAYER_H$/;"	d
OType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef typename TraitsO::ElType OType;$/;"	t	class:psimag::CLOSE::CloseReducerType
OType	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef typename TraitsO::ElType OType;$/;"	t	class:psimag::EQUAL::EqualReducerType
OType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      typedef typename TraitsO::ElType OType;$/;"	t	class:psimag::L2NORM::MagnitudeReducerType
OType	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      typedef typename TraitsO::ElType OType;$/;"	t	class:psimag::MAGNITUDE::MagnitudeReducerType
OType	PartialPsimag/Symmetry/Mat/MatMax.h	/^      typedef typename TraitsO::ElType OType;$/;"	t	class:psimag::MAX::MaxReducerType
ObjectBegin	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void ObjectBegin() {$/;"	f	class:JsonParser::DefaultContext
ObjectEnd	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void ObjectEnd() {$/;"	f	class:JsonParser::DefaultContext
OccItr	PartialPsimag/Symmetry/PatternData.h	/^    typedef typename Occupants::const_iterator           OccItr;$/;"	t	class:psimag::PatternData
OccMapItr	PartialPsimag/Symmetry/PatternData.h	/^    typedef typename OccupantMap::const_iterator         OccMapItr;$/;"	t	class:psimag::PatternData
OccRef	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef typename PatternDataType::OccItr              OccRef;$/;"	t	class:psimag::OriginLocator
Occupant	PartialPsimag/Symmetry/Occupant.h	/^    Occupant(): $/;"	f	class:psimag::Occupant
Occupant	PartialPsimag/Symmetry/Occupant.h	/^    Occupant(char* cString): $/;"	f	class:psimag::Occupant
Occupant	PartialPsimag/Symmetry/Occupant.h	/^    Occupant(const Occupant& aOccupant): $/;"	f	class:psimag::Occupant
Occupant	PartialPsimag/Symmetry/Occupant.h	/^    Occupant(std::string aName): $/;"	f	class:psimag::Occupant
Occupant	PartialPsimag/Symmetry/Occupant.h	/^    Occupant(std::string aName,std::string color_): $/;"	f	class:psimag::Occupant
Occupant	PartialPsimag/Symmetry/Occupant.h	/^  class Occupant {$/;"	c	namespace:psimag
OccupantClosure	PartialPsimag/Symmetry/OccupantClosure.h	/^    OccupantClosure(const Occupant& occupant_, PatternType& pattern_): $/;"	f	class:psimag::OccupantClosure
OccupantClosure	PartialPsimag/Symmetry/OccupantClosure.h	/^  class OccupantClosure  {$/;"	c	namespace:psimag
OccupantClosureType	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef OccupantClosure<Field,DIM,NUMPOS,Occupant>    OccupantClosureType;$/;"	t	class:psimag::OriginLocator
OccupantMap	PartialPsimag/Symmetry/PatternData.h	/^    typedef std::map<Occupant,CellPositions>             OccupantMap;$/;"	t	class:psimag::PatternData
Occupants	PartialPsimag/Symmetry/PatternData.h	/^    typedef std::set<Occupant>                           Occupants;$/;"	t	class:psimag::PatternData
Omega0	parameters.h	/^		Field Omega0;$/;"	m	class:rpa::parameters
OperationClosure	PartialPsimag/OperationClosure.h	/^    OperationClosure(const Operand1Type& l,$/;"	f	class:psimag::OperationClosure
OperationClosure	PartialPsimag/OperationClosure.h	/^  class OperationClosure {$/;"	c	namespace:psimag
OperationClosure	PsimagLite/src/JSON/OperationClosure.h	/^    OperationClosure(const Operand1Type& l,$/;"	f	class:psimag::OperationClosure
OperationClosure	PsimagLite/src/JSON/OperationClosure.h	/^  class OperationClosure {$/;"	c	namespace:psimag
OrbitSetType	PartialPsimag/Symmetry/Orbits.h	/^    typedef std::set<int>                                                     OrbitSetType;$/;"	t	class:psimag::Orbits
OrbitSetType	PartialPsimag/Symmetry/Star.h	/^    typedef std::set<int>                                                 OrbitSetType;$/;"	t	class:psimag::Star
OrbitSpaceType	PartialPsimag/Symmetry/Orbits.h	/^    typedef std::vector<OrbitType>                                            OrbitSpaceType;$/;"	t	class:psimag::Orbits
OrbitSpaceType	PartialPsimag/Symmetry/Star.h	/^    typedef std::vector<OrbitType>                                        OrbitSpaceType;$/;"	t	class:psimag::Star
OrbitType	PartialPsimag/Symmetry/Orbits.h	/^    typedef std::vector<int>                                                  OrbitType;$/;"	t	class:psimag::Orbits
OrbitType	PartialPsimag/Symmetry/Star.h	/^    typedef std::vector<int>                                              OrbitType;$/;"	t	class:psimag::Star
Orbits	PartialPsimag/Symmetry/Orbits.h	/^    Orbits()$/;"	f	class:psimag::Orbits
Orbits	PartialPsimag/Symmetry/Orbits.h	/^    Orbits(const Orbits& other)$/;"	f	class:psimag::Orbits
Orbits	PartialPsimag/Symmetry/Orbits.h	/^  class Orbits:$/;"	c	namespace:psimag
OrbitsType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef Orbits<Field>                                                     OrbitsType;$/;"	t	class:psimag::SymmetryGroup
OrbsToIndex	parameters.h	/^		IntMatrixType OrbsToIndex;$/;"	m	class:rpa::parameters
OriginLocator	PartialPsimag/Symmetry/OriginLocator.h	/^  class OriginLocator: public PatternBase<Field,DIM,NUMPOS,Occupant,Algorithms>  {$/;"	c	namespace:psimag
OriginalType	PartialPsimag/Symmetry/TypeManip.h	/^        typedef T OriginalType;$/;"	t	struct:psimag::Type2Type
Out	PsimagLite/src/IoSimple.h	/^			Out()  : rank_(0),fout_(0) {}$/;"	f	class:PsimagLite::IoSimple::Out
Out	PsimagLite/src/IoSimple.h	/^			Out(const std::string& fn,int rank) : rank_(rank),filename_(fn),fout_(0)$/;"	f	class:PsimagLite::IoSimple::Out
Out	PsimagLite/src/IoSimple.h	/^			Out(std::ostream& os) : rank_(0), filename_("OSTREAM")$/;"	f	class:PsimagLite::IoSimple::Out
Out	PsimagLite/src/IoSimple.h	/^		class Out {$/;"	c	class:PsimagLite::IoSimple
PACK_INDICES_H	PsimagLite/src/PackIndices.h	/^#define PACK_INDICES_H$/;"	d
PAIRING_H	pairing.h	/^#define PAIRING_H$/;"	d
PARAMETERS_FOR_SOLVER_H	PsimagLite/src/ParametersForSolver.h	/^#define PARAMETERS_FOR_SOLVER_H$/;"	d
PARAMETERS_H	parameters.h	/^#define PARAMETERS_H$/;"	d
PATTERN_H	PartialPsimag/Symmetry/Pattern.h	/^#define PATTERN_H$/;"	d
PI	PartialPsimag/Real.h	/^#define PI /;"	d
PI	PartialPsimag/Real.h	/^#undef PI$/;"	d
PLOT_PARAMS_H	PsimagLite/src/PlotParams.h	/^#define PLOT_PARAMS_H$/;"	d
PLUS	PartialPsimag/OperationClosure.h	/^    typedef enum{FourierTransform,PLUS,MINUS,TIMES,DIVIDE,INV} Type;$/;"	e	enum:psimag::OP::__anon112
PLUS	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
PRINT_FUNCTOR	PartialPsimag/Symmetry/Mat/MatPrint.h	/^  class PRINT_FUNCTOR {$/;"	c	namespace:psimag
PRODUCE	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      static T PRODUCE(EType el, ArgType& arg) {$/;"	f	class:psimag::EQUAL_VAL::EqualReducerType
PRODUCE	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      static T PRODUCE(EType el, OType otherEl, ArgType& arg) {$/;"	f	class:psimag::CLOSE::CloseReducerType
PRODUCE	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      static T PRODUCE(EType el, OType otherEl, ArgType& arg) {$/;"	f	class:psimag::EQUAL::EqualReducerType
PRODUCE	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      static T PRODUCE(const EType el, const OType otherEl, ArgType& arg) {$/;"	f	class:psimag::L2NORM::MagnitudeReducerType
PRODUCE	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      static T PRODUCE(const EType el, const OType otherEl, ArgType& arg) {$/;"	f	class:psimag::MAGNITUDE::MagnitudeReducerType
PRODUCE	PartialPsimag/Symmetry/Mat/MatMax.h	/^      static T PRODUCE(const EType el, const OType otherEl, ArgType& arg) {$/;"	f	class:psimag::MAX::MaxReducerType
PRODUCE	PartialPsimag/Symmetry/Mat/MatTrace.h	/^      static T PRODUCE(T el) {$/;"	f	class:psimag::TRACE::TraceReducerType
PROFILING_H_	PsimagLite/src/Profiling.h	/^#define PROFILING_H_$/;"	d
PROGRESS_INDICATOR_H	PsimagLite/src/ProgressIndicator.h	/^#define PROGRESS_INDICATOR_H$/;"	d
PSICOMPLEX_H_	PsimagLite/src/Complex.h	/^#define PSICOMPLEX_H_$/;"	d
PSIMAGLITE_STACK_H_	PsimagLite/src/Stack.h	/^#define PSIMAGLITE_STACK_H_$/;"	d
PSIMAG_AbstractRat_H	PartialPsimag/Symmetry/AbstractRat.h	/^#define PSIMAG_AbstractRat_H$/;"	d
PSIMAG_Assert_H	PartialPsimag/PSIMAGAssert.h	/^#define PSIMAG_Assert_H$/;"	d
PSIMAG_Assert_H	PsimagLite/src/JSON/PSIMAGAssert.h	/^#define PSIMAG_Assert_H$/;"	d
PSIMAG_BLAS	PartialPsimag/BLAS.h	/^#define PSIMAG_BLAS$/;"	d
PSIMAG_BLAS	PsimagLite/src/BLAS.h	/^#define PSIMAG_BLAS$/;"	d
PSIMAG_BravaisType_H	PartialPsimag/Symmetry/BravaisType.h	/^#define PSIMAG_BravaisType_H$/;"	d
PSIMAG_CONVENTIONALCRYSTAL_H	PartialPsimag/Symmetry/ConventionalCrystal.h	/^#define PSIMAG_CONVENTIONALCRYSTAL_H$/;"	d
PSIMAG_CRYSTAL_H	PartialPsimag/Symmetry/Crystal.h	/^#define PSIMAG_CRYSTAL_H$/;"	d
PSIMAG_CellParameters_H	PartialPsimag/Symmetry/CellParameters.h	/^#define PSIMAG_CellParameters_H$/;"	d
PSIMAG_CellPosition_H	PartialPsimag/Symmetry/CellPosition.h	/^#define PSIMAG_CellPosition_H$/;"	d
PSIMAG_Cell_H	PartialPsimag/Symmetry/PrimitiveCell.h	/^#define PSIMAG_Cell_H$/;"	d
PSIMAG_Centering2D_H	PartialPsimag/Symmetry/CeneringPointGroup.h	/^#define PSIMAG_Centering2D_H$/;"	d
PSIMAG_Centering2D_H	PartialPsimag/Symmetry/Centering2D.h	/^#define PSIMAG_Centering2D_H$/;"	d
PSIMAG_Centering_H	PartialPsimag/Symmetry/Centering.h	/^#define PSIMAG_Centering_H$/;"	d
PSIMAG_ConventionalLattice_H	PartialPsimag/Symmetry/ConventionalLattice.h	/^#define PSIMAG_ConventionalLattice_H$/;"	d
PSIMAG_DCA_Transposer_H	PsimagLite/src/JSON/Transposer.h	/^#define PSIMAG_DCA_Transposer_H$/;"	d
PSIMAG_FieldConvert_H	PartialPsimag/Symmetry/FieldConvert.h	/^#define PSIMAG_FieldConvert_H$/;"	d
PSIMAG_FieldParser_H	PartialPsimag/Symmetry/FieldParser.h	/^#define PSIMAG_FieldParser_H$/;"	d
PSIMAG_FiniteGroup_H	PartialPsimag/Symmetry/FiniteGroup.h	/^#define PSIMAG_FiniteGroup_H$/;"	d
PSIMAG_ForEachCentering_H	PartialPsimag/Symmetry/ForEachCentering.h	/^#define PSIMAG_ForEachCentering_H$/;"	d
PSIMAG_FourFoldNSymmetryElement2D_H	PartialPsimag/Symmetry/FourFoldN2D.h	/^#define PSIMAG_FourFoldNSymmetryElement2D_H$/;"	d
PSIMAG_FourFoldSymmetryElement2D_H	PartialPsimag/Symmetry/FourFold2D.h	/^#define PSIMAG_FourFoldSymmetryElement2D_H$/;"	d
PSIMAG_GEOMETRY_HEADER_H	PartialPsimag/Symmetry/PsimagGeometry.h	/^#define PSIMAG_GEOMETRY_HEADER_H$/;"	d
PSIMAG_GlideSymmetry2D_H	PartialPsimag/Symmetry/Glide2D.h	/^#define PSIMAG_GlideSymmetry2D_H$/;"	d
PSIMAG_IdentitySymmetryElement2D_H	PartialPsimag/Symmetry/IdentityElement2D.h	/^#define PSIMAG_IdentitySymmetryElement2D_H$/;"	d
PSIMAG_IndexedMatrix_H	PartialPsimag/IndexedMatrix.h	/^#define PSIMAG_IndexedMatrix_H$/;"	d
PSIMAG_InverseLatticeTransformation_H	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^#define PSIMAG_InverseLatticeTransformation_H$/;"	d
PSIMAG_KISS_H	PartialPsimag/KISS.h	/^#define PSIMAG_KISS_H$/;"	d
PSIMAG_LAPACK	PartialPsimag/LAPACK.h	/^#define PSIMAG_LAPACK$/;"	d
PSIMAG_LatticeTransformationBase_H	PartialPsimag/Symmetry/LatticeTransformationBase.h	/^#define PSIMAG_LatticeTransformationBase_H$/;"	d
PSIMAG_LatticeTransformation_H	PartialPsimag/Symmetry/LatticeTransformation.h	/^#define PSIMAG_LatticeTransformation_H$/;"	d
PSIMAG_Lattice_H	PartialPsimag/Symmetry/Lattice.h	/^#define PSIMAG_Lattice_H$/;"	d
PSIMAG_MatAlgorithms_H	PartialPsimag/Symmetry/Mat/MatAlgorithms.h	/^#define PSIMAG_MatAlgorithms_H$/;"	d
PSIMAG_MatCopy_H	PartialPsimag/Symmetry/Mat/MatCopy.h	/^#define PSIMAG_MatCopy_H$/;"	d
PSIMAG_MatDet_H	PartialPsimag/Symmetry/Mat/MatDet.h	/^#define PSIMAG_MatDet_H$/;"	d
PSIMAG_MatDifference_H	PartialPsimag/Symmetry/Mat/MatDifference.h	/^#define PSIMAG_MatDifference_H$/;"	d
PSIMAG_MatEqual_H	PartialPsimag/Symmetry/Mat/MatEqual.h	/^#define PSIMAG_MatEqual_H$/;"	d
PSIMAG_MatForEach3_H	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^#define PSIMAG_MatForEach3_H$/;"	d
PSIMAG_MatForEachDiagonal_H	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^#define PSIMAG_MatForEachDiagonal_H$/;"	d
PSIMAG_MatForEach_H	PartialPsimag/Symmetry/Mat/MatForEach.h	/^#define PSIMAG_MatForEach_H$/;"	d
PSIMAG_MatForeach2_H	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^#define PSIMAG_MatForeach2_H$/;"	d
PSIMAG_MatIdentity_H	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^#define PSIMAG_MatIdentity_H$/;"	d
PSIMAG_MatInverse_H	PartialPsimag/Symmetry/Mat/MatInverse.h	/^#define PSIMAG_MatInverse_H$/;"	d
PSIMAG_MatMagnitude_H	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^#define PSIMAG_MatMagnitude_H$/;"	d
PSIMAG_MatMax_H	PartialPsimag/Symmetry/Mat/MatMax.h	/^#define PSIMAG_MatMax_H$/;"	d
PSIMAG_MatMultvec_H	PartialPsimag/Symmetry/Mat/MatMult.h	/^#define PSIMAG_MatMultvec_H$/;"	d
PSIMAG_MatPrint_H	PartialPsimag/Symmetry/Mat/MatPrint.h	/^#define PSIMAG_MatPrint_H$/;"	d
PSIMAG_MatReduce2_H	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^#define PSIMAG_MatReduce2_H$/;"	d
PSIMAG_MatReduceDiagonal_H	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^#define PSIMAG_MatReduceDiagonal_H$/;"	d
PSIMAG_MatReduce_H	PartialPsimag/Symmetry/Mat/MatReduce.h	/^#define PSIMAG_MatReduce_H$/;"	d
PSIMAG_MatSum_H	PartialPsimag/Symmetry/Mat/MatSum.h	/^#define PSIMAG_MatSum_H$/;"	d
PSIMAG_MatTrace_H	PartialPsimag/Symmetry/Mat/MatTrace.h	/^#define PSIMAG_MatTrace_H$/;"	d
PSIMAG_MatTraits_H	PartialPsimag/Symmetry/Mat/MatTraits.h	/^#define PSIMAG_MatTraits_H$/;"	d
PSIMAG_MatTranspose_H	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^#define PSIMAG_MatTranspose_H$/;"	d
PSIMAG_MatUtil_H_	PartialPsimag/Symmetry/Mat/MatUtil.h	/^#define PSIMAG_MatUtil_H_$/;"	d
PSIMAG_Mat_H	PartialPsimag/Symmetry/Mat/Mat.h	/^#define PSIMAG_Mat_H$/;"	d
PSIMAG_MatrixLike_H	PartialPsimag/MatrixLike.h	/^#define PSIMAG_MatrixLike_H$/;"	d
PSIMAG_MatrixLike_H	PsimagLite/src/JSON/MatrixLike.h	/^#define PSIMAG_MatrixLike_H$/;"	d
PSIMAG_MatrixSlice_H	PartialPsimag/MatrixSlice.h	/^#define PSIMAG_MatrixSlice_H$/;"	d
PSIMAG_Matrix_H	PartialPsimag/Matrix.h	/^#define PSIMAG_Matrix_H$/;"	d
PSIMAG_MetricTensor_H	PartialPsimag/Symmetry/MetricTensor.h	/^#define PSIMAG_MetricTensor_H$/;"	d
PSIMAG_Mirror2DSymmetry2D_H	PartialPsimag/Symmetry/Mirror2D.h	/^#define PSIMAG_Mirror2DSymmetry2D_H$/;"	d
PSIMAG_NullType_H	PartialPsimag/Symmetry/NullType.h	/^#define PSIMAG_NullType_H$/;"	d
PSIMAG_Occupant_H	PartialPsimag/Symmetry/Occupant.h	/^#define PSIMAG_Occupant_H$/;"	d
PSIMAG_Operation_Closures_H	PartialPsimag/OperationClosure.h	/^#define PSIMAG_Operation_Closures_H$/;"	d
PSIMAG_Operation_Closures_H	PsimagLite/src/JSON/OperationClosure.h	/^#define PSIMAG_Operation_Closures_H$/;"	d
PSIMAG_PatternWithLattice_H	PartialPsimag/Symmetry/PatternWithLattice.h	/^#define PSIMAG_PatternWithLattice_H$/;"	d
PSIMAG_RealPart_H	PartialPsimag/RealPart.h	/^#define PSIMAG_RealPart_H$/;"	d
PSIMAG_Real_H	PartialPsimag/Real.h	/^#define PSIMAG_Real_H$/;"	d
PSIMAG_ReciprocalLattice_H	PartialPsimag/Symmetry/ReciprocalLattice.h	/^#define PSIMAG_ReciprocalLattice_H$/;"	d
PSIMAG_Reciprocal_H	PartialPsimag/Symmetry/Reciprocal.h	/^#define PSIMAG_Reciprocal_H$/;"	d
PSIMAG_ReducedLattice_H	PartialPsimag/Symmetry/ReducedLattice.h	/^#define PSIMAG_ReducedLattice_H$/;"	d
PSIMAG_Reducer_H	PartialPsimag/Symmetry/Reducer.h	/^#define PSIMAG_Reducer_H$/;"	d
PSIMAG_STLUtil_H_	PartialPsimag/Symmetry/STLUtil.h	/^#define PSIMAG_STLUtil_H_$/;"	d
PSIMAG_SearchTable_H	PartialPsimag/Symmetry/SearchTable.h	/^#define PSIMAG_SearchTable_H$/;"	d
PSIMAG_SeitzMatrixTraits_H	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^#define PSIMAG_SeitzMatrixTraits_H$/;"	d
PSIMAG_Simple2DReducer_H	PartialPsimag/Symmetry/Simple2DReducer.h	/^#define PSIMAG_Simple2DReducer_H$/;"	d
PSIMAG_SixFoldNSymmetryElement2D_H	PartialPsimag/Symmetry/SixFoldN2D.h	/^#define PSIMAG_SixFoldNSymmetryElement2D_H$/;"	d
PSIMAG_SixFoldSymmetryElement2D_H	PartialPsimag/Symmetry/SixFold2D.h	/^#define PSIMAG_SixFoldSymmetryElement2D_H$/;"	d
PSIMAG_SymmetryElements2D_H	PartialPsimag/Symmetry/SymmetryElements2D.h	/^#define PSIMAG_SymmetryElements2D_H$/;"	d
PSIMAG_SymmetryOperations2D_H	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^#define PSIMAG_SymmetryOperations2D_H$/;"	d
PSIMAG_ThreeFoldNSymmetryElement2D_H	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^#define PSIMAG_ThreeFoldNSymmetryElement2D_H$/;"	d
PSIMAG_ThreeFoldSymmetryElement2D_H	PartialPsimag/Symmetry/ThreeFold2D.h	/^#define PSIMAG_ThreeFoldSymmetryElement2D_H$/;"	d
PSIMAG_TwoFoldSymmetryElement2D_H	PartialPsimag/Symmetry/TwoFold2D.h	/^#define PSIMAG_TwoFoldSymmetryElement2D_H$/;"	d
PSIMAG_ValueTypeFunction_H	PartialPsimag/ValueTypeFunction.h	/^#define PSIMAG_ValueTypeFunction_H$/;"	d
PSIMAG_Vec_H	PartialPsimag/Vec.h	/^#define PSIMAG_Vec_H$/;"	d
PSIMAG_VectorLike_H	PartialPsimag/Vector.h	/^#define PSIMAG_VectorLike_H$/;"	d
PSIMAG_VectorLike_H	PartialPsimag/VectorLike.h	/^#define PSIMAG_VectorLike_H$/;"	d
PSIVECTOR_H_	PsimagLite/src/Vector.h	/^#define PSIVECTOR_H_$/;"	d
PTHREADS_HEADER_H	PsimagLite/src/Pthreads.h	/^#define PTHREADS_HEADER_H$/;"	d
PackIndices	PsimagLite/src/PackIndices.h	/^		PackIndices(size_t n) : n_(n) { }$/;"	f	class:PsimagLite::PackIndices
PackIndices	PsimagLite/src/PackIndices.h	/^	class PackIndices {$/;"	c	namespace:PsimagLite
Pair	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^      Pair(StateType s, ActionType a):$/;"	f	class:JsonParser::AugmentedStateTranslationTable::Pair
Pair	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^      Pair(StateType s, ActionType a, ActionType b):$/;"	f	class:JsonParser::AugmentedStateTranslationTable::Pair
Pair	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^      Pair(const Pair& other):$/;"	f	class:JsonParser::AugmentedStateTranslationTable::Pair
Pair	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^    class Pair {$/;"	c	class:JsonParser::AugmentedStateTranslationTable
PairType	PsimagLite/src/Geometry/GeometryFactory.h	/^		typedef std::pair<size_t,size_t> PairType;$/;"	t	class:PsimagLite::GeometryFactory
PairType	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		typedef std::pair<int,int> PairType;$/;"	t	class:PsimagLite::KTwoNiFFour
PairType	PsimagLite/src/Geometry/LadderBath.h	/^			typedef std::pair<int,int> PairType;$/;"	t	class:PsimagLite::LadderBath
PairType	PsimagLite/src/Rusage.h	/^		typedef std::pair<size_t,size_t> PairType;$/;"	t	class:PsimagLite::Rusage
PairType	PsimagLite/src/Sort.h	/^	typedef std::pair<FieldType,size_t> PairType;$/;"	t	class:Sort
ParametersForSolver	PsimagLite/src/ParametersForSolver.h	/^		ParametersForSolver() $/;"	f	struct:PsimagLite::ParametersForSolver
ParametersForSolver	PsimagLite/src/ParametersForSolver.h	/^	struct ParametersForSolver {$/;"	s	namespace:PsimagLite
ParametersType	PsimagLite/src/ChebyshevSerializer.h	/^		typedef ParametersForSolver<RealType> ParametersType;$/;"	t	class:PsimagLite::ChebyshevSerializer
ParametersType	PsimagLite/src/ContinuedFraction.h	/^		typedef ParametersForSolver<RealType> ParametersType;$/;"	t	class:PsimagLite::ContinuedFraction
ParseBuffer	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^    ParseBuffer():$/;"	f	class:JsonParser::ParseBuffer
ParseBuffer	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^  class ParseBuffer: $/;"	c	namespace:JsonParser
Pattern	PartialPsimag/Symmetry/OriginLocator.h	/^    Pattern(LatticeType& lattice): $/;"	f	class:psimag::OriginLocator
Pattern	PartialPsimag/Symmetry/Pattern.h	/^    Pattern(): $/;"	f	class:psimag::Pattern
Pattern	PartialPsimag/Symmetry/Pattern.h	/^    Pattern(const Occupant& occupant): $/;"	f	class:psimag::Pattern
Pattern	PartialPsimag/Symmetry/Pattern.h	/^    Pattern(const Pattern& pat): $/;"	f	class:psimag::Pattern
Pattern	PartialPsimag/Symmetry/Pattern.h	/^    Pattern(const PatternDataType& patternData): $/;"	f	class:psimag::Pattern
Pattern	PartialPsimag/Symmetry/Pattern.h	/^  class Pattern  $/;"	c	namespace:psimag
PatternBaseType	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef PatternBase<Field,DIM,NUMPOS,Occupant,Algorithms> PatternBaseType;$/;"	t	class:psimag::OriginLocator
PatternBaseType	PartialPsimag/Symmetry/PatternWithLattice.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                 PatternBaseType;$/;"	t	class:psimag::PatternWithLattice
PatternData	PartialPsimag/Symmetry/PatternData.h	/^    PatternData() {}$/;"	f	class:psimag::PatternData
PatternData	PartialPsimag/Symmetry/PatternData.h	/^  class PatternData  {$/;"	c	namespace:psimag
PatternDataType	PartialPsimag/Symmetry/Crystal.h	/^    typedef PatternData        <Field,DIM,Occupant,            Algorithms> PatternDataType;$/;"	t	class:psimag::Crystal
PatternDataType	PartialPsimag/Symmetry/CrystalBase.h	/^    typedef PatternData<Field,DIM,Occupant,Algorithms>                    PatternDataType;$/;"	t	class:psimag::CrystalBase
PatternDataType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef PatternData<Field,DIM,Occupant,Algorithms>                        PatternDataType;$/;"	t	class:psimag::FloodTiler
PatternDataType	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    typedef PatternData<Field,DIM,Occupant,Algorithms>                    PatternDataType;$/;"	t	class:psimag::LatticeWithPattern
PatternDataType	PartialPsimag/Symmetry/OccupantClosure.h	/^    typedef PatternData<Field,DIM,Occupant,Algorithms>                 PatternDataType;$/;"	t	class:psimag::OccupantClosure
PatternDataType	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef PatternData<Field,DIM,NUMPOS,Occupant>        PatternDataType;$/;"	t	class:psimag::OriginLocator
PatternDataType	PartialPsimag/Symmetry/Pattern.h	/^    typedef PatternData<Field,DIM,Occupant,Algorithms> PatternDataType;$/;"	t	class:psimag::Pattern
PatternDataType	PartialPsimag/Symmetry/PatternWithLattice.h	/^    typedef PatternData<Field,DIM,Occupant,Algorithms>             PatternDataType;$/;"	t	class:psimag::PatternWithLattice
PatternDataType	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    typedef PatternData<Field,DIM,Occupant,Algorithms> PatternDataType;$/;"	t	class:psimag::SuperCrystalBuilder
PatternType	PartialPsimag/Symmetry/Crystal.h	/^    typedef Pattern            <Field,DIM,Occupant,            Algorithms> PatternType;$/;"	t	class:psimag::Crystal
PatternType	PartialPsimag/Symmetry/CrystalBase.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                        PatternType;$/;"	t	class:psimag::CrystalBase
PatternType	PartialPsimag/Symmetry/FloodTiler.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                            PatternType;$/;"	t	class:psimag::FloodTiler
PatternType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                            PatternType;$/;"	t	class:psimag::GroupAction
PatternType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                                  PatternType;$/;"	t	class:psimag::GroupMultiplicationTable
PatternType	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                        PatternType;$/;"	t	class:psimag::LatticeWithPattern
PatternType	PartialPsimag/Symmetry/OccupantClosure.h	/^    typedef PatternTemplate<Field,DIM,Occupant,LatticeType,Algorithms> PatternType;$/;"	t	class:psimag::OccupantClosure
PatternType	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef Pattern<Field,DIM,NUMPOS,Occupant,Algorithms>     PatternType;$/;"	t	class:psimag::OriginLocator
PatternType	PartialPsimag/Symmetry/Pattern.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>     PatternType;$/;"	t	class:psimag::Pattern
PatternType	PartialPsimag/Symmetry/PatternData.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>       PatternType;$/;"	t	class:psimag::PatternData
PatternType	PartialPsimag/Symmetry/Star.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                        PatternType;$/;"	t	class:psimag::Star
PatternType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                        PatternType;$/;"	t	class:psimag::SuperCrystal
PatternType	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>     PatternType;$/;"	t	class:psimag::SuperCrystalBuilder
PatternType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                        PatternType;$/;"	t	class:psimag::Symmetry
PatternType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                            PatternType;$/;"	t	class:psimag::SymmetryGroup
PatternType	PartialPsimag/Symmetry/TestPattern.h	/^    typedef Pattern<Field,DIM,Occupant,Algorithms>                              PatternType;$/;"	t	class:psimag::TestPattern
PatternWithLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^    PatternWithLattice(const LatticeType& lattice): $/;"	f	class:psimag::PatternWithLattice
PatternWithLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^    PatternWithLattice(const LatticeType& lattice, PatternDataType& patternData): $/;"	f	class:psimag::PatternWithLattice
PatternWithLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^    PatternWithLattice(const LatticeType& lattice, const Occupant& occupant): $/;"	f	class:psimag::PatternWithLattice
PatternWithLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^    PatternWithLattice(const Pattern<Field,DIM,Occupant,Algorithms>& pat, $/;"	f	class:psimag::PatternWithLattice
PatternWithLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^    PatternWithLattice(const PatternWithLattice& pat): $/;"	f	class:psimag::PatternWithLattice
PatternWithLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^    PatternWithLattice(const PatternWithLattice& pat, const LatticeTransformationType& transform): $/;"	f	class:psimag::PatternWithLattice
PatternWithLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^  class PatternWithLattice: $/;"	c	namespace:psimag
Pi	ferminator.h	/^		FieldType Pi;$/;"	m	class:rpa::ferminator
PlotDataType	PsimagLite/src/ChebyshevSerializer.h	/^		typedef std::vector<std::pair<RealType,RealType> > PlotDataType;$/;"	t	class:PsimagLite::ChebyshevSerializer
PlotDataType	PsimagLite/src/ContinuedFraction.h	/^		typedef std::vector<std::pair<RealType,ComplexType> > PlotDataType;$/;"	t	class:PsimagLite::ContinuedFraction
PlotDataType	PsimagLite/src/ContinuedFractionCollection.h	/^		typedef typename ContinuedFractionType::PlotDataType PlotDataType;$/;"	t	class:PsimagLite::ContinuedFractionCollection
PlotParams	PsimagLite/src/PlotParams.h	/^	PlotParams(const RealType& wbegin,const RealType& wend,const RealType& wstep,const RealType& wdelta)$/;"	f	struct:PsimagLite::PlotParams
PlotParams	PsimagLite/src/PlotParams.h	/^struct PlotParams {$/;"	s	namespace:PsimagLite
PlotParamsType	PsimagLite/drivers/continuedFractionCollection.cpp	/^typedef ContinuedFractionType::PlotParamsType PlotParamsType;$/;"	t	file:
PlotParamsType	PsimagLite/src/ChebyshevSerializer.h	/^		typedef PlotParams<RealType> PlotParamsType;$/;"	t	class:PsimagLite::ChebyshevSerializer
PlotParamsType	PsimagLite/src/ContinuedFraction.h	/^		typedef PlotParams<RealType> PlotParamsType;$/;"	t	class:PsimagLite::ContinuedFraction
PlotParamsType	PsimagLite/src/ContinuedFractionCollection.h	/^		typedef typename ContinuedFractionType::PlotParamsType PlotParamsType;$/;"	t	class:PsimagLite::ContinuedFractionCollection
PointPermutationType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef std::vector<int>                                                  PointPermutationType;$/;"	t	class:psimag::GroupAction
PointPermutationType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef std::vector<int>                                                  PointPermutationType;$/;"	t	class:psimag::SymmetryGroup
Pool	PythonScripts/Sr2RuO4.py	/^from multiprocessing import Pool$/;"	i
Position	PsimagLite/src/JSON/JSN_Writer.h	/^    typedef enum {First,Middle,Last} Position;$/;"	t	class:dca::JSN	typeref:enum:dca::JSN::__anon119
PositionMatCols	PartialPsimag/Symmetry/OriginLocator.h	/^    enum { PositionMatCols= NUMPOS, PositionMatRows=DIM+1};$/;"	e	enum:psimag::OriginLocator::__anon65
PositionMatRows	PartialPsimag/Symmetry/OriginLocator.h	/^    enum { PositionMatCols= NUMPOS, PositionMatRows=DIM+1};$/;"	e	enum:psimag::OriginLocator::__anon65
PostProcType	PsimagLite/src/ChebyshevSolver.h	/^		typedef ChebyshevSerializer<RealType,TridiagonalMatrixType> PostProcType;$/;"	t	class:PsimagLite::ChebyshevSolver
PostProcType	PsimagLite/src/LanczosSolver.h	/^		                    PostProcType;$/;"	t	class:PsimagLite::LanczosSolver
PostProcType	PsimagLite/src/LanczosVectors.h	/^		                    PostProcType;$/;"	t	class:PsimagLite::LanczosVectors
PrimitiveCell	PartialPsimag/Symmetry/PrimitiveCell.h	/^  class PrimitiveCell: public Cell<Field,DIM> {$/;"	c	namespace:psimag
PrimitiveToCentered	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    static const TransformationType PrimitiveToCentered() {$/;"	f	class:psimag::CenteringPointGroup
PrimitiveToCentered	PartialPsimag/Symmetry/Centering2D.h	/^    static const TransformationType PrimitiveToCentered() {$/;"	f	class:psimag::Centering
PrintArrayWidth	PsimagLite/src/JSON/JSN_Writer.h	/^  template<>           class PrintArrayWidth<double> {public: enum {value=13}; };$/;"	c	namespace:dca
PrintArrayWidth	PsimagLite/src/JSON/JSN_Writer.h	/^  template<typename T> class PrintArrayWidth         {public: enum {value=7 }; };$/;"	c	namespace:dca
PrintFunctionType	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    class PrintFunctionType {$/;"	c	class:psimag::PRINT_FUNCTOR
Profiling	PsimagLite/src/Profiling.h	/^			Profiling(const std::string& s) : message_(s),start_(clock())$/;"	f	class:PsimagLite::Profiling
Profiling	PsimagLite/src/Profiling.h	/^	class  Profiling {$/;"	c	namespace:PsimagLite
ProgressIndicator	PsimagLite/src/ProgressIndicator.h	/^		ProgressIndicator(const std::string& caller,size_t rank) : caller_(caller),rank_(rank) $/;"	f	class:PsimagLite::ProgressIndicator
ProgressIndicator	PsimagLite/src/ProgressIndicator.h	/^	class ProgressIndicator {$/;"	c	namespace:PsimagLite
PsimagGeometry	PartialPsimag/Symmetry/PsimagGeometry.h	/^  class PsimagGeometry {$/;"	c	namespace:rpa
PsimagLite	PsimagLite/src/AlmostEqual.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/BitManip.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ChebyshevFunction.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ChebyshevSerializer.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ChebyshevSolver.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Concurrency.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ConcurrencyMpi.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ConcurrencySerial.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ContinuedFraction.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ContinuedFractionCollection.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/CrsMatrix.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Fermi.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/Chain.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/Geometry.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/GeometryDirection.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/GeometryFactory.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/GeometryTerm.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/GeometryUtils.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/KTwoNiFFour.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/Ladder.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/LadderBath.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Geometry/LadderX.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/GslWrapper.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/HostInfo.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/IoSimple.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/LanczosSolver.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/LanczosVectors.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/LineMarker.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/LinearPrediction.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Matrix.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/MemoryUsage.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Minimizer.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/NoPthreads.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/PackIndices.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ParametersForSolver.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/PlotParams.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Profiling.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/ProgressIndicator.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Pthreads.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Random48.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/RandomForTests.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Range.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Rusage.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/SampleCRSMatrix.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/SparseRow.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Tokenizer.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/TridiagonalMatrix.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/TypeToString.h	/^namespace PsimagLite {$/;"	n
PsimagLite	PsimagLite/src/Vector.h	/^namespace PsimagLite {$/;"	n
Psimag_APPLIED_SYMMETRY_ELEMENT	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^#define  Psimag_APPLIED_SYMMETRY_ELEMENT$/;"	d
Psimag_APPLIED_SYMMETRY_ELEMENT	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^#define  Psimag_APPLIED_SYMMETRY_ELEMENT$/;"	d
Psimag_BasicCrystalAlgorithms_H	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^#define Psimag_BasicCrystalAlgorithms_H$/;"	d
Psimag_Cartesian_Position	PartialPsimag/Symmetry/CartesianPosition.h	/^#define  Psimag_Cartesian_Position$/;"	d
Psimag_Cartesian_Rotation	PartialPsimag/Symmetry/CartesianRotation.h	/^#define  Psimag_Cartesian_Rotation$/;"	d
Psimag_Cartesian_Translation	PartialPsimag/Symmetry/CartesianTranslation.h	/^#define  Psimag_Cartesian_Translation$/;"	d
Psimag_CellRotation	PartialPsimag/Symmetry/CellRotation.h	/^#define  Psimag_CellRotation$/;"	d
Psimag_CellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^#define  Psimag_CellTranslation$/;"	d
Psimag_Cell_Direction	PartialPsimag/Symmetry/CellDirection.h	/^#define  Psimag_Cell_Direction$/;"	d
Psimag_CrystalBase_H	PartialPsimag/Symmetry/CrystalBase.h	/^#define Psimag_CrystalBase_H$/;"	d
Psimag_FloodTiler_H	PartialPsimag/Symmetry/FloodTiler.h	/^#define Psimag_FloodTiler_H$/;"	d
Psimag_GroupAction	PartialPsimag/Symmetry/GroupAction.h	/^#define  Psimag_GroupAction$/;"	d
Psimag_GroupMultiplicationTable	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^#define  Psimag_GroupMultiplicationTable$/;"	d
Psimag_HermiteNormalForm	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^#define  Psimag_HermiteNormalForm$/;"	d
Psimag_LatticeCoordinates	PartialPsimag/Symmetry/LatticeCoordinates.h	/^#define  Psimag_LatticeCoordinates$/;"	d
Psimag_LatticeTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^#define  Psimag_LatticeTranslation$/;"	d
Psimag_LatticeWithPattern_H	PartialPsimag/Symmetry/LatticeWithPattern.h	/^#define Psimag_LatticeWithPattern_H$/;"	d
Psimag_Miller_Direction	PartialPsimag/Symmetry/MillerDirection.h	/^#define  Psimag_Miller_Direction$/;"	d
Psimag_Orbits	PartialPsimag/Symmetry/Orbits.h	/^#define  Psimag_Orbits$/;"	d
Psimag_ReducedCrystal_H	PartialPsimag/Symmetry/ReducedCrystal.h	/^#define Psimag_ReducedCrystal_H$/;"	d
Psimag_SYMMETRY_ELEMENT	PartialPsimag/Symmetry/SymmetryElement.h	/^#define  Psimag_SYMMETRY_ELEMENT$/;"	d
Psimag_SYMMETRY_ELEMENT_NAME	PartialPsimag/Symmetry/SymmetryElementName.h	/^#define  Psimag_SYMMETRY_ELEMENT_NAME$/;"	d
Psimag_SYMMETRY_OPERATION	PartialPsimag/Symmetry/SymmetryOperation.h	/^#define  Psimag_SYMMETRY_OPERATION$/;"	d
Psimag_SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^#define  Psimag_SeitzMatrix$/;"	d
Psimag_Seitz_Position	PartialPsimag/Symmetry/SeitzPosition.h	/^#define  Psimag_Seitz_Position$/;"	d
Psimag_Seitz_Translation	PartialPsimag/Symmetry/SeitzTranslation.h	/^#define  Psimag_Seitz_Translation$/;"	d
Psimag_Seitz_Vector	PartialPsimag/Symmetry/SeitzVector.h	/^#define  Psimag_Seitz_Vector$/;"	d
Psimag_Seitz_Vectors	PartialPsimag/Symmetry/SeitzVectors.h	/^#define  Psimag_Seitz_Vectors$/;"	d
Psimag_SpaceGroup	PartialPsimag/Symmetry/SpaceGroup.h	/^#define  Psimag_SpaceGroup$/;"	d
Psimag_SpaceGroup2D	PartialPsimag/Symmetry/SpaceGroup2D.h	/^#define  Psimag_SpaceGroup2D$/;"	d
Psimag_SpaceGroup2D_Iterator	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^#define  Psimag_SpaceGroup2D_Iterator$/;"	d
Psimag_SpaceGroupConstructor	PartialPsimag/Symmetry/SpaceGroupConstructor.h	/^#define  Psimag_SpaceGroupConstructor$/;"	d
Psimag_SpaceGroupConstructor_2D	PartialPsimag/Symmetry/SpaceGroupConstructor2D.h	/^#define  Psimag_SpaceGroupConstructor_2D$/;"	d
Psimag_SpaceGroupData2D	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^#define  Psimag_SpaceGroupData2D$/;"	d
Psimag_Star	PartialPsimag/Symmetry/Star.h	/^#define  Psimag_Star$/;"	d
Psimag_SuperCrystalBuilder_H	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^#define Psimag_SuperCrystalBuilder_H$/;"	d
Psimag_SuperCrystal_H	PartialPsimag/Symmetry/SuperCrystal.h	/^#define Psimag_SuperCrystal_H$/;"	d
Psimag_SymmetryGroup	PartialPsimag/Symmetry/SymmetryGroup.h	/^#define  Psimag_SymmetryGroup$/;"	d
Psimag_Symmetry_H	PartialPsimag/Symmetry/Symmetry.h	/^#define Psimag_Symmetry_H$/;"	d
Psimag_TypeManip	PartialPsimag/Symmetry/TypeManip.h	/^#define  Psimag_TypeManip$/;"	d
PthreadFunctionStruct	PsimagLite/src/Pthreads.h	/^struct PthreadFunctionStruct {$/;"	s
Pthreads	PsimagLite/src/Pthreads.h	/^			Pthreads() $/;"	f	class:PsimagLite::Pthreads
Pthreads	PsimagLite/src/Pthreads.h	/^	class Pthreads : public PsimagLite::Concurrency<typename PthreadFunctionHolderType::RealType> {$/;"	c	namespace:PsimagLite
QVec	susceptibility.h	/^			std::vector<std::vector<FieldType> > QVec;$/;"	m	class:rpa::susceptibility
RANDOM48_H	PsimagLite/src/Random48.h	/^#define RANDOM48_H$/;"	d
RANDOM_FOR_TESTS_H	PsimagLite/src/RandomForTests.h	/^#define RANDOM_FOR_TESTS_H$/;"	d
RANGE_HEADER_H	PsimagLite/src/Range.h	/^#define RANGE_HEADER_H$/;"	d
RATIONAL_H	PartialPsimag/Symmetry/rational.h	/^#define RATIONAL_H$/;"	d
RCOL	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { RCOL= 0, NLROW=Traits::NROW};$/;"	e	enum:psimag::MatMultVecCol::__anon9
REDUCE	PartialPsimag/Symmetry/Mat/MatReduce.h	/^  class REDUCE {$/;"	c	namespace:psimag
REDUCE2	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^  class REDUCE2 {$/;"	c	namespace:psimag
REDUCE2_	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^  class REDUCE2_ {$/;"	c	namespace:psimag
REDUCE2_	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^  class REDUCE2_<ReducerType, MatType, MatTypeOther, Traits, TraitsO, ArgType, 0> {$/;"	c	namespace:psimag
REDUCE2_ELS	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^  class REDUCE2_ELS {$/;"	c	namespace:psimag
REDUCE2_ELS	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^  class REDUCE2_ELS<ReducerType, MatType, MatTypeOther, Traits, TraitsO, ArgType, ROW, 0> {$/;"	c	namespace:psimag
REDUCE_	PartialPsimag/Symmetry/Mat/MatReduce.h	/^  class REDUCE_ {$/;"	c	namespace:psimag
REDUCE_	PartialPsimag/Symmetry/Mat/MatReduce.h	/^  class REDUCE_<ReducerType, MatType, Traits, ArgType, 0> {$/;"	c	namespace:psimag
REDUCE_DIAG	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^  class REDUCE_DIAG {$/;"	c	namespace:psimag
REDUCE_DIAG_	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^  class REDUCE_DIAG_<Reducer, MatType, Traits, 0> {$/;"	c	namespace:psimag
REDUCE_DIAG_	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^  class REDUCE_DIAG_{$/;"	c	namespace:psimag
REDUCE_ELS	PartialPsimag/Symmetry/Mat/MatReduce.h	/^  class REDUCE_ELS {$/;"	c	namespace:psimag
REDUCE_ELS	PartialPsimag/Symmetry/Mat/MatReduce.h	/^  class REDUCE_ELS<ReducerType, MatType, Traits, ArgType, ROW, 0> {$/;"	c	namespace:psimag
REF	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class REF$/;"	c	class:psimag::ColMajorTraits
REF	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class REF$/;"	c	class:psimag::ConstantTraits
REF	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class REF$/;"	c	class:psimag::DoubleIndexTraits
REF	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class REF$/;"	c	class:psimag::ReverseDoubleIndexTraits
REF	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class REF$/;"	c	class:psimag::RowMajorTraits
REF	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^    class REF$/;"	c	class:psimag::SeitzMatrixTraits
REF_	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    typedef typename Traits::template  REF<MatType,0,0> REF_;$/;"	t	class:psimag::FOREACH_DIAG_
REF_	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    typedef typename Traits::template  REF<MatType,ROW,ROW> REF_;$/;"	t	class:psimag::FOREACH_DIAG_
REF_	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    typedef typename Traits::template  REF<MatType,0,0> REF_;$/;"	t	class:psimag::REDUCE_DIAG_
REF_	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    typedef typename Traits::template  REF<MatType,ROW,ROW> REF_;$/;"	t	class:psimag::REDUCE_DIAG_
REF_LHS	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    typedef typename Traits::template REF<MatType,   ROW,COL> REF_LHS;$/;"	t	class:psimag::FOREACH_ELS
REF_LHS	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    typedef typename TraitsLHS::template REF<MatType,   ROW,COL> REF_LHS;$/;"	t	class:psimag::FOREACH2_ELS
REF_LHS	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    typedef typename TraitsLHS::template REF<MatTypeLHS,   ROW,0>   REF_LHS;$/;"	t	class:psimag::FOREACH3_ELS
REF_LHS	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    typedef typename TraitsLHS::template REF<MatTypeLHS,   ROW,COL> REF_LHS;$/;"	t	class:psimag::FOREACH3_ELS
REF_LHS	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    typedef typename Traits::template  REF<MatType,ROW,0> REF_LHS;$/;"	t	class:psimag::REDUCE_ELS
REF_LHS	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    typedef typename Traits::template  REF<MatType,ROW,COL> REF_LHS;$/;"	t	class:psimag::REDUCE_ELS
REF_LHS	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename Traits::template  REF<MatType,ROW,0> REF_LHS;$/;"	t	class:psimag::REDUCE2_ELS
REF_LHS	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename Traits::template  REF<MatType,ROW,COL> REF_LHS;$/;"	t	class:psimag::REDUCE2_ELS
REF_RHS	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    typedef typename TraitsRHS::template REF<MatTypeRHS,ROW,COL> REF_RHS;$/;"	t	class:psimag::FOREACH2_ELS
REF_RHS	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    typedef typename TraitsRHS::template REF<MatTypeRHS,   ROW,0>   REF_RHS;$/;"	t	class:psimag::FOREACH3_ELS
REF_RHS	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    typedef typename TraitsRHS::template REF<MatTypeRHS,   ROW,COL> REF_RHS;$/;"	t	class:psimag::FOREACH3_ELS
REF_RHS	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename TraitsO::template REF<MatTypeOther,ROW,0> REF_RHS;$/;"	t	class:psimag::REDUCE2_ELS
REF_RHS	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename TraitsO::template REF<MatTypeOther,ROW,COL> REF_RHS;$/;"	t	class:psimag::REDUCE2_ELS
REF_Result	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    typedef typename TraitsLHS::template REF<MatTypeResult,ROW,0>   REF_Result;$/;"	t	class:psimag::FOREACH3_ELS
REF_Result	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^    typedef typename TraitsLHS::template REF<MatTypeResult,ROW,COL> REF_Result;$/;"	t	class:psimag::FOREACH3_ELS
RETRIEVER	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^			      LastColRetriever> ::Result RETRIEVER;$/;"	t	class:psimag::SeitzMatrixTraits::REF
RHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsRHS::ElType RHSType;$/;"	t	class:psimag::COPY::CopyFunctionType
RHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsRHS::ElType RHSType;$/;"	t	class:psimag::COPY::CopyMinusFunctionType
RHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsRHS::ElType RHSType;$/;"	t	class:psimag::COPY::CopyPlusFunctionType
RHSType	PartialPsimag/Symmetry/Mat/MatCopy.h	/^      typedef typename TraitsRHS::ElType RHSType;$/;"	t	class:psimag::COPY::CopyTimesFunctionType
RHSType	PartialPsimag/Symmetry/Mat/MatDifference.h	/^      typedef typename TraitsRHS::ElType    RHSType;$/;"	t	class:psimag::DIFFERENCE::DifferenceFunctionType
RHSType	PartialPsimag/Symmetry/Mat/MatSum.h	/^      typedef typename TraitsRHS::ElType    RHSType;$/;"	t	class:psimag::SUM::SumFunctionType
ROW	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static const size_t ROW = NROW - 1;$/;"	m	class:psimag::FOREACH_
ROW	PartialPsimag/Symmetry/Mat/MatForEach.h	/^    static const size_t ROW = NROW - ROWS_LEFT;$/;"	m	class:psimag::FOREACH_
ROW	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static const size_t ROW = NROW - 1;$/;"	m	class:psimag::FOREACH2_
ROW	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^    static const size_t ROW = NROW - ROWS_LEFT;$/;"	m	class:psimag::FOREACH2_
ROW	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    enum { ROW=0, NCOL = Traits::NCOL };$/;"	e	enum:psimag::TRANSPOSE::__anon49
RPA	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^class RPA:$/;"	c
RPA	PythonScripts/Sr2RuO4.py	/^class RPA:$/;"	c
RPA_CUO_H	rpa_CuO.h	/^#define RPA_CUO_H$/;"	d
RPA_H	rpa.h	/^#define RPA_H$/;"	d
RPA_MOMENTUMDOMAIN_H	momentumDomain.h	/^#define RPA_MOMENTUMDOMAIN_H$/;"	d
RREF	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      typedef typename RotationTraits_::template REF<RotationType_, ROW_, COL_> RREF;$/;"	t	class:psimag::SeitzMatrixTraits::REF
RROW	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { LCOL=0, RROW=LCOL };$/;"	e	enum:psimag::MatMultVecPos::__anon4
RROW	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { LCOL=0, RROW=LCOL };$/;"	e	enum:psimag::MatMultVecRow::__anon6
RROW	PartialPsimag/Symmetry/Mat/MatMult.h	/^    enum { RROW=LCOL };$/;"	e	enum:psimag::MatMultVecPos::__anon3
RUSAGE_H_H	PsimagLite/src/Rusage.h	/^#define RUSAGE_H_H$/;"	d
Random48	PsimagLite/src/Random48.h	/^		Random48(LongType seed,size_t rank = 0,size_t nprocs = 1)$/;"	f	class:PsimagLite::Random48
Random48	PsimagLite/src/Random48.h	/^	class  Random48 {$/;"	c	namespace:PsimagLite
RandomForTests	PsimagLite/src/RandomForTests.h	/^		RandomForTests() \/\/LongType seed = 127773,size_t rank = 0,size_t nprocs = 1)$/;"	f	class:PsimagLite::RandomForTests
RandomForTests	PsimagLite/src/RandomForTests.h	/^	class  RandomForTests {$/;"	c	namespace:PsimagLite
RandomType	PsimagLite/drivers/randomTest.cpp	/^typedef Random48<RealType> RandomType;$/;"	t	file:
Range	PsimagLite/src/Range.h	/^		Range(size_t start,$/;"	f	class:PsimagLite::Range
Range	PsimagLite/src/Range.h	/^	class Range {$/;"	c	namespace:PsimagLite
Range	PsimagLite/src/Range.h	/^	class Range<ConcurrencySerial<> > {$/;"	c	namespace:PsimagLite
RangeType	bandstructure.h	/^		typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	class:rpa::bandstructure
RangeType	chi0.h	/^		typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	class:rpa::calcChi0Matrix
RangeType	chi0.h	/^		typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	class:rpa::chi0q
RangeType	gap.h	/^		typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	class:rpa::gap
RangeType	gaps2D.h	/^		typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	class:rpa::gap2D
RangeType	gaps3D.h	/^        typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	class:rpa::gap3D
RangeType	main.cpp	/^typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	file:
RangeType	susceptibility.h	/^			typedef PsimagLite::Range<ConcurrencyType> RangeType;$/;"	t	class:rpa::susceptibility
RatedElementsType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef std::vector<SymmetryOperationType>                             RatedElementsType;$/;"	t	class:psimag::SymmetryElements
RatedOperationsType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef std::vector<SymmetryOperationType>                    RatedOperationsType;$/;"	t	class:psimag::Glide
RatedOperationsType	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    typedef std::vector<SymmetryOperationType>                             RatedOperationsType;$/;"	t	class:psimag::SymmetryOperations
Real	PartialPsimag/Real.h	/^typedef float Real;$/;"	t	namespace:psimag
RealPart	PartialPsimag/RealPart.h	/^    RealPart(ComplexMatrixLikeType& m):$/;"	f	class:psimag::RealPart
RealPart	PartialPsimag/RealPart.h	/^  class RealPart {$/;"	c	namespace:psimag
RealType	PsimagLite/drivers/combineContinuedFraction.cpp	/^typedef double RealType;$/;"	t	file:
RealType	PsimagLite/drivers/concurrencyTest.cpp	/^typedef double RealType;$/;"	t	file:
RealType	PsimagLite/drivers/continuedFraction.cpp	/^typedef double RealType;$/;"	t	file:
RealType	PsimagLite/drivers/continuedFractionCollection.cpp	/^typedef double RealType;$/;"	t	file:
RealType	PsimagLite/drivers/minimizer.cpp	/^typedef  double RealType;$/;"	t	file:
RealType	PsimagLite/drivers/randomTest.cpp	/^typedef double RealType;$/;"	t	file:
RealType	PsimagLite/drivers/range.cpp	/^typedef double RealType;$/;"	t	file:
RealType	PsimagLite/drivers/testCRSMatrix.cpp	/^typedef double RealType;$/;"	t	file:
RealType	PsimagLite/src/AkimaSpline.h	/^	typedef typename VectorType::value_type RealType;$/;"	t	class:AkimaSpline
RealType	PsimagLite/src/ChebyshevSolver.h	/^		typedef typename SolverParametersType::RealType RealType;$/;"	t	class:PsimagLite::ChebyshevSolver
RealType	PsimagLite/src/ContinuedFractionCollection.h	/^		typedef typename	TridiagonalMatrixType::value_type RealType;$/;"	t	class:PsimagLite::ContinuedFractionCollection
RealType	PsimagLite/src/LanczosSolver.h	/^		typedef typename SolverParametersType::RealType RealType;$/;"	t	class:PsimagLite::LanczosSolver
RealType	PsimagLite/src/ParametersForSolver.h	/^		typedef RealType_ RealType;$/;"	t	struct:PsimagLite::ParametersForSolver
Reciprocal	PartialPsimag/Symmetry/Reciprocal.h	/^  LatticeTemplate<Field,2,Algorithms> Reciprocal(const LatticeTemplate<Field,2,Algorithms>& givenLattice)$/;"	f	namespace:psimag
Reciprocal	PartialPsimag/Symmetry/Reciprocal.h	/^  void Reciprocal(const Lattice<Field,1,Algorithms>& givenLattice, $/;"	f	namespace:psimag
Reciprocal	PartialPsimag/Symmetry/Reciprocal.h	/^  void Reciprocal(const Lattice<Field,3,Algorithms>& givenLattice, $/;"	f	namespace:psimag
Reciprocal	PartialPsimag/Symmetry/Reciprocal.h	/^  void Reciprocal(const LatticeTemplate1<Field,2,Algorithms>& givenLattice, $/;"	f	namespace:psimag
ReciprocalLattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    ReciprocalLattice(LatticeType& lat): lattice(lat) {}$/;"	f	class:psimag::ReciprocalLattice
ReciprocalLattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    ReciprocalLattice(const LatticeType& lat): lattice(lat) {}$/;"	f	class:psimag::ReciprocalLattice
ReciprocalLattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^  class ReciprocalLattice {};$/;"	c	namespace:psimag
ReciprocalLattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^  class ReciprocalLattice<Field,1,LatticeTemplate,Algorithms>$/;"	c	namespace:psimag
ReciprocalLattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^  class ReciprocalLattice<Field,2,LatticeTemplate,Algorithms>$/;"	c	namespace:psimag
ReciprocalLattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^  class ReciprocalLattice<Field,3,LatticeTemplate,Algorithms>$/;"	c	namespace:psimag
ReciprocalLatticeType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef ReciprocalLattice<Field,DIM,Lattice,Algorithms>               ReciprocalLatticeType;$/;"	t	class:psimag::SuperCrystal
RecordChar	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordChar,    \/* RecordChar               *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
RecordFalse	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordFalse,   \/* RecordFalse            *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
RecordFloat	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordFloat,   \/* RecordFloat            *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
RecordInteger	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordInteger, \/* RecordInteger            *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
RecordKey	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordKey,     \/* RecordKey                *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
RecordNull	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordNull,    \/* RecordNull            *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
RecordString	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordString,  \/* RecordString             *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
RecordTrue	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^      RecordTrue,    \/* RecordTrue            *\/$/;"	e	enum:JsonParser::ActionsMixin::actions
ReducedCrystal	PartialPsimag/Symmetry/ReducedCrystal.h	/^    ReducedCrystal(const CrystalType& crystal):$/;"	f	class:psimag::ReducedCrystal
ReducedCrystal	PartialPsimag/Symmetry/ReducedCrystal.h	/^  class ReducedCrystal: $/;"	c	namespace:psimag
ReducedCrystalType	PartialPsimag/Symmetry/ConventionalCrystal.h	/^    typedef ReducedCrystal<Field,DIM,Occupant,Algorithms>                  ReducedCrystalType;$/;"	t	class:psimag::ConventionalCrystal
ReducedCrystalType	PartialPsimag/Symmetry/Crystal.h	/^    typedef ReducedCrystal     <Field,DIM,Occupant,            Algorithms> ReducedCrystalType;$/;"	t	class:psimag::Crystal
ReducedCrystalType	PartialPsimag/Symmetry/Simple2DReducer.h	/^    typedef ReducedCrystal<Field,DIM,Occupant,Algorithms>  ReducedCrystalType;$/;"	t	class:psimag::Simple2DReducer
ReducedLattice	PartialPsimag/Symmetry/ReducedLattice.h	/^    ReducedLattice():$/;"	f	class:psimag::ReducedLattice
ReducedLattice	PartialPsimag/Symmetry/ReducedLattice.h	/^    ReducedLattice(const LatticeType& origionalLattice):$/;"	f	class:psimag::ReducedLattice
ReducedLattice	PartialPsimag/Symmetry/ReducedLattice.h	/^  class ReducedLattice: $/;"	c	namespace:psimag
ReducedLatticeType	PartialPsimag/Symmetry/ConventionalLattice.h	/^    typedef ReducedLattice<Field,DIM,Algorithms>       ReducedLatticeType;$/;"	t	class:psimag::ConventionalLattice
ReducedLatticeType	PartialPsimag/Symmetry/Crystal.h	/^    typedef ReducedLattice     <Field,DIM,                     Algorithms> ReducedLatticeType;$/;"	t	class:psimag::Crystal
ReducedLatticeWithPatternType	PartialPsimag/Symmetry/Crystal.h	/^    typedef LatticeWithPattern <Field,DIM,Occupant,ReducedLatticeType,Algorithms> ReducedLatticeWithPatternType;$/;"	t	class:psimag::Crystal
ReducedSymmetryType	PartialPsimag/Symmetry/Crystal.h	/^    typedef Symmetry<Field,DIM,Occupant,ReducedLattice,Algorithms>         ReducedSymmetryType;  $/;"	t	class:psimag::Crystal
Reducer	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  typedef Simple2DReducer<double,Occupant,BasicCrystalAlgorithms>  Reducer;       \/\/ Occupant should be a template arg? &*&*&*&*$/;"	t	class:psimag::BasicCrystalAlgorithms
Reducer	PartialPsimag/Symmetry/Reducer.h	/^  class Reducer {$/;"	c	namespace:psimag
RefType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef Type&        RefType;$/;"	t	class:psimag::ColMajorTraits
RefType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef Type&        RefType;$/;"	t	class:psimag::ConstantTraits
RefType	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef Type&        RefType;$/;"	t	class:psimag::RowMajorTraits
Result	PartialPsimag/Symmetry/SeitzVector.h	/^    template<typename T> class TypeComputer {public: typedef T Result[DIM]; };$/;"	t	class:psimag::SeitzVector::TypeComputer
Result	PartialPsimag/Symmetry/TypeManip.h	/^        typedef T Result;$/;"	t	struct:psimag::Select
Result	PartialPsimag/Symmetry/TypeManip.h	/^        typedef U Result;$/;"	t	struct:psimag::Select
ResultType	PartialPsimag/Symmetry/Mat/MatDifference.h	/^      typedef typename TraitsResult::ElType ResultType;$/;"	t	class:psimag::DIFFERENCE::DifferenceFunctionType
ResultType	PartialPsimag/Symmetry/Mat/MatSum.h	/^      typedef typename TraitsResult::ElType ResultType;$/;"	t	class:psimag::SUM::SumFunctionType
ReturnType	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    typedef typename Functor::T                     ReturnType;$/;"	t	class:psimag::FOREACH_DIAG_
ReturnType	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^    typedef typename Functor::T ReturnType; $/;"	t	class:psimag::FOREACH_DIAG
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    typedef typename Reducer::T ReturnType; $/;"	t	class:psimag::REDUCE_ELS
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    typedef typename ReducerType::T ReturnType; $/;"	t	class:psimag::REDUCE
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    typedef typename ReducerType::T ReturnType; $/;"	t	class:psimag::REDUCE_
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce.h	/^    typedef typename ReducerType::T ReturnType;$/;"	t	class:psimag::REDUCE_ELS
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename Reducer::T ReturnType; $/;"	t	class:psimag::REDUCE2_ELS
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename ReducerType::T ReturnType; $/;"	t	class:psimag::REDUCE2
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename ReducerType::T ReturnType; $/;"	t	class:psimag::REDUCE2_
ReturnType	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^    typedef typename ReducerType::T ReturnType;$/;"	t	class:psimag::REDUCE2_ELS
ReturnType	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    typedef typename Reducer::T                             ReturnType; $/;"	t	class:psimag::REDUCE_DIAG_
ReturnType	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    typedef typename Reducer::T                     ReturnType;$/;"	t	class:psimag::REDUCE_DIAG_
ReturnType	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^    typedef typename Reducer::T ReturnType; $/;"	t	class:psimag::REDUCE_DIAG
ReverseDoubleIndexTraits	PartialPsimag/Symmetry/Mat/MatTraits.h	/^  class ReverseDoubleIndexTraits$/;"	c	namespace:psimag
RngType	PsimagLite/src/ChebyshevSolver.h	/^		typedef PsimagLite::Random48<RealType> RngType;$/;"	t	class:PsimagLite::ChebyshevSolver
RotArray2D	PartialPsimag/Symmetry/SeitzMatrix.h	/^      typedef IN_TYPE RotArray2D[DIM][DIM];$/;"	t	class:psimag::SeitzMatrix::TypeComputer
RotRetriever	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      class RotRetriever {$/;"	c	class:psimag::SeitzMatrixTraits::REF
RotationClass	PartialPsimag/Symmetry/CellRotation.h	/^    typedef Mat< Field, DIM, DIM > RotationClass;$/;"	t	class:psimag::CellRotation
RotationTraits	PartialPsimag/Symmetry/SeitzMatrix.h	/^    typedef typename RotationType::Traits         RotationTraits;$/;"	t	class:psimag::SeitzMatrix
RotationTraits_	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      typedef typename SeitzMatrixType::RotationTraits    RotationTraits_;$/;"	t	class:psimag::SeitzMatrixTraits::REF
RotationType	PartialPsimag/Symmetry/CellRotation.h	/^		   twofold=2, threefold=3,  fourfold=4, sixfold=6 } RotationType;$/;"	t	class:psimag::CellRotation	typeref:enum:psimag::CellRotation::__anon62
RotationType	PartialPsimag/Symmetry/SeitzMatrix.h	/^    typedef RotationType_                         RotationType;$/;"	t	class:psimag::SeitzMatrix
RotationType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef typename MatType::RotationType          RotationType;$/;"	t	class:psimag::SymmetryOperation
RotationType_	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      typedef typename SeitzMatrixType::RotationType      RotationType_;$/;"	t	class:psimag::SeitzMatrixTraits::REF
RowMajorTraits	PartialPsimag/Symmetry/Mat/MatTraits.h	/^  class RowMajorTraits$/;"	c	namespace:psimag
RowSlice	PartialPsimag/MatrixSlice.h	/^    RowSlice(MatrixLikeType& m, size_t rowIndex):$/;"	f	class:psimag::RowSlice
RowSlice	PartialPsimag/MatrixSlice.h	/^  class RowSlice {$/;"	c	namespace:psimag
Rusage	PsimagLite/src/Rusage.h	/^		Rusage(int who = RUSAGE_SELF) : who_(who)$/;"	f	class:PsimagLite::Rusage
Rusage	PsimagLite/src/Rusage.h	/^	class Rusage {$/;"	c	namespace:PsimagLite
SAMPLE_CRSMATRIX_HEADER_H	PsimagLite/src/SampleCRSMatrix.h	/^#define SAMPLE_CRSMATRIX_HEADER_H$/;"	d
SB	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      SB = -17, \/* string begin *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
SBMV	PartialPsimag/BLAS.h	/^inline void SBMV(char uplo,int n,int k,const double &alpha,const double *a,int lda,$/;"	f	namespace:psimag::BLAS
SBMV	PartialPsimag/BLAS.h	/^inline void SBMV(char uplo,int n,int k,const float &alpha,const float *a,int lda,$/;"	f	namespace:psimag::BLAS
SBMV	PsimagLite/src/BLAS.h	/^inline void SBMV(char uplo,int n,int k,const double &alpha,const double *a,int lda,$/;"	f	namespace:psimag::BLAS
SBMV	PsimagLite/src/BLAS.h	/^inline void SBMV(char uplo,int n,int k,const float &alpha,const float *a,int lda,$/;"	f	namespace:psimag::BLAS
SCAL	PartialPsimag/BLAS.h	/^void SCAL(int size,const double &a,double *y,int sy) {$/;"	f	namespace:psimag::BLAS
SCAL	PartialPsimag/BLAS.h	/^void SCAL(int size,const float &a,float* y,int sy) {$/;"	f	namespace:psimag::BLAS
SCAL	PartialPsimag/BLAS.h	/^void SCAL(int size,const std::complex<double> &a,std::complex<double>* y,int sy) {$/;"	f	namespace:psimag::BLAS
SCAL	PartialPsimag/BLAS.h	/^void SCAL(int size,const std::complex<float> &a,std::complex<float>* y,int sy) {$/;"	f	namespace:psimag::BLAS
SCAL	PsimagLite/src/BLAS.h	/^void SCAL(int size,const double &a,double *y,int sy) {$/;"	f	namespace:psimag::BLAS
SCAL	PsimagLite/src/BLAS.h	/^void SCAL(int size,const float &a,float* y,int sy) {$/;"	f	namespace:psimag::BLAS
SCAL	PsimagLite/src/BLAS.h	/^void SCAL(int size,const std::complex<double> &a,std::complex<double>* y,int sy) {$/;"	f	namespace:psimag::BLAS
SCAL	PsimagLite/src/BLAS.h	/^void SCAL(int size,const std::complex<float> &a,std::complex<float>* y,int sy) {$/;"	f	namespace:psimag::BLAS
SE	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      SE = -4,  \/* STRING END *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
SEPBASIS_H	sepBasis.h	/^#define SEPBASIS_H$/;"	d
SHELL	Makefile	/^SHELL    = \/bin\/bash$/;"	m
SHELL	PsimagLite/src/JSON/JsonParser/Makefile	/^SHELL    = \/bin\/bash$/;"	m
SINGLEBAND_H	singleBand.h	/^#define SINGLEBAND_H$/;"	d
SINGLEBAND_WSPIN_H	1band_wSpin.h	/^#define SINGLEBAND_WSPIN_H$/;"	d
SORT_H_H	PsimagLite/src/Sort.h	/^#define SORT_H_H$/;"	d
SPARSE_ROW_H	PsimagLite/src/SparseRow.h	/^#define SPARSE_ROW_H$/;"	d
SPMV	PartialPsimag/BLAS.h	/^inline void SPMV(char uplo,int n,const double &alpha,const double *ap,const double *x,$/;"	f	namespace:psimag::BLAS
SPMV	PartialPsimag/BLAS.h	/^inline void SPMV(char uplo,int n,const float &alpha,const float *ap,const float *x,$/;"	f	namespace:psimag::BLAS
SPMV	PsimagLite/src/BLAS.h	/^inline void SPMV(char uplo,int n,const double &alpha,const double *ap,const double *x,$/;"	f	namespace:psimag::BLAS
SPMV	PsimagLite/src/BLAS.h	/^inline void SPMV(char uplo,int n,const float &alpha,const float *ap,const float *x,$/;"	f	namespace:psimag::BLAS
SPR	PartialPsimag/BLAS.h	/^  inline void SPR(char uplo,int n,const double &alpha,const double *x,int incx,double *ap){$/;"	f	namespace:psimag::BLAS
SPR	PartialPsimag/BLAS.h	/^  inline void SPR(char uplo,int n,const float &alpha,const float *x,int incx,float *ap){$/;"	f	namespace:psimag::BLAS
SPR	PsimagLite/src/BLAS.h	/^  inline void SPR(char uplo,int n,const double &alpha,const double *x,int incx,double *ap){$/;"	f	namespace:psimag::BLAS
SPR	PsimagLite/src/BLAS.h	/^  inline void SPR(char uplo,int n,const float &alpha,const float *x,int incx,float *ap){$/;"	f	namespace:psimag::BLAS
SPR2	PartialPsimag/BLAS.h	/^  inline void SPR2(char uplo,int n,const double &alpha,const double *x,$/;"	f	namespace:psimag::BLAS
SPR2	PartialPsimag/BLAS.h	/^  inline void SPR2(char uplo,int n,const float &alpha,const float *x,$/;"	f	namespace:psimag::BLAS
SPR2	PsimagLite/src/BLAS.h	/^  inline void SPR2(char uplo,int n,const double &alpha,const double *x,$/;"	f	namespace:psimag::BLAS
SPR2	PsimagLite/src/BLAS.h	/^  inline void SPR2(char uplo,int n,const float &alpha,const float *x,$/;"	f	namespace:psimag::BLAS
SQRT10	PartialPsimag/Real.h	/^#define SQRT10 /;"	d
SQRT11	PartialPsimag/Real.h	/^#define SQRT11 /;"	d
SQRT13	PartialPsimag/Real.h	/^#define SQRT13 /;"	d
SQRT17	PartialPsimag/Real.h	/^#define SQRT17 /;"	d
SQRT19	PartialPsimag/Real.h	/^#define SQRT19 /;"	d
SQRT2	PartialPsimag/Real.h	/^#define SQRT2 /;"	d
SQRT2	PartialPsimag/Real.h	/^#undef SQRT2$/;"	d
SQRT3	PartialPsimag/Real.h	/^#define SQRT3 /;"	d
SQRT5	PartialPsimag/Real.h	/^#define SQRT5 /;"	d
SQRT6	PartialPsimag/Real.h	/^#define SQRT6 /;"	d
SQRT7	PartialPsimag/Real.h	/^#define SQRT7 /;"	d
SQRT8	PartialPsimag/Real.h	/^#define SQRT8 /;"	d
SRC_DIR	Makefile	/^SRC_DIR = .\/$/;"	m
SRC_DIR	PsimagLite/src/JSON/JsonParser/Makefile	/^SRC_DIR  = .$/;"	m
SRRUO_H	SrRuO.h	/^#define SRRUO_H$/;"	d
SRRUO_SO_H	SrRuO_SO.h	/^#define SRRUO_SO_H$/;"	d
ST	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      ST,  \/* string   *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
ST	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      ST,  \/* Looking for string characters         *\/$/;"	e	enum:JsonParser::StatesMixin::states
STATIC_CHECK	PartialPsimag/PSIMAGAssert.h	/^#define STATIC_CHECK(/;"	d
STATIC_CHECK	PsimagLite/src/JSON/PSIMAGAssert.h	/^#define STATIC_CHECK(/;"	d
SUBTYPE_X	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {SUBTYPE_X,SUBTYPE_Y};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon129
SUBTYPE_Y	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {SUBTYPE_X,SUBTYPE_Y};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon129
SUM	PartialPsimag/Symmetry/Mat/MatSum.h	/^  class SUM {$/;"	c	namespace:psimag
SUPERSUBCLASS	PartialPsimag/Symmetry/TypeManip.h	/^#define SUPERSUBCLASS(/;"	d
SUPERSUBCLASS_STRICT	PartialPsimag/Symmetry/TypeManip.h	/^#define SUPERSUBCLASS_STRICT(/;"	d
SUSCEPTIBILITY_H	susceptibility.h	/^#define SUSCEPTIBILITY_H$/;"	d
SUSINT_H	susInt.h	/^#define SUSINT_H$/;"	d
SVG	PartialPsimag/XMLHeading.h	/^    typedef enum { XHTML, SVG} DocType;$/;"	e	enum:psimag::XMLHeading::__anon1
SYMM	PartialPsimag/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const double &a,const double* x,$/;"	f	namespace:psimag::BLAS
SYMM	PartialPsimag/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const float &a,const float* x,$/;"	f	namespace:psimag::BLAS
SYMM	PartialPsimag/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const std::complex<double> &a,$/;"	f	namespace:psimag::BLAS
SYMM	PartialPsimag/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const std::complex<float> &a,$/;"	f	namespace:psimag::BLAS
SYMM	PsimagLite/src/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const double &a,const double* x,$/;"	f	namespace:psimag::BLAS
SYMM	PsimagLite/src/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const float &a,const float* x,$/;"	f	namespace:psimag::BLAS
SYMM	PsimagLite/src/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const std::complex<double> &a,$/;"	f	namespace:psimag::BLAS
SYMM	PsimagLite/src/BLAS.h	/^inline void SYMM(char c1,char c2,int sX,int sY,const std::complex<float> &a,$/;"	f	namespace:psimag::BLAS
SYMV	PartialPsimag/BLAS.h	/^inline void SYMV(char uplo,int n,const double &alpha,const double *a,int lda,const double *x,$/;"	f	namespace:psimag::BLAS
SYMV	PartialPsimag/BLAS.h	/^inline void SYMV(char uplo,int n,const float &alpha,const float *a,int lda,const float *x,$/;"	f	namespace:psimag::BLAS
SYMV	PsimagLite/src/BLAS.h	/^inline void SYMV(char uplo,int n,const double &alpha,const double *a,int lda,const double *x,$/;"	f	namespace:psimag::BLAS
SYMV	PsimagLite/src/BLAS.h	/^inline void SYMV(char uplo,int n,const float &alpha,const float *a,int lda,const float *x,$/;"	f	namespace:psimag::BLAS
SYR	PartialPsimag/BLAS.h	/^  inline void SYR(char uplo,int n,const double &alpha,const double *x,int incx,$/;"	f	namespace:psimag::BLAS
SYR	PartialPsimag/BLAS.h	/^  inline void SYR(char uplo,int n,const float &alpha,const float *x,int incx,$/;"	f	namespace:psimag::BLAS
SYR	PsimagLite/src/BLAS.h	/^  inline void SYR(char uplo,int n,const double &alpha,const double *x,int incx,$/;"	f	namespace:psimag::BLAS
SYR	PsimagLite/src/BLAS.h	/^  inline void SYR(char uplo,int n,const float &alpha,const float *x,int incx,$/;"	f	namespace:psimag::BLAS
SYR2	PartialPsimag/BLAS.h	/^  inline void SYR2(char uplo,int n,const double &alpha,const double *x,$/;"	f	namespace:psimag::BLAS
SYR2	PartialPsimag/BLAS.h	/^  inline void SYR2(char uplo,int n,const float &alpha,const float *x,$/;"	f	namespace:psimag::BLAS
SYR2	PsimagLite/src/BLAS.h	/^  inline void SYR2(char uplo,int n,const double &alpha,const double *x,$/;"	f	namespace:psimag::BLAS
SYR2	PsimagLite/src/BLAS.h	/^  inline void SYR2(char uplo,int n,const float &alpha,const float *x,$/;"	f	namespace:psimag::BLAS
SYR2K	PartialPsimag/BLAS.h	/^inline void SYR2K(char uplo,char trans,int n, int k,const float &alpha,$/;"	f	namespace:psimag::BLAS
SYR2K	PartialPsimag/BLAS.h	/^inline void SYR2K(char uplo,char trans,int n,int k,const double &alpha,$/;"	f	namespace:psimag::BLAS
SYR2K	PsimagLite/src/BLAS.h	/^inline void SYR2K(char uplo,char trans,int n, int k,const float &alpha,$/;"	f	namespace:psimag::BLAS
SYR2K	PsimagLite/src/BLAS.h	/^inline void SYR2K(char uplo,char trans,int n,int k,const double &alpha,$/;"	f	namespace:psimag::BLAS
SYR2k	PartialPsimag/BLAS.h	/^inline void SYR2k(char uplo,char trans,int n,int k,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
SYR2k	PartialPsimag/BLAS.h	/^inline void SYR2k(char uplo,char trans,int n,int k,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
SYR2k	PsimagLite/src/BLAS.h	/^inline void SYR2k(char uplo,char trans,int n,int k,const std::complex<double> &alpha,$/;"	f	namespace:psimag::BLAS
SYR2k	PsimagLite/src/BLAS.h	/^inline void SYR2k(char uplo,char trans,int n,int k,const std::complex<float> &alpha,$/;"	f	namespace:psimag::BLAS
SYRK	PartialPsimag/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const double &ALPHA,$/;"	f	namespace:psimag::BLAS
SYRK	PartialPsimag/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const float &ALPHA,$/;"	f	namespace:psimag::BLAS
SYRK	PartialPsimag/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const std::complex<double> &ALPHA,$/;"	f	namespace:psimag::BLAS
SYRK	PartialPsimag/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const std::complex<float> &ALPHA,$/;"	f	namespace:psimag::BLAS
SYRK	PsimagLite/src/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const double &ALPHA,$/;"	f	namespace:psimag::BLAS
SYRK	PsimagLite/src/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const float &ALPHA,$/;"	f	namespace:psimag::BLAS
SYRK	PsimagLite/src/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const std::complex<double> &ALPHA,$/;"	f	namespace:psimag::BLAS
SYRK	PsimagLite/src/BLAS.h	/^inline void SYRK(char UPLO,char TRANS,int N,int K,const std::complex<float> &ALPHA,$/;"	f	namespace:psimag::BLAS
SYSTEM_TIME	PsimagLite/src/Rusage.h	/^		enum {USER_TIME,SYSTEM_TIME};$/;"	e	enum:PsimagLite::Rusage::__anon132
SameKeys	PartialPsimag/Symmetry/STLUtil.h	/^bool SameKeys(const std::map<K,T,C,A>& obj1, const std::map<K,T,C,A>& obj2)$/;"	f
SampleCRSMatrix	PsimagLite/src/SampleCRSMatrix.h	/^		SampleCRSMatrix(SomeIoInputType& io)$/;"	f	class:PsimagLite::SampleCRSMatrix
SampleCRSMatrix	PsimagLite/src/SampleCRSMatrix.h	/^		SampleCRSMatrix(size_t rank) : rank_(rank),rowptr_(rank+1)$/;"	f	class:PsimagLite::SampleCRSMatrix
SampleCRSMatrix	PsimagLite/src/SampleCRSMatrix.h	/^		SampleCRSMatrix(size_t rank,T seed,size_t nonZeros,T maxValue) : rank_(rank),rowptr_(rank+1)$/;"	f	class:PsimagLite::SampleCRSMatrix
SampleCRSMatrix	PsimagLite/src/SampleCRSMatrix.h	/^	class SampleCRSMatrix {$/;"	c	namespace:PsimagLite
SearchTable	PartialPsimag/Symmetry/SearchTable.h	/^  class SearchTable {};$/;"	c	namespace:psimag
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix() : $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const Field& a): $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const IN_TYPE data [(DIM-1)*(DIM-1)], IN_TYPE tdata [DIM-1]) : $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const IN_TYPE data [DIM-1*DIM-1] ): $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const IN_TYPE* data, const IN_TYPE* tdata) : $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const MatType<IN_TYPE, DIM>& m,$/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const RotationType&    m) : $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const RotationType&    m,$/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const SeitzVector<Field,DIM,0>& t) : $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const ThisType& other) : $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix(const TranslationType& t) : $/;"	f	class:psimag::SeitzMatrix
SeitzMatrix	PartialPsimag/Symmetry/SeitzMatrix.h	/^  class SeitzMatrix$/;"	c	namespace:psimag
SeitzMatrixTraits	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^  class SeitzMatrixTraits$/;"	c	namespace:psimag
SeitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^    SeitzPosition(): BaseType() {}$/;"	f	class:psimag::SeitzPosition
SeitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^    SeitzPosition(const ArrayType& vals):  BaseType(vals) {}$/;"	f	class:psimag::SeitzPosition
SeitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^    SeitzPosition(const BaseType& v): BaseType(v) {}$/;"	f	class:psimag::SeitzPosition
SeitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^    SeitzPosition(const Field& val): BaseType(val) {}$/;"	f	class:psimag::SeitzPosition
SeitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^    SeitzPosition(const SeitzPosition<Field, DIM>& v): BaseType(v) {}$/;"	f	class:psimag::SeitzPosition
SeitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^    SeitzPosition(const Vec<Field, DIM>& v):  BaseType(v) {}$/;"	f	class:psimag::SeitzPosition
SeitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^  class SeitzPosition: public SeitzVector< Field, DIM, 1 > $/;"	c	namespace:psimag
SeitzPositionType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef SeitzPosition<Field,DIM>                SeitzPositionType;$/;"	t	class:psimag::SymmetryOperation
SeitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^    SeitzTranslation(): SeitzVector< Field, DIM > ()  {}$/;"	f	class:psimag::SeitzTranslation
SeitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^    SeitzTranslation(IN_TYPE val): SeitzVector<Field, DIM>(val) {}$/;"	f	class:psimag::SeitzTranslation
SeitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^    SeitzTranslation(IN_TYPE vals[DIM]): SeitzVector< Field, DIM > (vals) {}$/;"	f	class:psimag::SeitzTranslation
SeitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^  class SeitzTranslation: public SeitzVector< Field, DIM, 0 > $/;"	c	namespace:psimag
SeitzTranslationType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef SeitzTranslation<Field,DIM>             SeitzTranslationType;$/;"	t	class:psimag::SymmetryOperation
SeitzVector	PartialPsimag/Symmetry/SeitzVector.h	/^    SeitzVector(): BaseType(Field(0)) $/;"	f	class:psimag::SeitzVector
SeitzVector	PartialPsimag/Symmetry/SeitzVector.h	/^    SeitzVector(const ArrayType&  vals) { $/;"	f	class:psimag::SeitzVector
SeitzVector	PartialPsimag/Symmetry/SeitzVector.h	/^    SeitzVector(const Vec<IN_TYPE, DIM+1, VTraits>& val)$/;"	f	class:psimag::SeitzVector
SeitzVector	PartialPsimag/Symmetry/SeitzVector.h	/^    SeitzVector(const Vec<IN_TYPE, DIM, VTraits>& val)$/;"	f	class:psimag::SeitzVector
SeitzVector	PartialPsimag/Symmetry/SeitzVector.h	/^    explicit SeitzVector(const Field& val): BaseType(val) $/;"	f	class:psimag::SeitzVector
SeitzVector	PartialPsimag/Symmetry/SeitzVector.h	/^    explicit SeitzVector(const SeitzVector<IN_TYPE, DIM, otherIND, OtherTraits>& val)$/;"	f	class:psimag::SeitzVector
SeitzVector	PartialPsimag/Symmetry/SeitzVector.h	/^  class SeitzVector: protected Vec< Field, DIM+1, TRAITS > {$/;"	c	namespace:psimag
Select	PartialPsimag/Symmetry/TypeManip.h	/^    struct Select$/;"	s	namespace:psimag
Select	PartialPsimag/Symmetry/TypeManip.h	/^    struct Select<false, T, U>$/;"	s	namespace:psimag
Simple2DReducer	PartialPsimag/Symmetry/Simple2DReducer.h	/^  class Simple2DReducer  $/;"	c	namespace:psimag
SingleBand_wSpin	1band_wSpin.h	/^		SingleBand_wSpin(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::SingleBand_wSpin
SingleBand_wSpin	1band_wSpin.h	/^	class SingleBand_wSpin {$/;"	c	namespace:rpa
SixFold	PartialPsimag/Symmetry/SixFold2D.h	/^    SixFold():$/;"	f	class:psimag::SixFold
SixFold	PartialPsimag/Symmetry/SixFold2D.h	/^    SixFold(IN_TYPE p1, IN_TYPE p2):$/;"	f	class:psimag::SixFold
SixFold	PartialPsimag/Symmetry/SixFold2D.h	/^    SixFold(const CellTranslationType&    offset):$/;"	f	class:psimag::SixFold
SixFold	PartialPsimag/Symmetry/SixFold2D.h	/^  class SixFold<Field,2,Algorithms>: $/;"	c	namespace:psimag
SixFold	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class SixFold   {};$/;"	c	namespace:psimag
SixFoldN	PartialPsimag/Symmetry/SixFoldN2D.h	/^    SixFoldN():$/;"	f	class:psimag::SixFoldN
SixFoldN	PartialPsimag/Symmetry/SixFoldN2D.h	/^    SixFoldN(IN_TYPE p1, IN_TYPE p2):$/;"	f	class:psimag::SixFoldN
SixFoldN	PartialPsimag/Symmetry/SixFoldN2D.h	/^    SixFoldN(const CellTranslationType&    offset):$/;"	f	class:psimag::SixFoldN
SixFoldN	PartialPsimag/Symmetry/SixFoldN2D.h	/^  class SixFoldN<Field,2,Algorithms>: $/;"	c	namespace:psimag
SixFoldN	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class SixFoldN  {};$/;"	c	namespace:psimag
SixFoldNType	PartialPsimag/Symmetry/SixFoldN2D.h	/^    typedef SixFoldN<Field,DIM,Algorithms>            SixFoldNType;$/;"	t	class:psimag::SixFoldN
SixFoldNType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef SixFoldN<Field,DIM,Algorithms>                                 SixFoldNType;$/;"	t	class:psimag::SymmetryElements
SixFoldType	PartialPsimag/Symmetry/SixFold2D.h	/^    typedef SixFold<Field,DIM,Algorithms>             SixFoldType;$/;"	t	class:psimag::SixFold
SixFoldType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef SixFold<Field,DIM,Algorithms>                                  SixFoldType;$/;"	t	class:psimag::SymmetryElements
Small	PartialPsimag/Symmetry/TypeManip.h	/^            typedef char Small;$/;"	t	struct:psimag::TypeManip_Private::ConversionHelper
Solve	PartialPsimag/Symmetry/Mat/MatUtil.h	/^void Solve(const Mat<T,2,2>& m,$/;"	f	namespace:psimag
Solve	PartialPsimag/Symmetry/Mat/MatUtil.h	/^void Solve(const Mat<T,3,3>& m,$/;"	f	namespace:psimag
Solve	PartialPsimag/Symmetry/Mat/MatUtil.h	/^void Solve(const Mat<T,NROW,NCOL>& a, $/;"	f	namespace:psimag
Sort	PsimagLite/src/Sort.h	/^class Sort {$/;"	c
SpaceGroup	PartialPsimag/Symmetry/SpaceGroup.h	/^  class SpaceGroup$/;"	c	namespace:psimag
SpaceGroup	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    SpaceGroup():$/;"	f	class:psimag::SpaceGroup
SpaceGroup	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    SpaceGroup(const SpaceGroupType& sg):$/;"	f	class:psimag::SpaceGroup
SpaceGroup	PartialPsimag/Symmetry/SpaceGroup2D.h	/^  class SpaceGroup<Field,2,Occupant,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupConstructor	PartialPsimag/Symmetry/SpaceGroupConstructor.h	/^  class SpaceGroupConstructor  $/;"	c	namespace:psimag
SpaceGroupConstructor	PartialPsimag/Symmetry/SpaceGroupConstructor2D.h	/^  class SpaceGroupConstructor<Field,2>  {$/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData$/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,1,1,Algorithms>$/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,10,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,11,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,12,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,13,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,14,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,15,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,16,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,17,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,2,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,3,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,4,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,5,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,6,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,7,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,8,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupData	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^  class SpaceGroupData<Field,2,9,1,Algorithms>   $/;"	c	namespace:psimag
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=1, NumGenerators=1, NumOperations=1};$/;"	e	enum:psimag::SpaceGroupData::__anon82
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=10, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon91
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=11, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon92
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=12, NumGenerators=4, NumOperations=8};$/;"	e	enum:psimag::SpaceGroupData::__anon93
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=13 , NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon94
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=14 , NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon95
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=15, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon96
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=16, NumGenerators=3, NumOperations=6};$/;"	e	enum:psimag::SpaceGroupData::__anon97
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=17, NumGenerators=4, NumOperations=12};$/;"	e	enum:psimag::SpaceGroupData::__anon98
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=2, NumGenerators=2, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon83
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=3, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon84
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=4, NumGenerators=2, NumOperations=3};$/;"	e	enum:psimag::SpaceGroupData::__anon85
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=6, NumGenerators=3, NumOperations=8 };$/;"	e	enum:psimag::SpaceGroupData::__anon87
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=7 , NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon88
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=false, SpaceGroupNumber=8, NumGenerators=3, NumOperations=4};$/;"	e	enum:psimag::SpaceGroupData::__anon89
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=5, NumGenerators=3, NumOperations=5};$/;"	e	enum:psimag::SpaceGroupData::__anon86
SpaceGroupNumber	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    enum { DIM=2, Centered=true, SpaceGroupNumber=9 , NumGenerators=4, NumOperations=11};$/;"	e	enum:psimag::SpaceGroupData::__anon90
SpaceGroupType	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    typedef SpaceGroup<Field,DIM,Occupant, Algorithms>                        SpaceGroupType;$/;"	t	class:psimag::AppliedSymmetryElementIterator
SpaceGroupType	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    typedef SpaceGroup<Field,2,Occupant, Algorithms>                          SpaceGroupType;$/;"	t	class:psimag::SpaceGroup
SpaceGroupType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef SpaceGroup<Field,DIM,Occupant,Algorithms>                     SpaceGroupType;$/;"	t	class:psimag::Symmetry
SpaceGroupVectorType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef std::vector<SpaceGroupType>                                   SpaceGroupVectorType;$/;"	t	class:psimag::Symmetry
SparseRow	PsimagLite/src/SparseRow.h	/^	class SparseRow {$/;"	c	namespace:PsimagLite
Spf	PsimagLite/src/IoSimple.h	/^namespace Spf {$/;"	n
SrRuO	SrRuO.h	/^		SrRuO(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::SrRuO
SrRuO	SrRuO.h	/^	class SrRuO {$/;"	c	namespace:rpa
Star	PartialPsimag/Symmetry/Star.h	/^    Star():$/;"	f	class:psimag::Star
Star	PartialPsimag/Symmetry/Star.h	/^  class Star$/;"	c	namespace:psimag
StarType	PartialPsimag/Symmetry/Star.h	/^    typedef Star<Field,DIM,Occupant,LatticeTemplate,Algorithms>           StarType;$/;"	t	class:psimag::Star
StateTranslationTable	PsimagLite/src/JSON/JsonParser/StateTranslationTable.h	/^  class StateTranslationTable: $/;"	c	namespace:JsonParser
StateType	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^    } StateType;$/;"	t	class:JsonParser::StatesMixin	typeref:enum:JsonParser::StatesMixin::states
StatesAndActionsMixin	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^  class StatesAndActionsMixin {$/;"	c	namespace:JsonParser
StatesAndActionsType	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^    } StatesAndActionsType;$/;"	t	class:JsonParser::StatesAndActionsMixin	typeref:enum:JsonParser::StatesAndActionsMixin::statesAndActions
StatesMixin	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^  class StatesMixin {$/;"	c	namespace:JsonParser
String	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void String(ParseBuffer& s) {$/;"	f	class:JsonParser::DefaultContext
SubLatticeVecCoordType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef LatticeCoordinates<DIM>                                       SubLatticeVecCoordType;$/;"	t	class:psimag::SuperCrystal
SubLatticeVecCoordType	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    typedef LatticeCoordinates<DIM>                    SubLatticeVecCoordType;$/;"	t	class:psimag::SuperCrystalBuilder
SubLatticeVecCoordsType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef std::vector<SubLatticeVecCoordType>                           SubLatticeVecCoordsType;$/;"	t	class:psimag::SuperCrystal
SubLatticeVecCoordsType	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    typedef std::vector<SubLatticeVecCoordType>        SubLatticeVecCoordsType;$/;"	t	class:psimag::SuperCrystalBuilder
SumFunctionType	PartialPsimag/Symmetry/Mat/MatSum.h	/^    class SumFunctionType {$/;"	c	class:psimag::SUM
SuperClass	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef SeitzMatrix< Field, DIM >               SuperClass;   $/;"	t	class:psimag::SymmetryOperation
SuperCrystal	PartialPsimag/Symmetry/SuperCrystal.h	/^    SuperCrystal(SubLatticeVecCoordsType& subLatticeVecCoords, $/;"	f	class:psimag::SuperCrystal
SuperCrystal	PartialPsimag/Symmetry/SuperCrystal.h	/^    SuperCrystal(const CrystalType&       cryst,$/;"	f	class:psimag::SuperCrystal
SuperCrystal	PartialPsimag/Symmetry/SuperCrystal.h	/^  class SuperCrystal: $/;"	c	namespace:psimag
SuperCrystalBuilder	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    SuperCrystalBuilder(int n0, int m0, int n1, int m1):$/;"	f	class:psimag::SuperCrystalBuilder
SuperCrystalBuilder	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    SuperCrystalBuilder(int n0, int m0, int n1, int m1, PatternDataType patternData):$/;"	f	class:psimag::SuperCrystalBuilder
SuperCrystalBuilder	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^  class SuperCrystalBuilder {};$/;"	c	namespace:psimag
SuperCrystalBuilder	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^  class SuperCrystalBuilder<Field,2,Occupant,Algorithms> {$/;"	c	namespace:psimag
SuperType	PartialPsimag/Tag.h	/^      typedef std::vector<Tag> SuperType;$/;"	t	class:psimag::Tag::Elements
Symmetry	PartialPsimag/Symmetry/Symmetry.h	/^    Symmetry(const LatticeWithPatternType& latPatt):$/;"	f	class:psimag::Symmetry
Symmetry	PartialPsimag/Symmetry/Symmetry.h	/^  class Symmetry$/;"	c	namespace:psimag
SymmetryElement	PartialPsimag/Symmetry/SymmetryElement.h	/^    SymmetryElement(): $/;"	f	class:psimag::SymmetryElement
SymmetryElement	PartialPsimag/Symmetry/SymmetryElement.h	/^    SymmetryElement(const SymmetryElementType& other): $/;"	f	class:psimag::SymmetryElement
SymmetryElement	PartialPsimag/Symmetry/SymmetryElement.h	/^    SymmetryElement(std::string                   elType,$/;"	f	class:psimag::SymmetryElement
SymmetryElement	PartialPsimag/Symmetry/SymmetryElement.h	/^  class SymmetryElement {$/;"	c	namespace:psimag
SymmetryElementName	PartialPsimag/Symmetry/SymmetryElementName.h	/^    SymmetryElementName(const SymmetryElement<Field,2,Algorithms>& element):$/;"	f	class:psimag::SymmetryElementName
SymmetryElementName	PartialPsimag/Symmetry/SymmetryElementName.h	/^    SymmetryElementName(const ThisType& name):$/;"	f	class:psimag::SymmetryElementName
SymmetryElementName	PartialPsimag/Symmetry/SymmetryElementName.h	/^    SymmetryElementName(const char*& name):$/;"	f	class:psimag::SymmetryElementName
SymmetryElementName	PartialPsimag/Symmetry/SymmetryElementName.h	/^    SymmetryElementName(const std::string& name):$/;"	f	class:psimag::SymmetryElementName
SymmetryElementName	PartialPsimag/Symmetry/SymmetryElementName.h	/^  class SymmetryElementName: $/;"	c	namespace:psimag
SymmetryElementName	PartialPsimag/Symmetry/SymmetryElementName.h	/^  class SymmetryElementName<2>: $/;"	c	namespace:psimag
SymmetryElementType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                  SymmetryElementType;$/;"	t	class:psimag::AppliedSymmetryElement
SymmetryElementType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                  SymmetryElementType;$/;"	t	class:psimag::AppliedSymmetryElement
SymmetryElementType	PartialPsimag/Symmetry/FourFold2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::FourFold
SymmetryElementType	PartialPsimag/Symmetry/FourFoldN2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::FourFoldN
SymmetryElementType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                 SymmetryElementType;$/;"	t	class:psimag::Glide
SymmetryElementType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                             SymmetryElementType;$/;"	t	class:psimag::GroupAction
SymmetryElementType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                                   SymmetryElementType;$/;"	t	class:psimag::GroupMultiplicationTable
SymmetryElementType	PartialPsimag/Symmetry/IdentityElement2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::IdentityElement
SymmetryElementType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>              SymmetryElementType;$/;"	t	class:psimag::Mirror
SymmetryElementType	PartialPsimag/Symmetry/SixFold2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::SixFold
SymmetryElementType	PartialPsimag/Symmetry/SixFoldN2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::SixFoldN
SymmetryElementType	PartialPsimag/Symmetry/Star.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                             SymmetryElementType;$/;"	t	class:psimag::Star
SymmetryElementType	PartialPsimag/Symmetry/SymmetryElement.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>   SymmetryElementType;$/;"	t	class:psimag::SymmetryElement
SymmetryElementType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                          SymmetryElementType;$/;"	t	class:psimag::SymmetryElements
SymmetryElementType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>                             SymmetryElementType;$/;"	t	class:psimag::SymmetryGroup
SymmetryElementType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>   SymmetryElementType;$/;"	t	class:psimag::SymmetryOperation
SymmetryElementType	PartialPsimag/Symmetry/ThreeFold2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::ThreeFold
SymmetryElementType	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::ThreeFoldN
SymmetryElementType	PartialPsimag/Symmetry/TwoFold2D.h	/^    typedef SymmetryElement<Field,DIM,Algorithms>     SymmetryElementType;$/;"	t	class:psimag::TwoFold
SymmetryElements	PartialPsimag/Symmetry/SymmetryElements2D.h	/^  class SymmetryElements {};$/;"	c	namespace:psimag
SymmetryElements	PartialPsimag/Symmetry/SymmetryElements2D.h	/^  class SymmetryElements<Field,2,Algorithms> {$/;"	c	namespace:psimag
SymmetryElementsType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef SymmetryElements<Field,DIM,Algorithms>                 SymmetryElementsType;$/;"	t	class:psimag::AppliedSymmetryElement
SymmetryElementsType	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    typedef SymmetryElements<Field,DIM,Algorithms>                            SymmetryElementsType;  $/;"	t	class:psimag::SpaceGroup
SymmetryElementsType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef SymmetryElements <Field,DIM,Algorithms>    SymmetryElementsType; $/;"	t	class:psimag::SpaceGroupData
SymmetryElementsType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef SymmetryElements<Field,DIM,Algorithms>   SymmetryElementsType; $/;"	t	class:psimag::SpaceGroupData
SymmetryElementsType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef SymmetryElements<Field,DIM,Algorithms> SymmetryElementsType; $/;"	t	class:psimag::SpaceGroupData
SymmetryElementsType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef SymmetryElements<Field,DIM,Algorithms> SymmetryElementsType;$/;"	t	class:psimag::SpaceGroupData
SymmetryElementsType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef SymmetryElements<Field,DIM,Algorithms>                        SymmetryElementsType;$/;"	t	class:psimag::Symmetry
SymmetryGroup	PartialPsimag/Symmetry/SymmetryGroup.h	/^    SymmetryGroup(const LatticeWithPatternType&  lpat):$/;"	f	class:psimag::SymmetryGroup
SymmetryGroup	PartialPsimag/Symmetry/SymmetryGroup.h	/^  class SymmetryGroup$/;"	c	namespace:psimag
SymmetryGroupType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef SymmetryGroup<Field,DIM,Occupant,LatticeTemplate,Algorithms>  SymmetryGroupType;$/;"	t	class:psimag::Symmetry
SymmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SymmetryOperation(): $/;"	f	class:psimag::SymmetryOperation
SymmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SymmetryOperation(const IN_TYPE data [DIM*DIM]) : $/;"	f	class:psimag::SymmetryOperation
SymmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SymmetryOperation(const IN_TYPE data [DIM*DIM], const IN_TYPE tdata [DIM]) : $/;"	f	class:psimag::SymmetryOperation
SymmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SymmetryOperation(const SeitzVector<IN_TYPE,DIM,0>& t): $/;"	f	class:psimag::SymmetryOperation
SymmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SymmetryOperation(const SymmetryOperationType& other): $/;"	f	class:psimag::SymmetryOperation
SymmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^  class SymmetryOperation: public SeitzMatrix< Field, DIM > {$/;"	c	namespace:psimag
SymmetryOperationType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                SymmetryOperationType;$/;"	t	class:psimag::AppliedSymmetryElement
SymmetryOperationType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                SymmetryOperationType;$/;"	t	class:psimag::AppliedSymmetryElement
SymmetryOperationType	PartialPsimag/Symmetry/Crystal.h	/^    typedef SymmetryOperation  <Field,DIM,Algorithms>                      SymmetryOperationType;$/;"	t	class:psimag::Crystal
SymmetryOperationType	PartialPsimag/Symmetry/FourFold2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::FourFold
SymmetryOperationType	PartialPsimag/Symmetry/FourFoldN2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::FourFoldN
SymmetryOperationType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>               SymmetryOperationType;$/;"	t	class:psimag::Glide
SymmetryOperationType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                           SymmetryOperationType;$/;"	t	class:psimag::GroupAction
SymmetryOperationType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                                 SymmetryOperationType;$/;"	t	class:psimag::GroupMultiplicationTable
SymmetryOperationType	PartialPsimag/Symmetry/IdentityElement2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::IdentityElement
SymmetryOperationType	PartialPsimag/Symmetry/Lattice.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>       SymmetryOperationType;$/;"	t	class:psimag::Lattice
SymmetryOperationType	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                       SymmetryOperationType;$/;"	t	class:psimag::LatticeWithPattern
SymmetryOperationType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>            SymmetryOperationType;$/;"	t	class:psimag::Mirror
SymmetryOperationType	PartialPsimag/Symmetry/OriginLocator.h	/^    typedef SymmetryOperation<Field,DIM>                  SymmetryOperationType;$/;"	t	class:psimag::OriginLocator
SymmetryOperationType	PartialPsimag/Symmetry/PatternWithLattice.h	/^    typedef SymmetryOperation<Field,DIM>                           SymmetryOperationType;$/;"	t	class:psimag::PatternWithLattice
SymmetryOperationType	PartialPsimag/Symmetry/SixFold2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::SixFold
SymmetryOperationType	PartialPsimag/Symmetry/SixFoldN2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::SixFoldN
SymmetryOperationType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>    SymmetryOperationType;$/;"	t	class:psimag::SpaceGroupData
SymmetryOperationType	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>  SymmetryOperationType;$/;"	t	class:psimag::SpaceGroupData
SymmetryOperationType	PartialPsimag/Symmetry/Star.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                           SymmetryOperationType;$/;"	t	class:psimag::Star
SymmetryOperationType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                       SymmetryOperationType;$/;"	t	class:psimag::Symmetry
SymmetryOperationType	PartialPsimag/Symmetry/SymmetryElement.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms> SymmetryOperationType;$/;"	t	class:psimag::SymmetryElement
SymmetryOperationType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                        SymmetryOperationType;$/;"	t	class:psimag::SymmetryElements
SymmetryOperationType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                           SymmetryOperationType;$/;"	t	class:psimag::SymmetryGroup
SymmetryOperationType	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms> SymmetryOperationType;$/;"	t	class:psimag::SymmetryOperation
SymmetryOperationType	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    typedef SymmetryOperation<Field,2,Algorithms>                          SymmetryOperationType;$/;"	t	class:psimag::SymmetryOperations
SymmetryOperationType	PartialPsimag/Symmetry/TestPattern.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>                             SymmetryOperationType;$/;"	t	class:psimag::TestPattern
SymmetryOperationType	PartialPsimag/Symmetry/ThreeFold2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::ThreeFold
SymmetryOperationType	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::ThreeFoldN
SymmetryOperationType	PartialPsimag/Symmetry/TwoFold2D.h	/^    typedef SymmetryOperation<Field,DIM,Algorithms>   SymmetryOperationType;$/;"	t	class:psimag::TwoFold
SymmetryOperations	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^  class SymmetryOperations {};$/;"	c	namespace:psimag
SymmetryOperations	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^  class SymmetryOperations<Field,2,Algorithms> {$/;"	c	namespace:psimag
SymmetryType	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    typedef Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>           SymmetryType;$/;"	t	class:psimag::AppliedSymmetryElementIterator
SymmetryType	PartialPsimag/Symmetry/Crystal.h	/^    typedef Symmetry<Field,DIM,Occupant,Lattice,Algorithms>                SymmetryType;  $/;"	t	class:psimag::Crystal
SymmetryType	PartialPsimag/Symmetry/CrystalBase.h	/^    typedef Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>       SymmetryType;$/;"	t	class:psimag::CrystalBase
SymmetryType	PartialPsimag/Symmetry/Star.h	/^    typedef Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>       SymmetryType;$/;"	t	class:psimag::Star
SymmetryType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>       SymmetryType;$/;"	t	class:psimag::Symmetry
SymmetryType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>           SymmetryType;$/;"	t	class:psimag::SymmetryGroup
T	PartialPsimag/MatrixLike.h	/^      typedef typename MatrixLikeType::value_type T;$/;"	t	class:psimag::MatrixLike::INVERT
T	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    TransformType T;$/;"	m	class:psimag::HermiteNormalForm
T	PartialPsimag/Symmetry/Mat/MatDet.h	/^    typedef typename MT::ElType   T;$/;"	t	class:psimag::DET
T	PartialPsimag/Symmetry/Mat/MatDet.h	/^    typedef typename Traits::ElType T;$/;"	t	class:psimag::DET
T	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef bool T;$/;"	t	class:psimag::CLOSE::CloseReducerType
T	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef bool T;$/;"	t	class:psimag::EQUAL::EqualReducerType
T	PartialPsimag/Symmetry/Mat/MatEqual.h	/^      typedef bool T;$/;"	t	class:psimag::EQUAL_VAL::EqualReducerType
T	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^      typedef typename Traits::ElType  T;$/;"	t	class:psimag::MakeIDENTITY::IdentityReducerType
T	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^    typedef typename Traits::ElType  T;$/;"	t	class:psimag::MakeIDENTITY
T	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      typedef typename Traits::ElType  T;$/;"	t	class:psimag::L2NORM::MagnitudeReducerType
T	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^      typedef typename Traits::ElType  T;$/;"	t	class:psimag::MAGNITUDE::MagnitudeReducerType
T	PartialPsimag/Symmetry/Mat/MatMax.h	/^      typedef typename Traits::ElType  T;$/;"	t	class:psimag::MAX::MaxReducerType
T	PartialPsimag/Symmetry/Mat/MatMax.h	/^    typedef typename Traits::ElType  T;$/;"	t	class:psimag::MAX
T	PartialPsimag/Symmetry/Mat/MatMult.h	/^    typedef typename Traits::ElType  T;$/;"	t	class:psimag::MatMultVecRow
T	PartialPsimag/Symmetry/Mat/MatMult.h	/^    typedef typename Traits::ElType T;$/;"	t	class:psimag::MatMultVecPos
T	PartialPsimag/Symmetry/Mat/MatPrint.h	/^    typedef typename Traits::ElType T;$/;"	t	class:psimag::MAT_PRINT
T	PartialPsimag/Symmetry/Mat/MatTrace.h	/^      typedef typename Traits::ElType  T;$/;"	t	class:psimag::TRACE::TraceReducerType
T	PartialPsimag/Symmetry/Mat/MatTrace.h	/^    typedef typename Traits::ElType  T;$/;"	t	class:psimag::TRACE
T	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    typedef typename MT::ElType  T;$/;"	t	class:psimag::TRANSPOSE_ELS
T	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      T,   \/* Looking for _rue (true)   *\/$/;"	e	enum:JsonParser::StatesMixin::states
T	PsimagLite/src/JSON/MatrixLike.h	/^      typedef typename MatrixLikeType::value_type T;$/;"	t	class:psimag::MatrixLike::INVERT
T1	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      T1,  \/* tr       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
T2	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      T2,  \/* tru      *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
T3	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      T3,  \/* true     *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
TAG_Attribute_Parser_H	PartialPsimag/TagAttributeParser.h	/^#define TAG_Attribute_Parser_H$/;"	d
TAG_Attributes_H	PartialPsimag/TagAttributes.h	/^#define TAG_Attributes_H$/;"	d
TAG_H	PartialPsimag/Tag.h	/^#define TAG_H$/;"	d
TBFROMFILE_H	tbFromFile.h	/^#define TBFROMFILE_H$/;"	d
TBMV	PartialPsimag/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const double *a,int lda,$/;"	f	namespace:psimag::BLAS
TBMV	PartialPsimag/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const float *a,int lda,$/;"	f	namespace:psimag::BLAS
TBMV	PartialPsimag/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const std::complex<double> *a,$/;"	f	namespace:psimag::BLAS
TBMV	PartialPsimag/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const std::complex<float> *a,$/;"	f	namespace:psimag::BLAS
TBMV	PsimagLite/src/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const double *a,int lda,$/;"	f	namespace:psimag::BLAS
TBMV	PsimagLite/src/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const float *a,int lda,$/;"	f	namespace:psimag::BLAS
TBMV	PsimagLite/src/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const std::complex<double> *a,$/;"	f	namespace:psimag::BLAS
TBMV	PsimagLite/src/BLAS.h	/^inline void TBMV(char uplo,char trans,char diag,int n,int k,const std::complex<float> *a,$/;"	f	namespace:psimag::BLAS
TBSV	PartialPsimag/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const double *a,int lda,$/;"	f	namespace:psimag::BLAS
TBSV	PartialPsimag/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const float *a,int lda,$/;"	f	namespace:psimag::BLAS
TBSV	PartialPsimag/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const std::complex<double> *a,$/;"	f	namespace:psimag::BLAS
TBSV	PartialPsimag/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const std::complex<float> *a,$/;"	f	namespace:psimag::BLAS
TBSV	PsimagLite/src/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const double *a,int lda,$/;"	f	namespace:psimag::BLAS
TBSV	PsimagLite/src/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const float *a,int lda,$/;"	f	namespace:psimag::BLAS
TBSV	PsimagLite/src/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const std::complex<double> *a,$/;"	f	namespace:psimag::BLAS
TBSV	PsimagLite/src/BLAS.h	/^inline void TBSV(char uplo,char trans,char diag,int n,int k,const std::complex<float> *a,$/;"	f	namespace:psimag::BLAS
TEMP_PATTERN_H	PartialPsimag/Symmetry/PatternData.h	/^#define TEMP_PATTERN_H$/;"	d
TESTPATTERN_H	PartialPsimag/Symmetry/TestPattern.h	/^#define TESTPATTERN_H$/;"	d
TIMES	PartialPsimag/OperationClosure.h	/^    typedef enum{FourierTransform,PLUS,MINUS,TIMES,DIVIDE,INV} Type;$/;"	e	enum:psimag::OP::__anon112
TIMES	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	e	enum:psimag::OP::__anon120
TOKENIZER_H	PsimagLite/src/Tokenizer.h	/^#define TOKENIZER_H$/;"	d
TPMV	PartialPsimag/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const double *ap,double *x,int incx){$/;"	f	namespace:psimag::BLAS
TPMV	PartialPsimag/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const float *ap,float *x,int incx){$/;"	f	namespace:psimag::BLAS
TPMV	PartialPsimag/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const std::complex<double> *ap,$/;"	f	namespace:psimag::BLAS
TPMV	PartialPsimag/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const std::complex<float> *ap,$/;"	f	namespace:psimag::BLAS
TPMV	PsimagLite/src/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const double *ap,double *x,int incx){$/;"	f	namespace:psimag::BLAS
TPMV	PsimagLite/src/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const float *ap,float *x,int incx){$/;"	f	namespace:psimag::BLAS
TPMV	PsimagLite/src/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const std::complex<double> *ap,$/;"	f	namespace:psimag::BLAS
TPMV	PsimagLite/src/BLAS.h	/^inline void TPMV(char uplo,char trans,char diag,int n,const std::complex<float> *ap,$/;"	f	namespace:psimag::BLAS
TPSV	PartialPsimag/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const double *ap,double *x,int incx){$/;"	f	namespace:psimag::BLAS
TPSV	PartialPsimag/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const float *ap,float *x,int incx){$/;"	f	namespace:psimag::BLAS
TPSV	PartialPsimag/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const std::complex<double> *ap,$/;"	f	namespace:psimag::BLAS
TPSV	PartialPsimag/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const std::complex<float> *ap,$/;"	f	namespace:psimag::BLAS
TPSV	PsimagLite/src/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const double *ap,double *x,int incx){$/;"	f	namespace:psimag::BLAS
TPSV	PsimagLite/src/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const float *ap,float *x,int incx){$/;"	f	namespace:psimag::BLAS
TPSV	PsimagLite/src/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const std::complex<double> *ap,$/;"	f	namespace:psimag::BLAS
TPSV	PsimagLite/src/BLAS.h	/^inline void TPSV(char uplo,char trans,char diag,int n,const std::complex<float> *ap,$/;"	f	namespace:psimag::BLAS
TR	PartialPsimag/Symmetry/Mat/MatMult.h	/^    typedef typename TraitsR::ElType TR;$/;"	t	class:psimag::MatMultVecRow
TR	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      TR = -13, \/* false *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
TR	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      TR,  \/* Looking for __ue (true)        *\/$/;"	e	enum:JsonParser::StatesMixin::states
TRACE	PartialPsimag/Symmetry/Mat/MatTrace.h	/^  class TRACE {$/;"	c	namespace:psimag
TRANSPOSE	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^  class TRANSPOSE {$/;"	c	namespace:psimag
TRANSPOSE	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^  class TRANSPOSE<MatType, MatTypeR, Traits, TraitsR, 0> {$/;"	c	namespace:psimag
TRANSPOSE_ARRAY	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^#define TRANSPOSE_ARRAY(/;"	d
TRANSPOSE_ELS	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^  class TRANSPOSE_ELS {$/;"	c	namespace:psimag
TRANSPOSE_ELS	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^  class TRANSPOSE_ELS<MatType, MatTypeR, Traits, TraitsR, ROW, 0> {$/;"	c	namespace:psimag
TRIDIAGONAL_MATRIX_H	PsimagLite/src/TridiagonalMatrix.h	/^#define TRIDIAGONAL_MATRIX_H$/;"	d
TRMM	PartialPsimag/BLAS.h	/^inline void TRMM(char side,char uplo,char transa,char diag,int m,int n,$/;"	f	namespace:psimag::BLAS
TRMM	PartialPsimag/BLAS.h	/^inline void TRMM(char side,char uplo,char transa,char diag,int m,int n,const double &alpha,$/;"	f	namespace:psimag::BLAS
TRMM	PartialPsimag/BLAS.h	/^inline void TRMM(char side,char uplo,char transa,char diag,int m,int n,const float &alpha,$/;"	f	namespace:psimag::BLAS
TRMM	PsimagLite/src/BLAS.h	/^inline void TRMM(char side,char uplo,char transa,char diag,int m,int n,$/;"	f	namespace:psimag::BLAS
TRMM	PsimagLite/src/BLAS.h	/^inline void TRMM(char side,char uplo,char transa,char diag,int m,int n,const double &alpha,$/;"	f	namespace:psimag::BLAS
TRMM	PsimagLite/src/BLAS.h	/^inline void TRMM(char side,char uplo,char transa,char diag,int m,int n,const float &alpha,$/;"	f	namespace:psimag::BLAS
TRMV	PartialPsimag/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const double *a,int lda, $/;"	f	namespace:psimag::BLAS
TRMV	PartialPsimag/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const float *a,int lda, $/;"	f	namespace:psimag::BLAS
TRMV	PartialPsimag/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const std::complex<double> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRMV	PartialPsimag/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const std::complex<float> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRMV	PsimagLite/src/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const double *a,int lda, $/;"	f	namespace:psimag::BLAS
TRMV	PsimagLite/src/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const float *a,int lda, $/;"	f	namespace:psimag::BLAS
TRMV	PsimagLite/src/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const std::complex<double> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRMV	PsimagLite/src/BLAS.h	/^inline void TRMV(char uplo,char trans,char diag,int n,const std::complex<float> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSM	PartialPsimag/BLAS.h	/^inline void TRSM(char side,char uplo,char transa,char diag,int m,int n,$/;"	f	namespace:psimag::BLAS
TRSM	PartialPsimag/BLAS.h	/^inline void TRSM(char side,char uplo,char transa,char diag,int m,int n,const double &alpha,$/;"	f	namespace:psimag::BLAS
TRSM	PartialPsimag/BLAS.h	/^inline void TRSM(char side,char uplo,char transa,char diag,int m,int n,const float &alpha,$/;"	f	namespace:psimag::BLAS
TRSM	PsimagLite/src/BLAS.h	/^inline void TRSM(char side,char uplo,char transa,char diag,int m,int n,$/;"	f	namespace:psimag::BLAS
TRSM	PsimagLite/src/BLAS.h	/^inline void TRSM(char side,char uplo,char transa,char diag,int m,int n,const double &alpha,$/;"	f	namespace:psimag::BLAS
TRSM	PsimagLite/src/BLAS.h	/^inline void TRSM(char side,char uplo,char transa,char diag,int m,int n,const float &alpha,$/;"	f	namespace:psimag::BLAS
TRSV	PartialPsimag/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const double *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSV	PartialPsimag/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const float *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSV	PartialPsimag/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const std::complex<double> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSV	PartialPsimag/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const std::complex<float> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSV	PsimagLite/src/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const double *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSV	PsimagLite/src/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const float *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSV	PsimagLite/src/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const std::complex<double> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRSV	PsimagLite/src/BLAS.h	/^inline void TRSV(char uplo,char trans,char diag,int n,const std::complex<float> *a,int lda, $/;"	f	namespace:psimag::BLAS
TRU	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      TRU, \/* Looking for ___e (true)       *\/$/;"	e	enum:JsonParser::StatesMixin::states
TYPE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<bool>           { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_BOOL;     } };$/;"	c	namespace:JsonParser
TYPE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<double>         { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_DOUBLE;   } };$/;"	c	namespace:JsonParser
TYPE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<int>            { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_INTEGER;  } };$/;"	c	namespace:JsonParser
TYPE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<std::map<std::wstring,Whatever> >  { public: Whatever::WhateverType to() {return Whatever::WHATEVER_MAP;    } };$/;"	c	namespace:JsonParser
TYPE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<std::string>    { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_STRING;   } };$/;"	c	namespace:JsonParser
TYPE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<std::vector<Whatever> >            { public: Whatever::WhateverType to() {return Whatever::WHATEVER_VECTOR; } };$/;"	c	namespace:JsonParser
TYPE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<typename T> class TYPE       { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_UNKNOWN;  } };$/;"	c	namespace:JsonParser
TYPE_C	PsimagLite/src/Geometry/KTwoNiFFour.h	/^			size_t TYPE_C;$/;"	m	struct:PsimagLite::KTwoNiFFour::AdditionalData
TYPE_C	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {TYPE_O,TYPE_C};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon128
TYPE_O	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		enum {TYPE_O,TYPE_C};$/;"	e	enum:PsimagLite::KTwoNiFFour::__anon128
TYPE_TO_STRING_H	PsimagLite/src/TypeToString.h	/^#define TYPE_TO_STRING_H$/;"	d
Tag	PartialPsimag/Tag.h	/^    Tag():                                    name("span")                       {}$/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(char* name_, const ContentType& cont      ):    name(name_)                             { content << " " << cont << " "; }$/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(char* name_, const Elements&      elements_  ): name(name_), elements(elements_)        {}$/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(char* name_, const Tag&        tag        ):    name(name_)                             { elements.add(tag); }$/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(char* name_, const TagAttributes& attributes ): TagAttributes(attributes), name(name_)  {}$/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(char* name_, const TagAttributes& attributes, const Elements& elements_): $/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(const Tag& tag): $/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(const char* name_):                         name(name_)                         {}$/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^    Tag(const std::string name_):                   name(name_)                         {}$/;"	f	class:psimag::Tag
Tag	PartialPsimag/Tag.h	/^  class Tag: public TagAttributes {$/;"	c	namespace:psimag
TagAttributeParser	PartialPsimag/TagAttributeParser.h	/^    TagAttributeParser(const string& in, map<string,string>& attributes_):$/;"	f	class:psimag::TagAttributeParser
TagAttributeParser	PartialPsimag/TagAttributeParser.h	/^  class TagAttributeParser {$/;"	c	namespace:psimag
TagAttributes	PartialPsimag/TagAttributes.h	/^  class TagAttributes  {$/;"	c	namespace:psimag
TagAttributesClosure	PartialPsimag/TagAttributes.h	/^    TagAttributesClosure( const std::string                    _key,$/;"	f	class:psimag::TagAttributesClosure
TagAttributesClosure	PartialPsimag/TagAttributes.h	/^  class TagAttributesClosure {$/;"	c	namespace:psimag
TestPattern	PartialPsimag/Symmetry/TestPattern.h	/^    TestPattern():$/;"	f	class:psimag::TestPattern
TestPattern	PartialPsimag/Symmetry/TestPattern.h	/^    TestPattern(const LatticeWithPatternType&   latticeWithPattern,  $/;"	f	class:psimag::TestPattern
TestPattern	PartialPsimag/Symmetry/TestPattern.h	/^    TestPattern(const TestPattern<Field,DIM,Occupant,OtherLatticeType,Algorithms>&   testPattern):$/;"	f	class:psimag::TestPattern
TestPattern	PartialPsimag/Symmetry/TestPattern.h	/^  class TestPattern: public LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>   {$/;"	c	namespace:psimag
TestPatternType	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms> TestPatternType;$/;"	t	class:psimag::AppliedSymmetryElement
TestPatternType	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms> TestPatternType;$/;"	t	class:psimag::AppliedSymmetryElement
TestPatternType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>            TestPatternType;$/;"	t	class:psimag::GroupAction
TestPatternType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>                  TestPatternType;$/;"	t	class:psimag::GroupMultiplicationTable
TestPatternType	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>        TestPatternType;$/;"	t	class:psimag::LatticeWithPattern
TestPatternType	PartialPsimag/Symmetry/Star.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>            TestPatternType;$/;"	t	class:psimag::Star
TestPatternType	PartialPsimag/Symmetry/Symmetry.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>            TestPatternType;$/;"	t	class:psimag::Symmetry
TestPatternType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>            TestPatternType;$/;"	t	class:psimag::SymmetryGroup
TestPatternType	PartialPsimag/Symmetry/TestPattern.h	/^    typedef TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>              TestPatternType;$/;"	t	class:psimag::TestPattern
ThisType	PartialPsimag/IndexedMatrix.h	/^    typedef IndexedMatrix<MatrixLikeType,IndexType>       ThisType;$/;"	t	class:psimag::IndexedMatrix
ThisType	PartialPsimag/Matrix.h	/^    typedef Matrix<T>    ThisType;$/;"	t	class:psimag::Matrix
ThisType	PartialPsimag/MatrixSlice.h	/^    typedef ColSlice<MatrixLikeType>            ThisType;$/;"	t	class:psimag::ColSlice
ThisType	PartialPsimag/MatrixSlice.h	/^    typedef RowSlice<MatrixLikeType>            ThisType;$/;"	t	class:psimag::RowSlice
ThisType	PartialPsimag/MatrixSlice.h	/^    typedef TransposedRowSlice<MatrixLikeType>  ThisType;$/;"	t	class:psimag::TransposedColSlice
ThisType	PartialPsimag/MatrixSlice.h	/^    typedef TransposedRowSlice<MatrixLikeType>  ThisType;$/;"	t	class:psimag::TransposedRowSlice
ThisType	PartialPsimag/Symmetry/CellPosition.h	/^    typedef CellPositionType                    ThisType;$/;"	t	class:psimag::CellPosition
ThisType	PartialPsimag/Symmetry/CellTranslation.h	/^    typedef          CellTranslation<Field, DIM> ThisType;$/;"	t	class:psimag::CellTranslation
ThisType	PartialPsimag/Symmetry/Crystal.h	/^    typedef Crystal            <Field,DIM,Occupant,            Algorithms> ThisType;$/;"	t	class:psimag::Crystal
ThisType	PartialPsimag/Symmetry/CrystalBase.h	/^    typedef CrystalBase<Field,DIM,Occupant,LatticeTemplate,Algorithms>    ThisType;$/;"	t	class:psimag::CrystalBase
ThisType	PartialPsimag/Symmetry/GroupAction.h	/^    typedef SymmetryGroup<Field,DIM,Occupant,LatticeTemplate,Algorithms>      ThisType;$/;"	t	class:psimag::GroupAction
ThisType	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    typedef GroupMultiplicationTable<Field,DIM,Occupant,LatticeTemplate,Algorithms> ThisType;$/;"	t	class:psimag::GroupMultiplicationTable
ThisType	PartialPsimag/Symmetry/Lattice.h	/^    typedef Lattice<Field,DIM,Algorithms>                 ThisType;$/;"	t	class:psimag::Lattice
ThisType	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    typedef LatticeCoordinates<DIM>   ThisType;$/;"	t	class:psimag::LatticeCoordinates
ThisType	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    typedef LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>    ThisType;$/;"	t	class:psimag::LatticeWithPattern
ThisType	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    typedef HermiteNormalForm<Field, NROW, NCOL, Traits> ThisType;$/;"	t	class:psimag::HermiteNormalForm
ThisType	PartialPsimag/Symmetry/Mat/Mat.h	/^    typedef Mat<Field,NROW,NCOL,TRAITS>      ThisType;$/;"	t	class:psimag::Mat
ThisType	PartialPsimag/Symmetry/SeitzMatrix.h	/^    typedef SeitzMatrix<Field,DIM,RotationType_>  ThisType;$/;"	t	class:psimag::SeitzMatrix
ThisType	PartialPsimag/Symmetry/SeitzVector.h	/^    typedef SeitzVector<Field, DIM, IND, TRAITS> ThisType;$/;"	t	class:psimag::SeitzVector
ThisType	PartialPsimag/Symmetry/SuperCrystal.h	/^    typedef SuperCrystal<Field,DIM,Occupant,Algorithms,BuilderHelperTemplate> ThisType;      $/;"	t	class:psimag::SuperCrystal
ThisType	PartialPsimag/Symmetry/SymmetryElementName.h	/^    typedef SymmetryElementName                     ThisType;$/;"	t	class:psimag::SymmetryElementName
ThisType	PartialPsimag/Symmetry/SymmetryGroup.h	/^    typedef SymmetryGroup<Field,DIM,Occupant,LatticeTemplate,Algorithms>      ThisType;$/;"	t	class:psimag::SymmetryGroup
ThisType	PartialPsimag/Symmetry/rational.h	/^  typedef rational<Int>  ThisType;$/;"	t	class:rational
ThisType	PsimagLite/src/JSON/JSN_Writer.h	/^    typedef JSN<MapType> ThisType;$/;"	t	class:dca::JSN
ThisType	PsimagLite/src/JSON/Transposer.h	/^    typedef Transposer<MatrixLikeType>          ThisType;$/;"	t	class:psimag::Transposer
ThisType	PsimagLite/src/LanczosVectors.h	/^		typedef LanczosVectors<RealType,MatrixType,VectorType> ThisType;$/;"	t	class:PsimagLite::LanczosVectors
ThisType	PsimagLite/src/Minimizer.h	/^		typedef Minimizer<RealType,FunctionType> ThisType;$/;"	t	class:PsimagLite::Minimizer
ThreeFold	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class ThreeFold {};$/;"	c	namespace:psimag
ThreeFold	PartialPsimag/Symmetry/ThreeFold2D.h	/^    ThreeFold():$/;"	f	class:psimag::ThreeFold
ThreeFold	PartialPsimag/Symmetry/ThreeFold2D.h	/^    ThreeFold(IN_TYPE p1, IN_TYPE p2):$/;"	f	class:psimag::ThreeFold
ThreeFold	PartialPsimag/Symmetry/ThreeFold2D.h	/^    ThreeFold(const CellTranslationType&    offset):$/;"	f	class:psimag::ThreeFold
ThreeFold	PartialPsimag/Symmetry/ThreeFold2D.h	/^  class ThreeFold<Field,2,Algorithms>: $/;"	c	namespace:psimag
ThreeFoldN	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class ThreeFoldN{};$/;"	c	namespace:psimag
ThreeFoldN	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    ThreeFoldN():$/;"	f	class:psimag::ThreeFoldN
ThreeFoldN	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    ThreeFoldN(IN_TYPE p1, IN_TYPE p2):$/;"	f	class:psimag::ThreeFoldN
ThreeFoldN	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    ThreeFoldN(const CellTranslationType&    offset):$/;"	f	class:psimag::ThreeFoldN
ThreeFoldN	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^  class ThreeFoldN<Field,2,Algorithms>: $/;"	c	namespace:psimag
ThreeFoldNType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef ThreeFoldN<Field,DIM,Algorithms>                               ThreeFoldNType;$/;"	t	class:psimag::SymmetryElements
ThreeFoldType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef ThreeFold<Field,DIM,Algorithms>                                ThreeFoldType;$/;"	t	class:psimag::SymmetryElements
ThreeFoldType	PartialPsimag/Symmetry/ThreeFold2D.h	/^    typedef ThreeFold<Field,DIM,Algorithms>           ThreeFoldType;$/;"	t	class:psimag::ThreeFold
ThreeFoldType	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    typedef ThreeFold<Field,DIM,Algorithms>           ThreeFoldType;$/;"	t	class:psimag::ThreeFoldN
Trace	PartialPsimag/Symmetry/CellRotation.h	/^  Field Trace(const CellRotation<Field, DIM>& cellRotation) {$/;"	f	namespace:psimag
Trace	PartialPsimag/Symmetry/Mat/MatTrace.h	/^inline  T Trace(const MatType<T,NROW,NCOL,Traits>& m) {$/;"	f	namespace:psimag
Trace	PartialPsimag/Symmetry/Mat/MatTrace.h	/^inline  double Trace(ColMajorTraits<double,2>::ConstRefType m) { $/;"	f	namespace:psimag
Trace	PartialPsimag/Symmetry/Mat/MatTrace.h	/^inline  double Trace(ColMajorTraits<double,3>::ConstRefType m) { $/;"	f	namespace:psimag
Trace	PartialPsimag/Symmetry/Mat/MatTrace.h	/^inline  int Trace(ColMajorTraits<int,2>::ConstRefType m) { $/;"	f	namespace:psimag
Trace	PartialPsimag/Symmetry/Mat/MatTrace.h	/^inline  int Trace(ColMajorTraits<int,3>::ConstRefType m) { $/;"	f	namespace:psimag
Trace	PartialPsimag/Symmetry/SeitzMatrix.h	/^inline  Field Trace(const SeitzMatrix<Field, DIM>& m) {$/;"	f	namespace:psimag
TraceReducerType	PartialPsimag/Symmetry/Mat/MatTrace.h	/^    class TraceReducerType {$/;"	c	class:psimag::TRACE
Traits	PartialPsimag/Symmetry/Mat/Mat.h	/^    typedef TRAITS                           Traits;$/;"	t	class:psimag::Mat
Traits	PartialPsimag/Symmetry/SeitzMatrix.h	/^    typedef SeitzMatrixTraits<Field, DIM>         Traits;$/;"	t	class:psimag::SeitzMatrix
Traits	PartialPsimag/Symmetry/SeitzVector.h	/^    typedef TRAITS                               Traits;$/;"	t	class:psimag::SeitzVector
Traits	PartialPsimag/Vec.h	/^    typedef TRAITS Traits;$/;"	t	class:psimag::Vec
TransRetriever	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^      class TransRetriever {$/;"	c	class:psimag::SeitzMatrixTraits::REF
TransformType	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    typedef Mat<Field, NCOL, NROW, Traits>               TransformType;$/;"	t	class:psimag::HermiteNormalForm
TransformationType	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    typedef LatticeTransformation<Field,2>         TransformationType;$/;"	t	class:psimag::CenteringPointGroup
TransformationType	PartialPsimag/Symmetry/Centering2D.h	/^    typedef LatticeTransformation<Field,2>         TransformationType;$/;"	t	class:psimag::Centering
TranslationType	PartialPsimag/Symmetry/Glide2D.h	/^    typedef typename SymmetryOperationType::TranslationType       TranslationType;$/;"	t	class:psimag::Glide
TranslationType	PartialPsimag/Symmetry/Mirror2D.h	/^    typedef typename SymmetryOperationType::TranslationType    TranslationType;$/;"	t	class:psimag::Mirror
TranslationType	PartialPsimag/Symmetry/SeitzMatrix.h	/^    typedef Vec<Field, DIM>                       TranslationType;$/;"	t	class:psimag::SeitzMatrix
TranslationType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef typename SymmetryOperationType::TranslationType                TranslationType;$/;"	t	class:psimag::SymmetryElements
TranslationType	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    typedef typename SymmetryOperationType::TranslationType                TranslationType;$/;"	t	class:psimag::SymmetryOperations
Translations	PartialPsimag/Symmetry/CeneringPointGroup.h	/^    static const DirectionVectorType Translations() {$/;"	f	class:psimag::CenteringPointGroup
Translations	PartialPsimag/Symmetry/Centering2D.h	/^    static const DirectionVectorType Translations() {$/;"	f	class:psimag::Centering
Transpose	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^  inline  void Transpose(const MatType <T,DIM,DIM, TraitsTemplate <T,DIM,DIM> >& m, $/;"	f	namespace:psimag
Transposed	PsimagLite/src/JSON/Transposer.h	/^    Transposed(size_t nrows):$/;"	f	class:psimag::Transposed
Transposed	PsimagLite/src/JSON/Transposer.h	/^    Transposed(size_t nrows, size_t nCols):$/;"	f	class:psimag::Transposed
Transposed	PsimagLite/src/JSON/Transposer.h	/^  class Transposed {$/;"	c	namespace:psimag
TransposedColSlice	PartialPsimag/MatrixSlice.h	/^    TransposedColSlice(const MatrixLikeType& m, size_t colIndex):$/;"	f	class:psimag::TransposedColSlice
TransposedColSlice	PartialPsimag/MatrixSlice.h	/^  class TransposedColSlice {$/;"	c	namespace:psimag
TransposedRowSlice	PartialPsimag/MatrixSlice.h	/^    TransposedRowSlice(const MatrixLikeType& m, size_t rowIndex):$/;"	f	class:psimag::TransposedRowSlice
TransposedRowSlice	PartialPsimag/MatrixSlice.h	/^  class TransposedRowSlice:$/;"	c	namespace:psimag
Transposer	PsimagLite/src/JSON/Transposer.h	/^    Transposer(MatrixLikeType& m):$/;"	f	class:psimag::Transposer
Transposer	PsimagLite/src/JSON/Transposer.h	/^  class Transposer {$/;"	c	namespace:psimag
TriLinear	interpolation.h	/^		void TriLinear(VectorType& q,SuscType& result) const {$/;"	f	class:rpa::interpolation
TriLinearGeneral	interpolation.h	/^		void TriLinearGeneral(VectorType& q,SuscType& result) const {$/;"	f	class:rpa::interpolation
TridiagonalMatrix	PsimagLite/src/TridiagonalMatrix.h	/^		TridiagonalMatrix()  { }$/;"	f	class:PsimagLite::TridiagonalMatrix
TridiagonalMatrix	PsimagLite/src/TridiagonalMatrix.h	/^		TridiagonalMatrix(IoInputType& io)$/;"	f	class:PsimagLite::TridiagonalMatrix
TridiagonalMatrix	PsimagLite/src/TridiagonalMatrix.h	/^	class TridiagonalMatrix {$/;"	c	namespace:PsimagLite
TridiagonalMatrixType	PsimagLite/drivers/combineContinuedFraction.cpp	/^typedef TridiagonalMatrix<RealType> TridiagonalMatrixType;$/;"	t	file:
TridiagonalMatrixType	PsimagLite/drivers/continuedFraction.cpp	/^typedef TridiagonalMatrix<RealType> TridiagonalMatrixType;$/;"	t	file:
TridiagonalMatrixType	PsimagLite/drivers/continuedFractionCollection.cpp	/^typedef TridiagonalMatrix<RealType> TridiagonalMatrixType;$/;"	t	file:
TridiagonalMatrixType	PsimagLite/src/ChebyshevSolver.h	/^		typedef std::vector<RealType> TridiagonalMatrixType;$/;"	t	class:PsimagLite::ChebyshevSolver
TridiagonalMatrixType	PsimagLite/src/ContinuedFraction.h	/^		typedef TridiagonalMatrixType_ TridiagonalMatrixType;$/;"	t	class:PsimagLite::ContinuedFraction
TridiagonalMatrixType	PsimagLite/src/ContinuedFractionCollection.h	/^				TridiagonalMatrixType;$/;"	t	class:PsimagLite::ContinuedFractionCollection
TridiagonalMatrixType	PsimagLite/src/LanczosSolver.h	/^		typedef typename LanczosVectorsType::TridiagonalMatrixType TridiagonalMatrixType;$/;"	t	class:PsimagLite::LanczosSolver
TridiagonalMatrixType	PsimagLite/src/LanczosVectors.h	/^		typedef TridiagonalMatrix<RealType> TridiagonalMatrixType;$/;"	t	class:PsimagLite::LanczosVectors
True	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void True( ) {$/;"	f	class:JsonParser::DefaultContext
TwoFold	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class TwoFold   {};$/;"	c	namespace:psimag
TwoFold	PartialPsimag/Symmetry/TwoFold2D.h	/^    TwoFold():$/;"	f	class:psimag::TwoFold
TwoFold	PartialPsimag/Symmetry/TwoFold2D.h	/^    TwoFold(IN_TYPE p1, IN_TYPE p2):$/;"	f	class:psimag::TwoFold
TwoFold	PartialPsimag/Symmetry/TwoFold2D.h	/^    TwoFold(const CellTranslationType&    offset):$/;"	f	class:psimag::TwoFold
TwoFold	PartialPsimag/Symmetry/TwoFold2D.h	/^  class TwoFold<Field,2,Algorithms>: $/;"	c	namespace:psimag
TwoFoldN	PartialPsimag/Symmetry/SymmetryElement.h	/^  template<typename Field, size_t DIM, typename Algorithms> class TwoFoldN  {};$/;"	c	namespace:psimag
TwoFoldType	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    typedef TwoFold<Field,DIM,Algorithms>                                  TwoFoldType;$/;"	t	class:psimag::SymmetryElements
TwoFoldType	PartialPsimag/Symmetry/TwoFold2D.h	/^    typedef TwoFold<Field,DIM,Algorithms>             TwoFoldType;$/;"	t	class:psimag::TwoFold
Type	PartialPsimag/OperationClosure.h	/^    typedef enum{FourierTransform,PLUS,MINUS,TIMES,DIVIDE,INV} Type;$/;"	t	class:psimag::OP	typeref:enum:psimag::OP::__anon112
Type	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            Type[NROW_*NCOL_];$/;"	t	class:psimag::ColMajorTraits
Type	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            Type[NROW_*NCOL_];$/;"	t	class:psimag::ConstantTraits
Type	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    typedef T            Type[NROW_*NCOL_];$/;"	t	class:psimag::RowMajorTraits
Type	PsimagLite/src/JSON/OperationClosure.h	/^    typedef enum{FourierTransform,Integrate,PLUS,MINUS,TIMES,DIVIDE,INV,NORM} Type;$/;"	t	class:psimag::OP	typeref:enum:psimag::OP::__anon120
Type2Type	PartialPsimag/Symmetry/TypeManip.h	/^    struct Type2Type$/;"	s	namespace:psimag
TypeComputer	PartialPsimag/Symmetry/SeitzMatrix.h	/^    class TypeComputer {$/;"	c	class:psimag::SeitzMatrix
TypeComputer	PartialPsimag/Symmetry/SeitzVector.h	/^    template<typename T> class TypeComputer {public: typedef T Result[DIM]; };$/;"	c	class:psimag::SeitzVector
TypeManip_Private	PartialPsimag/Symmetry/TypeManip.h	/^    namespace TypeManip_Private$/;"	n	namespace:psimag
TypesMixin	PsimagLite/src/JSON/JsonParser/TypesMixin.h	/^  class TypesMixin {$/;"	c	namespace:JsonParser
U	PythonScripts/plotChiRPAAlongHighSym.py	/^	U  = float(sys.argv[1])$/;"	v
U	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U	rpa.h	/^			Field U,Up,J,Jp;$/;"	m	class:rpa::interaction
U1	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      U1,  \/* u1       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
U2	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      U2,  \/* u2       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
U3	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      U3,  \/* u3       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
U4	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      U4,  \/* u4       *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
UC	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      UC = -22, \/* Unicode character read *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
USER_TIME	PsimagLite/src/Rusage.h	/^		enum {USER_TIME,SYSTEM_TIME};$/;"	e	enum:PsimagLite::Rusage::__anon132
UTILITIES_H	utilities.h	/^#define UTILITIES_H$/;"	d
U_d_c	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_d_c	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_d_coupl	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_d_coupl	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_d_s	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_d_s	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_p_c	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_p_c	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_p_coupl	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_p_coupl	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_p_s	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_p_s	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_pd_c	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_pd_c	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_pd_coupl	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_pd_coupl	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_pd_s	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_pd_s	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_pp_c	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_pp_c	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_pp_coupl	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_pp_coupl	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
U_pp_s	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
U_pp_s	rpa_CuO.h	/^			Field U_d_c,U_d_s,U_p_c,U_p_s,U_pd_c,U_pd_s,U_pp_c,U_pp_s,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::interactionEmery
UnaryOperationClosure	PartialPsimag/OperationClosure.h	/^    UnaryOperationClosure(const OperandType& theOperand):$/;"	f	class:psimag::UnaryOperationClosure
UnaryOperationClosure	PartialPsimag/OperationClosure.h	/^  class UnaryOperationClosure {$/;"	c	namespace:psimag
UnaryOperationClosure	PsimagLite/src/JSON/OperationClosure.h	/^    UnaryOperationClosure(const OperandType& theOperand):$/;"	f	class:psimag::UnaryOperationClosure
UnaryOperationClosure	PsimagLite/src/JSON/OperationClosure.h	/^  class UnaryOperationClosure {$/;"	c	namespace:psimag
Up	PythonScripts/plotChiRPAAlongHighSym.py	/^		Up = float(sys.argv[2])$/;"	v
Up	parameters.h	/^		Field U,Up,J,Jp,U_d_s,U_d_c,U_p_s,U_p_c,U_pd_s,U_pd_c,U_pp_s,U_pp_c,U_d_coupl,U_p_coupl,U_pd_coupl,U_pp_coupl;$/;"	m	class:rpa::parameters
Up	rpa.h	/^			Field U,Up,J,Jp;$/;"	m	class:rpa::interaction
VA	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      VA,  \/* value    *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
VA	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^      VA,  \/* looking for a value    *\/$/;"	e	enum:JsonParser::StatesMixin::states
VAL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^      enum { VAL=0 }; $/;"	e	enum:psimag::ConstantTraits::Index::__anon57
VAL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class Index { public: enum { VAL=COL_*NROW_+ROW_ }; };$/;"	e	enum:psimag::ColMajorTraits::Index::__anon55
VAL	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    class Index {public: enum { VAL=ROW_*NROW_+COL_ }; };$/;"	e	enum:psimag::RowMajorTraits::Index::__anon53
V_Charge	rpa_CuO.h	/^			ComplexMatrixType V_Charge;$/;"	m	class:rpa::interactionEmery
V_Charge_coupl	rpa_CuO.h	/^			ComplexMatrixType V_Charge_coupl;$/;"	m	class:rpa::interactionEmery
V_D	rpa_CuO.h	/^			ComplexMatrixType V_D;$/;"	m	class:rpa::interactionEmery
V_D_coupl	rpa_CuO.h	/^			ComplexMatrixType V_D_coupl;$/;"	m	class:rpa::interactionEmery
V_Spin	rpa_CuO.h	/^			ComplexMatrixType V_Spin;$/;"	m	class:rpa::interactionEmery
V_Spin_coupl	rpa_CuO.h	/^			ComplexMatrixType V_Spin_coupl;$/;"	m	class:rpa::interactionEmery
V_X_c	rpa_CuO.h	/^			ComplexMatrixType V_X_c;$/;"	m	class:rpa::interactionEmery
V_X_coupl	rpa_CuO.h	/^			ComplexMatrixType V_X_coupl;$/;"	m	class:rpa::interactionEmery
V_X_s	rpa_CuO.h	/^			ComplexMatrixType V_X_s;$/;"	m	class:rpa::interactionEmery
ValueType	PartialPsimag/TagAttributes.h	/^    typedef std::string ValueType;$/;"	t	class:psimag::TagAttributesClosure
ValueType	PartialPsimag/ValueTypeFunction.h	/^    typedef typename MatrixOrVectorLikeType::value_type        ValueType;$/;"	t	class:psimag::ValueTypeFunction
ValueType	PartialPsimag/ValueTypeFunction.h	/^    typedef typename MatrixOrVectorLikeType::value_type ValueType;$/;"	t	class:psimag::ValueTypeFunction
ValueType	PsimagLite/src/SparseRow.h	/^		typedef typename CrsMatrixType::value_type ValueType;$/;"	t	class:PsimagLite::SparseRow
ValueType	PsimagLite/src/Vector.h	/^		typedef T ValueType;$/;"	t	class:PsimagLite::Vector
ValueTypeFunction	PartialPsimag/ValueTypeFunction.h	/^    class ValueTypeFunction<const MatrixOrVectorLikeType> {$/;"	c	namespace:psimag
ValueTypeFunction	PartialPsimag/ValueTypeFunction.h	/^  class ValueTypeFunction {$/;"	c	namespace:psimag
Vec	PartialPsimag/Vec.h	/^    Vec() $/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec()$/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec(const T * const a,size_t stride=1) $/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec(const T& x,const T& y) $/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec(const T& x,const T& y,const T& z) $/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec(const T* const a, size_t stride=1)$/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec(const Vec<T,2>& v) $/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec(const Vec<T,3>& v) $/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    Vec(const Vec<T,DIM>& v)$/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^    explicit Vec(const T& a) $/;"	f	class:psimag::Vec
Vec	PartialPsimag/Vec.h	/^  class Vec {$/;"	c	namespace:psimag
Vec	PartialPsimag/Vec.h	/^  class Vec< T, 3, TRAITS > {$/;"	c	namespace:psimag
Vec	PartialPsimag/Vec.h	/^  template < typename T , typename TRAITS > class Vec< T, 2, TRAITS> {$/;"	c	namespace:psimag
Vector	PartialPsimag/Vector.h	/^	class Vector : public std::vector<T> {$/;"	c	namespace:psimag
Vector	PsimagLite/src/Vector.h	/^	class  Vector : public std::vector<T> {$/;"	c	namespace:PsimagLite
VectorElementType	PsimagLite/src/ChebyshevSolver.h	/^		typedef typename VectorType::value_type VectorElementType;$/;"	t	class:PsimagLite::ChebyshevSolver
VectorElementType	PsimagLite/src/LanczosSolver.h	/^		typedef typename VectorType::value_type VectorElementType;$/;"	t	class:PsimagLite::LanczosSolver
VectorElementType	PsimagLite/src/LanczosVectors.h	/^		typedef typename VectorType::value_type VectorElementType;$/;"	t	class:PsimagLite::LanczosVectors
VectorIntType	ferminator.h	/^		typedef std::vector<int>      		    VectorIntType;$/;"	t	class:rpa::ferminator
VectorLike	PartialPsimag/VectorLike.h	/^  namespace VectorLike {$/;"	n	namespace:psimag
VectorSuscType	susceptibility.h	/^			typedef std::vector<SuscType>              VectorSuscType;$/;"	t	class:rpa::susceptibility
VectorType	1band_wSpin.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::SingleBand_wSpin
VectorType	4Orbital.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::FourOrbital
VectorType	BSCCObilayer.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
VectorType	BaFeAs_5orb.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::BaFeAs
VectorType	FourOrbital.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::FourOrbital
VectorType	KFe2Se2.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::KFe2Se2
VectorType	PsimagLite/drivers/akimaSpline.cpp	/^typedef std::vector<FieldType> VectorType;$/;"	t	file:
VectorType	PsimagLite/drivers/concurrencyTest.cpp	/^typedef std::vector<RealType> VectorType;$/;"	t	file:
VectorType	PsimagLite/src/ChebyshevSerializer.h	/^		typedef VectorType_ VectorType;$/;"	t	class:PsimagLite::ChebyshevSerializer
VectorType	PsimagLite/src/Minimizer.h	/^		typedef std::vector<FieldType> VectorType;$/;"	t	class:PsimagLite::Minimizer
VectorType	PsimagLite/src/SparseRow.h	/^		typedef std::vector<ValueType> VectorType;$/;"	t	class:PsimagLite::SparseRow
VectorType	SrRuO.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::SrRuO
VectorType	SrRuO_SO.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
VectorType	bands.h	/^		typedef std::vector<Field>      VectorType;$/;"	t	class:rpa::Bands
VectorType	bandstructure.h	/^		typedef std::vector<Field>  		VectorType;$/;"	t	class:rpa::bandstructure
VectorType	bilayer.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
VectorType	bilayerFESC.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
VectorType	chi0.h	/^		typedef std::vector<Field>      		VectorType;$/;"	t	class:rpa::calcChi0Matrix
VectorType	chi0.h	/^		typedef std::vector<Field>      		VectorType;$/;"	t	class:rpa::chi0q
VectorType	chi0Ofq.h	/^		typedef std::vector<Field> VectorType;$/;"	t	class:rpa::chi0ofq
VectorType	coupledLadders.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
VectorType	ferminator.h	/^		typedef std::vector<Field>      		VectorType;$/;"	t	class:rpa::ferminator
VectorType	gap.h	/^		typedef std::vector<Field>      VectorType;$/;"	t	class:rpa::gap
VectorType	gaps2D.h	/^		typedef std::vector<Field>      VectorType;$/;"	t	class:rpa::gap2D
VectorType	gaps3D.h	/^        typedef std::vector<Field>      VectorType;$/;"	t	class:rpa::gap3D
VectorType	greensFunction.h	/^		typedef std::vector<Field> VectorType;$/;"	t	class:rpa::greensFunction
VectorType	interpolation.h	/^		typedef std::vector<Field>      		VectorType;$/;"	t	class:rpa::interpolation
VectorType	momentumDomain.h	/^		typedef std::vector<Field>      			VectorType;$/;"	t	class:rpa::momentumDomain
VectorType	orthoIIBilayer.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
VectorType	pairing.h	/^		typedef std::vector<Field>      		VectorType;$/;"	t	class:rpa::pairing
VectorType	rpa_CuO.h	/^			typedef std::vector<Field> 				VectorType;$/;"	t	class:rpa::interactionEmery
VectorType	sepBasis.h	/^			typedef std::vector<Field> 				VectorType;$/;"	t	class:rpa::sepBasis
VectorType	singleBand.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
VectorType	susceptibility.h	/^			typedef std::vector<Field>      		   VectorType;$/;"	t	class:rpa::susceptibility
VectorType	tbFromFile.h	/^		typedef std::vector<Field>      	VectorType;$/;"	t	class:rpa::model
WHATEVER_BOOL	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_BOOL,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_DOUBLE	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_DOUBLE,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_INTEGER	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_INTEGER,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_MAP	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_MAP,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_MAT	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_MAT,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_MATRIX	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_MATRIX,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_NULL	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_NULL,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_STRING	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_STRING,$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_UNKNOWN	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_UNKNOWN$/;"	e	enum:JsonParser::Whatever::__anon115
WHATEVER_VECTOR	PsimagLite/src/JSON/JsonParser/Whatever.h	/^      WHATEVER_VECTOR,$/;"	e	enum:JsonParser::Whatever::__anon115
WITH_INFO	PsimagLite/src/ChebyshevSolver.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::ChebyshevSolver::__anon114
WITH_INFO	PsimagLite/src/LanczosSolver.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::LanczosSolver::__anon122
WITH_INFO	PsimagLite/src/LanczosVectors.h	/^		enum {WITH_INFO=1,DEBUG=2,ALLOWS_ZERO=4};$/;"	e	enum:PsimagLite::LanczosVectors::__anon113
WTrafo	parameters.h	/^		MatrixType WTrafo;$/;"	m	class:rpa::parameters
Whatever	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever():$/;"	f	class:JsonParser::Whatever
Whatever	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever(WhateverType t):$/;"	f	class:JsonParser::Whatever
Whatever	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  class Whatever {$/;"	c	namespace:JsonParser
WhateverMap	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    typedef std::map<std::wstring,Whatever> WhateverMap;$/;"	t	class:JsonParser::Whatever
WhateverType	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    } WhateverType;$/;"	t	class:JsonParser::Whatever	typeref:enum:JsonParser::Whatever::__anon115
WhateverVector	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    typedef std::vector<Whatever>           WhateverVector;$/;"	t	class:JsonParser::Whatever
WordType	PsimagLite/src/BitManip.h	/^		typedef unsigned int long long WordType;$/;"	t	namespace:PsimagLite::BitManip
XHTML	PartialPsimag/XMLHeading.h	/^    typedef enum { XHTML, SVG} DocType;$/;"	e	enum:psimag::XMLHeading::__anon1
XMLHeading	PartialPsimag/XMLHeading.h	/^    XMLHeading(DocType docType_=XMLHeading::XHTML):$/;"	f	class:psimag::XMLHeading
XMLHeading	PartialPsimag/XMLHeading.h	/^  class XMLHeading {$/;"	c	namespace:psimag
XML_HEADING_H	PartialPsimag/XMLHeading.h	/^#define XML_HEADING_H$/;"	d
ZE	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      ZE,  \/* zero     *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
ZX	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      ZX = -19, \/* integer detected by zero *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
Zofk	pairing.h	/^		VectorType Zofk;$/;"	m	class:rpa::pairing
_Assert	PartialPsimag/PSIMAGAssert.h	/^void _Assert(const char * filename, int lineno, $/;"	f	namespace:psimag
_Assert	PartialPsimag/PSIMAGAssert.h	/^void _Assert(const char * filename, int lineno, A assertion, E except)$/;"	f	namespace:psimag
_Assert	PsimagLite/src/JSON/PSIMAGAssert.h	/^void _Assert(const char * filename, int lineno, $/;"	f	namespace:psimag
_Assert	PsimagLite/src/JSON/PSIMAGAssert.h	/^void _Assert(const char * filename, int lineno, A assertion, E except)$/;"	f	namespace:psimag
__	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^      __ = -1,  \/* Error *\/$/;"	e	enum:JsonParser::StatesAndActionsMixin::statesAndActions
__init__	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def __init__(self,nkIntlin=128,nklin=16,nwm=1,T=0.2,doping="OD0",U=2.0,calcV=False):$/;"	m	class:RPA
__init__	PythonScripts/CoupledLadders.py	/^	def __init__(self,t=1.0,tp=0.0,tlRatio=1.0):$/;"	m	class:CoupledLadders
__init__	PythonScripts/Sr2RuO4.py	/^        def __init__(self,nklin=16,T=0.2,U=2.0,lamSO = 0.035,mu=0.109):$/;"	m	class:RPA
_fixed	PartialPsimag/KISS.h	/^    seed_type _fixed; \/\/ this seed can have any value$/;"	m	class:psimag::KISS
_rank	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    size_t _rank;$/;"	m	class:psimag::HermiteNormalForm
_setState	PartialPsimag/KISS.h	/^    void _setState(seed_type a, seed_type b, seed_type c)$/;"	f	class:psimag::KISS
_small	PartialPsimag/KISS.h	/^    seed_type _small; \/\/ to guarantee long period 1 < _smallSeed < 2580$/;"	m	class:psimag::KISS
a	PartialPsimag/Symmetry/CellParameters.h	/^    Field a;          \/**< The length of the      shortest translation vector. **\/$/;"	m	class:psimag::CellParameters
a	PartialPsimag/Symmetry/CellParameters.h	/^    Field a;          \/**< The length of the shortest translation vector. **\/$/;"	m	class:psimag::CellParameters
a	PartialPsimag/Symmetry/Glide2D.h	/^    static GlideType* a() { $/;"	f	class:psimag::Glide
a	PartialPsimag/Symmetry/Glide2D.h	/^    static GlideType* a(IN_TYPE shift) { $/;"	f	class:psimag::Glide
a	PartialPsimag/Symmetry/Mirror2D.h	/^    static MirrorType* a() { $/;"	f	class:psimag::Mirror
a	PartialPsimag/Symmetry/Mirror2D.h	/^    static MirrorType* a(IN_TYPE shift) { $/;"	f	class:psimag::Mirror
a	PsimagLite/src/TridiagonalMatrix.h	/^		FieldType& a(size_t i) { return a_[i]; }$/;"	f	class:PsimagLite::TridiagonalMatrix
a	PsimagLite/src/TridiagonalMatrix.h	/^		const FieldType& a(size_t i) const { return a_[i]; }$/;"	f	class:PsimagLite::TridiagonalMatrix
a	gap.h	/^		VectorType a,b,c;$/;"	m	class:rpa::gap
a	gaps2D.h	/^		VectorType a,b,c;$/;"	m	class:rpa::gap2D
a0	PsimagLite/src/AkimaSpline.h	/^		RealType x0,x1,a0,a1,a2,a3;$/;"	m	struct:AkimaSpline::AkimaStruct
a1	PsimagLite/src/AkimaSpline.h	/^		RealType x0,x1,a0,a1,a2,a3;$/;"	m	struct:AkimaSpline::AkimaStruct
a1	momentumDomain.h	/^		VectorType a1,a2,a3;$/;"	m	class:rpa::momentumDomain
a1	parameters.h	/^		std::vector<Field> a1,a2,a3;$/;"	m	class:rpa::parameters
a2	PsimagLite/src/AkimaSpline.h	/^		RealType x0,x1,a0,a1,a2,a3;$/;"	m	struct:AkimaSpline::AkimaStruct
a2	momentumDomain.h	/^		VectorType a1,a2,a3;$/;"	m	class:rpa::momentumDomain
a2	parameters.h	/^		std::vector<Field> a1,a2,a3;$/;"	m	class:rpa::parameters
a3	PsimagLite/src/AkimaSpline.h	/^		RealType x0,x1,a0,a1,a2,a3;$/;"	m	struct:AkimaSpline::AkimaStruct
a3	momentumDomain.h	/^		VectorType a1,a2,a3;$/;"	m	class:rpa::momentumDomain
a3	parameters.h	/^		std::vector<Field> a1,a2,a3;$/;"	m	class:rpa::parameters
aSidedCenteredRectangle	PartialPsimag/Symmetry/CellParameters.h	/^    bool aSidedCenteredRectangle() const {$/;"	f	class:psimag::CellParameters
a_	PsimagLite/src/TridiagonalMatrix.h	/^		std::vector<FieldType> a_,b_;$/;"	m	class:PsimagLite::TridiagonalMatrix
ab_	PsimagLite/src/ContinuedFraction.h	/^		TridiagonalMatrixType ab_;$/;"	m	class:PsimagLite::ContinuedFraction
abs	PartialPsimag/Symmetry/rational.h	/^  rational<Int> abs() { rational<Int> w; w.num=abs(num); w.den=abs(den); return w; }$/;"	f	class:rational
abs	PartialPsimag/Symmetry/rational.h	/^rational<Int> abs(rational<Int> a)$/;"	f
abstractRat	PartialPsimag/Symmetry/FieldParser.h	/^    AbstractRat<IntType> abstractRat;$/;"	m	class:psimag::FieldParser
acceptableInterceptPt	PartialPsimag/Symmetry/SymmetryOperation.h	/^  bool acceptableInterceptPt(const CellPosition<Field,2,Algorithms>&  p)$/;"	f	namespace:psimag
accumulate	PartialPsimag/VectorLike.h	/^    void accumulate(VectorLikeType1& vector1,$/;"	f	namespace:psimag::VectorLike
accumulate	PsimagLite/src/ContinuedFractionCollection.h	/^		void accumulate(PlotDataType& v1,const PlotDataType& v2) const$/;"	f	class:PsimagLite::ContinuedFractionCollection
actionName	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^    static std::string  actionName(ActionType action) {$/;"	f	class:JsonParser::ActionsMixin
actions	PsimagLite/src/JSON/JsonParser/ActionsMixin.h	/^    typedef enum actions {$/;"	g	class:JsonParser::ActionsMixin
actions	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^      std::vector<ActionType> actions;$/;"	m	class:JsonParser::AugmentedStateTranslationTable::Pair
add	PartialPsimag/Tag.h	/^      void add(const Tag& tag) {$/;"	f	class:psimag::Tag::Elements
add	PartialPsimag/Tag.h	/^      void add(const TagCollectionType& tags) {$/;"	f	class:psimag::Tag::Elements
add	PartialPsimag/Tag.h	/^    void add(const Tag& tag) {$/;"	f	class:psimag::Tag
add	PartialPsimag/Tag.h	/^    void add(const TagCollectionType<Tag>& tags) {$/;"	f	class:psimag::Tag
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const T& obj){ $/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const bool&          b)   { bools  [key] = b;    }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const char*        str)   { strings[key] = str;  }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const double& val)              { numbers[key] = val;  }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const int&    val)              { numbers[key] = val;  }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const psimag::Matrix<double>& mat ) { dblMatrices[key] = &mat; }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const psimag::Matrix<int>&    mat ) { intMatrices[key] = &mat; }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const size_t& val)              { numbers[key] = val;  }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const std::map<std::string, T>& map) {$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const std::string& str)   { strings[key] = str;  }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const std::vector<double>&    vals) { vectors[key]     = vals; }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const std::vector<int>&       vals) { intvectors[key]  = vals; }$/;"	f	class:dca::JSN
add	PsimagLite/src/JSON/JSN_Writer.h	/^    void add(std::string key, const std::vector<size_t>&    vals) { sizetvectors[key]= vals; }$/;"	f	class:dca::JSN
add	PsimagLite/src/SparseRow.h	/^		void add(size_t col,ValueType value)$/;"	f	class:PsimagLite::SparseRow
addAppliedElement	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    int addAppliedElement(const AppliedSymmetryElementType&        appliedElement)$/;"	f	class:psimag::GroupMultiplicationTable
addElementToPair	PartialPsimag/Symmetry/Star.h	/^    void addElementToPair(AppliedSymmetryElementPairType&          pair,$/;"	f	class:psimag::Star
addSiteTableXML	PartialPsimag/Symmetry/Pattern.h	/^  Tag addSiteTableXML(const Pattern<Field,DIM,Occupant,Algorithms>& pat,$/;"	f	namespace:psimag
addTileOccupants	PartialPsimag/Symmetry/FloodTiler.h	/^    void addTileOccupants(const CartesianTranslationType& trans) {$/;"	f	class:psimag::FloodTiler
advance	PsimagLite/src/IoSimple.h	/^				std::pair<std::string,size_t> advance($/;"	f	class:PsimagLite::IoSimple::In
ak	bandstructure.h	/^		std::vector<ComplexMatrixType> ak;$/;"	m	class:rpa::bandstructure
akIm	PythonScripts/Sr2RuO4.py	/^        akIm = ctypeslib.as_ctypes(zeros((NInt,nOrb,nOrb),dtype='float'))$/;"	v	class:RPA
akRe	PythonScripts/Sr2RuO4.py	/^        akRe = ctypeslib.as_ctypes(zeros((NInt,nOrb,nOrb),dtype='float'))$/;"	v	class:RPA
akimaStruct_	PsimagLite/src/AkimaSpline.h	/^		std::vector<AkimaStruct> akimaStruct_;$/;"	m	class:AkimaSpline
akq	bandstructure.h	/^		std::vector<ComplexMatrixType> akq;$/;"	m	class:rpa::bandstructure
allAppliedElements	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    allAppliedElements(const LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>& latpat) {$/;"	f	class:psimag::SymmetryElements
allAppliedSymmetryElements	PartialPsimag/Symmetry/Symmetry.h	/^    AppliedSymmetryElementsType allAppliedSymmetryElements;  $/;"	m	class:psimag::Symmetry
allElements	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    const AppliedSymmetryElementsType& allElements;$/;"	m	class:psimag::AppliedSymmetryElementIterator
allReduce	PsimagLite/src/ConcurrencyMpi.h	/^		void allReduce(psimag::Matrix<std::complex<double> >& m,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
allReduce	PsimagLite/src/ConcurrencyMpi.h	/^		void allReduce(std::vector<double>& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
allReduce	PsimagLite/src/ConcurrencyMpi.h	/^		void allReduce(std::vector<psimag::Matrix<std::complex<double> > >& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
allReduce	PsimagLite/src/ConcurrencySerial.h	/^		void allReduce(DataType& v,CommType mpiComm=COMM_WORLD) {}$/;"	f	class:PsimagLite::ConcurrencySerial
allReduce	chi0.h	/^		void allReduce() {$/;"	f	class:rpa::susc
allow_comments	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    bool                 allow_comments; $/;"	m	class:JsonParser::JsonParser
alpha	PartialPsimag/Symmetry/CellParameters.h	/^    Field alpha;      \/**< The angle between b and c. **\/$/;"	m	class:psimag::CellParameters
alpha	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  alpha()      const { return acos(cos_alpha())*180.0\/PI; }$/;"	f	class:psimag::MetricTensor
alpha	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  alpha()     const { return acos(cos_alpha())*180.0\/PI; }$/;"	f	class:psimag::MetricTensor
analyzeSpaceGroups	PartialPsimag/Symmetry/Symmetry.h	/^    void analyzeSpaceGroups() {$/;"	f	class:psimag::Symmetry
appliedElements	PartialPsimag/Symmetry/GroupAction.h	/^    const AppliedSymmetryElementsType&       appliedElements; \/\/ an index into group$/;"	m	class:psimag::GroupAction
appliedElements	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    AppliedSymmetryElementsPtrType     appliedElements; \/\/ an index into group $/;"	m	class:psimag::GroupMultiplicationTable
appliedElements	PartialPsimag/Symmetry/SymmetryGroup.h	/^    const AppliedSymmetryElementsPtrType&    appliedElements; \/\/ kept in multiplication table, an index into group$/;"	m	class:psimag::SymmetryGroup
appliedSymmetryElements	PartialPsimag/Symmetry/Symmetry.h	/^    AppliedSymmetryElementsType appliedSymmetryElements;$/;"	m	class:psimag::Symmetry
areHexagonal	PartialPsimag/Symmetry/CellParameters.h	/^    bool areHexagonal()     const { return  close(a,b) && (close(alpha,60.0) || close(alpha,120.0)); }$/;"	f	class:psimag::CellParameters
areOblique	PartialPsimag/Symmetry/CellParameters.h	/^    bool areOblique()       const {$/;"	f	class:psimag::CellParameters
areRectangular	PartialPsimag/Symmetry/CellParameters.h	/^    bool areRectangular()   const { return !close(a,b) &&  close(alpha,90.0); }$/;"	f	class:psimag::CellParameters
areRhomboherdal	PartialPsimag/Symmetry/CellParameters.h	/^    bool areRhomboherdal()  const { return bSidedCenteredRectangle() || aSidedCenteredRectangle(); }$/;"	f	class:psimag::CellParameters
areSquare	PartialPsimag/Symmetry/CellParameters.h	/^    bool areSquare()        const { return  close(a,b) &&  close(alpha,90.0); }$/;"	f	class:psimag::CellParameters
assertKey	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void assertKey(std::wstring key) const {$/;"	f	class:JsonParser::Whatever
assertOkWhateverType	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void assertOkWhateverType(WhateverType t, std::string location) const {$/;"	f	class:JsonParser::Whatever
assertWhateverMap	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void assertWhateverMap(std::string moreMsg="") const {$/;"	f	class:JsonParser::Whatever
asymmetricUnitToXML	PartialPsimag/Symmetry/SpaceGroup2D.h	/^  Tag asymmetricUnitToXML(const SpaceGroup<Field,DIM,Occupant,Algorithms>& spaceGroup,$/;"	f	namespace:psimag
atEnd	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    bool                               atEnd;$/;"	m	class:psimag::AppliedSymmetryElementIterator
atOffset	PartialPsimag/Matrix.h	/^    T& atOffset(size_t offset)$/;"	f	class:psimag::Matrix
atOffset	PartialPsimag/Matrix.h	/^    const T& atOffset(size_t offset) const $/;"	f	class:psimag::Matrix
attributes	PartialPsimag/TagAttributeParser.h	/^    map<string,string>& attributes;$/;"	m	class:psimag::TagAttributeParser
attrs	PartialPsimag/TagAttributes.h	/^    std::map<std::string, std::string> attrs;$/;"	m	class:psimag::TagAttributes
axis	PartialPsimag/Symmetry/CellRotation.h	/^    CellDirection<Field, DIM> axis;$/;"	m	class:psimag::CellRotation
axisOrder	PartialPsimag/Symmetry/MetricTensor.h	/^  Vec<size_t, DIM > axisOrder(MetricTensor<Field,DIM> metric) {$/;"	f	namespace:psimag
b	PartialPsimag/Symmetry/CellParameters.h	/^    Field b;          \/**< The length of the next shortest translation vector. **\/$/;"	m	class:psimag::CellParameters
b	PartialPsimag/Symmetry/Glide2D.h	/^    static GlideType* b() { $/;"	f	class:psimag::Glide
b	PartialPsimag/Symmetry/Glide2D.h	/^    static GlideType* b(IN_TYPE shift) { $/;"	f	class:psimag::Glide
b	PartialPsimag/Symmetry/Mirror2D.h	/^    static MirrorType* b() { $/;"	f	class:psimag::Mirror
b	PartialPsimag/Symmetry/Mirror2D.h	/^    static MirrorType* b(IN_TYPE shift) { $/;"	f	class:psimag::Mirror
b	PsimagLite/src/ParametersForSolver.h	/^		RealType oneOverA,b;$/;"	m	struct:PsimagLite::ParametersForSolver
b	PsimagLite/src/TridiagonalMatrix.h	/^		FieldType& b(size_t i) { return b_[i]; }$/;"	f	class:PsimagLite::TridiagonalMatrix
b	PsimagLite/src/TridiagonalMatrix.h	/^		const FieldType& b(size_t i) const { return b_[i]; }$/;"	f	class:PsimagLite::TridiagonalMatrix
b	gap.h	/^		VectorType a,b,c;$/;"	m	class:rpa::gap
b	gaps2D.h	/^		VectorType a,b,c;$/;"	m	class:rpa::gap2D
b	momentumDomain.h	/^		MatrixType b;$/;"	m	class:rpa::momentumDomain
bSidedCenteredRectangle	PartialPsimag/Symmetry/CellParameters.h	/^    bool bSidedCenteredRectangle() const {$/;"	f	class:psimag::CellParameters
b_	PsimagLite/src/TridiagonalMatrix.h	/^		std::vector<FieldType> a_,b_;$/;"	m	class:PsimagLite::TridiagonalMatrix
back	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& back() {$/;"	f	class:JsonParser::Whatever
bands	PythonScripts/CoupledLadders.py	/^	def bands(self,kx,ky):$/;"	m	class:CoupledLadders
bands	PythonScripts/MayaVi_Plot_of_FS.py	/^bands=loadtxt("ek.dat")$/;"	v
bands	chi0.h	/^		BandsType& bands;$/;"	m	class:rpa::calcChi0Matrix
bands	ferminator.h	/^		BandsType bands;$/;"	m	class:rpa::ferminator
bands	pairing.h	/^		BandsType bands;$/;"	m	class:rpa::pairing
bandsAk	bands.h	/^		std::vector<ComplexMatrixType> bandsAk;$/;"	m	class:rpa::Bands
bandsEk	bands.h	/^		MatrixType bandsEk;$/;"	m	class:rpa::Bands
bandstructure	bandstructure.h	/^		bandstructure(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::bandstructure
bandstructure	bandstructure.h	/^	class bandstructure {$/;"	c	namespace:rpa
barrier	PsimagLite/src/Concurrency.h	/^		void barrier() { }$/;"	f	class:PsimagLite::Concurrency
barrier	PsimagLite/src/ConcurrencyMpi.h	/^		void barrier(CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
barrier	PsimagLite/src/ConcurrencySerial.h	/^		void barrier() { }$/;"	f	class:PsimagLite::ConcurrencySerial
bathSitesPerSite_	PsimagLite/src/Geometry/LadderBath.h	/^			size_t bathSitesPerSite_;$/;"	m	class:PsimagLite::LadderBath
bcTest	parameters.h	/^			void bcTest() {$/;"	f	class:rpa::parameters
before_comment_state	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    StateType            before_comment_state;$/;"	m	class:JsonParser::JsonParser
begin	PartialPsimag/Matrix.h	/^    const_iterator begin() const { return data; }$/;"	f	class:psimag::Matrix
begin	PartialPsimag/Matrix.h	/^    iterator       begin() { return data; }$/;"	f	class:psimag::Matrix
begin	PartialPsimag/TagAttributes.h	/^    const_iterator begin() const { return attrs.begin(); }$/;"	f	class:psimag::TagAttributes
begin	PartialPsimag/Vec.h	/^    const_iterator begin() const { return &(d[0]); }$/;"	f	class:psimag::Vec
begin	PartialPsimag/Vec.h	/^    iterator begin() { return &(d[0]); }$/;"	f	class:psimag::Vec
beginObjectOrArray	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void beginObjectOrArray() {$/;"	f	class:JsonParser::DefaultContext
beginOperations	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    beginOperations(const Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>& symmetry) {$/;"	f	class:psimag::SpaceGroup
beta	PartialPsimag/Symmetry/CellParameters.h	/^    Field beta;       \/**< The angle between a and c. **\/$/;"	m	class:psimag::CellParameters
beta	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  beta()      const { return acos(cos_beta())*180.0\/PI; }$/;"	f	class:psimag::MetricTensor
bisector	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,DIM> bisector(const SeitzPosition<Field,DIM>& p1, $/;"	f	namespace:psimag
blockInputOps	PsimagLite/src/Rusage.h	/^		long blockInputOps() const { return rusage_.ru_inblock; }$/;"	f	class:PsimagLite::Rusage
blockOutputOps	PsimagLite/src/Rusage.h	/^		long blockOutputOps() const { return rusage_.ru_oublock; }$/;"	f	class:PsimagLite::Rusage
blockSize	PsimagLite/src/Pthreads.h	/^	size_t blockSize;$/;"	m	struct:PthreadFunctionStruct
bools	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, bool>                          bools;$/;"	m	class:dca::JSN
broadcast	PsimagLite/src/Concurrency.h	/^		void broadcast(DataType &v) { }$/;"	f	class:PsimagLite::Concurrency
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(bool& b,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(double& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(int& i,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(psimag::Matrix<double>& m,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(psimag::Matrix<std::complex<double> >& m,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(size_t& i,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(std::string& s,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(std::vector<double>& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencyMpi.h	/^		void broadcast(std::vector<int>& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
broadcast	PsimagLite/src/ConcurrencySerial.h	/^		void broadcast(DataType &v,CommType mpiComm=COMM_WORLD) { }$/;"	f	class:PsimagLite::ConcurrencySerial
broadcastParam	parameters.h	/^			void broadcastParam() {$/;"	f	class:rpa::parameters
buffer	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    ParseBuffer           buffer;$/;"	m	class:JsonParser::JsonParser
build	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    void build()$/;"	f	class:psimag::GroupMultiplicationTable
buildDenseMatrix	PsimagLite/src/ChebyshevSolver.h	/^		void buildDenseMatrix( Matrix<VectorElementType>& T,const TridiagonalMatrixType& ab) const$/;"	f	class:PsimagLite::ChebyshevSolver
buildDenseMatrix	PsimagLite/src/LanczosSolver.h	/^		void buildDenseMatrix(DenseMatrixType& T,const TridiagonalMatrixType& ab) const$/;"	f	class:PsimagLite::LanczosSolver
buildDenseMatrix	PsimagLite/src/TridiagonalMatrix.h	/^		void buildDenseMatrix(SomeMatrixType& m) const$/;"	f	class:PsimagLite::TridiagonalMatrix
buildDiffIndex	PartialPsimag/Symmetry/Pattern.h	/^    void buildDiffIndex(Matrix<int>& diffIndex) const {$/;"	f	class:psimag::Pattern
buildGroup	PartialPsimag/Symmetry/Star.h	/^    void buildGroup(const SymmetryType& symmetry) {$/;"	f	class:psimag::Star
buildGroupAction	PartialPsimag/Symmetry/Star.h	/^    void buildGroupAction(const SymmetryType& symmetry) {$/;"	f	class:psimag::Star
buildMultiplicationTable	PartialPsimag/Symmetry/Star.h	/^    void buildMultiplicationTable(const SymmetryType& symmetry) {$/;"	f	class:psimag::Star
buildPlusIndex	PartialPsimag/Symmetry/Pattern.h	/^    void buildPlusIndex(Matrix<int>& plusIndex) const {$/;"	f	class:psimag::Pattern
c	PartialPsimag/Symmetry/CellParameters.h	/^    Field c;          \/**< The length of the       longest translation vector. **\/$/;"	m	class:psimag::CellParameters
c	PythonScripts/plotChiRPAAlongHighSym.py	/^	import calcAndPlotRPAChiQ as c$/;"	i
c	gap.h	/^		VectorType a,b,c;$/;"	m	class:rpa::gap
c	gaps2D.h	/^		VectorType a,b,c;$/;"	m	class:rpa::gap2D
cMatrices	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, const psimag::Matrix<std::complex<double> >*> cMatrices;$/;"	m	class:dca::JSN
cacheBands	parameters.h	/^		bool cacheBands;$/;"	m	class:rpa::parameters
cacheValues	PsimagLite/src/Geometry/GeometryTerm.h	/^			void cacheValues()$/;"	f	class:PsimagLite::GeometryTerm
cachedK	bandstructure.h	/^		std::vector<bool> cachedK;$/;"	m	class:rpa::bandstructure
cachedValues_	PsimagLite/src/Geometry/GeometryTerm.h	/^			PsimagLite::Matrix<RealType> cachedValues_;$/;"	m	class:PsimagLite::GeometryTerm
caching_	bandstructure.h	/^		bool caching_;$/;"	m	class:rpa::bandstructure
calcBandStructure	bandstructure.h	/^		void calcBandStructure(std::string file,bool printOccupation) {$/;"	f	class:rpa::bandstructure
calcBands	main.cpp	/^void calcBands(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param, ModelType& model, ConcurrencyType& conc) {$/;"	f
calcBandsK	bands.h	/^		inline void calcBandsK(const VectorType& k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::Bands
calcBandsK1	bands.h	/^		inline void calcBandsK1(const VectorType& k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::Bands
calcBandsKMesh	bands.h	/^		void calcBandsKMesh(const size_t nk, const size_t nkz, const size_t dim,$/;"	f	class:rpa::Bands
calcChi0	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcChi0(self,q,qz,wm):$/;"	m	class:RPA
calcChi0	PythonScripts/Sr2RuO4.py	/^        def calcChi0(self,q):$/;"	m	class:RPA
calcChi0Matrix	chi0.h	/^		calcChi0Matrix(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::calcChi0Matrix
calcChi0Matrix	chi0.h	/^	class calcChi0Matrix {$/;"	c	namespace:rpa
calcChi0q	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcChi0q(self):$/;"	m	class:RPA
calcChi0q	PythonScripts/Sr2RuO4.py	/^        def calcChi0q(self):$/;"	m	class:RPA
calcChi0q	chi0.h	/^		void calcChi0q() {$/;"	f	class:rpa::chi0q
calcChiNematicRPA	susceptibility.h	/^		ComplexType calcChiNematicRPA(ComplexMatrixType& chiC) {$/;"	f	class:rpa::susceptibility
calcChiRPAFromGammaRPA	rpa_CuO.h	/^		void calcChiRPAFromGammaRPA(ComplexMatrixType& Gamma, size_t interactionType, std::vector<Field>& q,$/;"	f	class:rpa::interactionEmery
calcChiSRPA	susceptibility.h	/^		ComplexType calcChiSRPA(ComplexMatrixType& chiS) {$/;"	f	class:rpa::susceptibility
calcDOS	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcDOS(self,nw=1001):$/;"	m	class:RPA
calcDeltaKF	ferminator.h	/^	FieldType calcDeltaKF(const FieldType& kFx, const FieldType& kFy, const FieldType& kFz,$/;"	f	class:rpa::ferminator
calcDeltaKF	ferminator.h	/^	void calcDeltaKF(const VectorType& kFx,const VectorType& kFy, VectorType& deltakF) {$/;"	f	class:rpa::ferminator
calcDeltaKF2D	ferminator.h	/^	void calcDeltaKF2D() {$/;"	f	class:rpa::ferminator
calcDeltaKFOpen2D	ferminator.h	/^	void calcDeltaKFOpen2D() {$/;"	f	class:rpa::ferminator
calcDir	PsimagLite/src/Geometry/Chain.h	/^			size_t calcDir(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Chain
calcDir	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t calcDir(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::GeometryFactory
calcDir	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t calcDir(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::KTwoNiFFour
calcDir	PsimagLite/src/Geometry/Ladder.h	/^		size_t calcDir(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Ladder
calcDir	PsimagLite/src/Geometry/LadderBath.h	/^			size_t calcDir(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderBath
calcDir	PsimagLite/src/Geometry/LadderX.h	/^			size_t calcDir(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderX
calcDirInCluster	PsimagLite/src/Geometry/LadderBath.h	/^			size_t calcDirInCluster(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderBath
calcEigen	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcEigen(self):$/;"	m	class:RPA
calcEigenVectors	pairing.h	/^	void calcEigenVectors() {$/;"	f	class:rpa::pairing
calcElements	susceptibility.h	/^		void calcElements(VectorSuscType& chi0Matrix) {$/;"	f	class:rpa::susceptibility
calcEmeryChi0	susceptibility.h	/^		void calcEmeryChi0(std::vector<ComplexMatrixType>& chi0,$/;"	f	class:rpa::susceptibility
calcEmeryRPA	susceptibility.h	/^		void calcEmeryRPA(std::vector<ComplexMatrixType>& chi0,$/;"	f	class:rpa::susceptibility
calcF	PsimagLite/src/ChebyshevSerializer.h	/^		RealType calcF(const RealType& x,const std::vector<RealType>& gnmn) const$/;"	f	class:PsimagLite::ChebyshevSerializer
calcGammaFromChiRPA	rpa_CuO.h	/^		void calcGammaFromChiRPA(ComplexMatrixType& V_bare, ComplexMatrixType& V_coupl, $/;"	f	class:rpa::interactionEmery
calcGammaPP	pairing.h	/^		void calcGammaPP() {$/;"	f	class:rpa::pairing
calcGammaPPBand	pairing.h	/^		void calcGammaPPBand(const ComplexMatrixType& gammaOrb, $/;"	f	class:rpa::pairing
calcGammaPPEmery	pairing.h	/^		void calcGammaPPEmery(std::vector<FieldType> q, $/;"	f	class:rpa::pairing
calcGammaPPOrb	pairing.h	/^		void calcGammaPPOrb(const ComplexMatrixType& usc0us,$/;"	f	class:rpa::pairing
calcGammaPPOrbEmery	pairing.h	/^		void calcGammaPPOrbEmery(ComplexMatrixType& GammaS, ComplexMatrixType& GammaC, $/;"	f	class:rpa::pairing
calcGammaPPTerms	pairing.h	/^		void calcGammaPPTerms(size_t ind,std::vector<FieldType> q, $/;"	f	class:rpa::pairing
calcIndexOfAdd	momentumDomain.h	/^		size_t calcIndexOfAdd(const size_t i1, const size_t i2) {$/;"	f	class:rpa::momentumDomain
calcInverse	utilities.h	/^inline void calcInverse(MType& matrix) {$/;"	f
calcKF	ferminator.h	/^	void calcKF(const size_t nkSearch,const size_t iSheet, const FieldType& kz,int dim) {$/;"	f	class:rpa::ferminator
calcKFOpen2D	ferminator.h	/^	void calcKFOpen2D(const size_t nkSearch, const size_t iSheet, const size_t scanAlongDir) {$/;"	f	class:rpa::ferminator
calcLambda	PythonScripts/Calc_lambda.py	/^def calcLambda(fileID=""):$/;"	f
calcLambdaZ	parameters.h	/^		bool calcLambdaZ;$/;"	m	class:rpa::parameters
calcMatrix	chi0Ofq.h	/^		void calcMatrix(const size_t iq, ComplexMatrixType& matrix) {$/;"	f	class:rpa::chi0ofq
calcNorm	pairing.h	/^		void calcNorm() {$/;"	f	class:rpa::pairing
calcOW_	ferminator.h	/^		bool calcOW_;$/;"	m	class:rpa::ferminator
calcOnlyDiagonal	parameters.h	/^		bool calcOnlyDiagonal;$/;"	m	class:rpa::parameters
calcOnlyDiagonal_	chi0.h	/^		bool calcOnlyDiagonal_;$/;"	m	class:rpa::calcChi0Matrix
calcPAofT	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcPAofT(self,w0=0.5):$/;"	m	class:RPA
calcPairing	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcPairing(self):$/;"	m	class:RPA
calcPairingStrength	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcPairingStrength(self):$/;"	m	class:RPA
calcPartialLambda	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcPartialLambda(self):$/;"	m	class:RPA
calcRPAResult	rpa.h	/^		void calcRPAResult(ComplexMatrixType& matrix0, $/;"	f	class:rpa::interaction
calcRPAResult	rpa_CuO.h	/^		void calcRPAResult(ComplexMatrixType& chi0, $/;"	f	class:rpa::interactionEmery
calcRPAResult	utilities.h	/^void calcRPAResult(MatrixTemplate<std::complex<FieldType> >& matrix0, $/;"	f
calcSCGap	coupledLadders.h	/^		std::complex<Field> calcSCGap(VectorType& k, size_t band, ComplexMatrixType& Uk) {$/;"	f	class:rpa::model
calcSCGap	singleBand.h	/^		std::complex<Field> calcSCGap(VectorType& k, size_t band, ComplexMatrixType& Uk) {$/;"	f	class:rpa::model
calcSus	1band_wSpin.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::SingleBand_wSpin
calcSus	BSCCObilayer.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcSus	SrRuO_SO.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcSus	bilayer.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcSus	bilayerFESC.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcSus	chi0.h	/^		std::complex<Field> calcSus() const {$/;"	f	class:rpa::susc
calcSus	coupledLadders.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcSus	orthoIIBilayer.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcSus	singleBand.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcSus	tbFromFile.h	/^		std::complex<Field> calcSus(const ComplexMatrixType& sus, const std::string& component = "zz") const {$/;"	f	class:rpa::model
calcValue	PsimagLite/src/Geometry/GeometryTerm.h	/^			RealType calcValue(size_t i1,size_t edof1,size_t i2,size_t edof2) const$/;"	f	class:PsimagLite::GeometryTerm
calcVkF	ferminator.h	/^	FieldType calcVkF(const FieldType& kFx, const FieldType& kFy, const FieldType& kFz,$/;"	f	class:rpa::ferminator
calcVkFz	ferminator.h	/^	FieldType calcVkFz(const FieldType& kFx, const FieldType& kFy, const FieldType& kFz,$/;"	f	class:rpa::ferminator
calcVprojected	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calcVprojected(self,rpa=True):$/;"	m	class:RPA
calcWeights	ferminator.h	/^	void calcWeights(const size_t ic) {$/;"	f	class:rpa::ferminator
calcZofk	pairing.h	/^	void calcZofk() {$/;"	f	class:rpa::pairing
calc_vkF	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def calc_vkF(self):$/;"	m	class:RPA
calcgammaB1GkF	ferminator.h	/^	FieldType calcgammaB1GkF(const FieldType& kFx, const FieldType& kFy, const FieldType& kFz,$/;"	f	class:rpa::ferminator
calculateBandTensors	bandstructure.h	/^		void calculateBandTensors(VectorType& k_, $/;"	f	class:rpa::bandstructure
calculateD	PsimagLite/src/AkimaSpline.h	/^		void calculateD(VectorType& d,const VectorType& x,const VectorType& s) const$/;"	f	class:AkimaSpline
calculateSprime	PsimagLite/src/AkimaSpline.h	/^		void calculateSprime(VectorType& sprime,const VectorType& x,const VectorType& s) const$/;"	f	class:AkimaSpline
calculateW	PsimagLite/src/AkimaSpline.h	/^		void calculateW(VectorType& w,const VectorType& d) const$/;"	f	class:AkimaSpline
calculate_ek_grid	PythonScripts/Sr2RuO4.py	/^        def calculate_ek_grid(self,kgrid):$/;"	m	class:RPA
caller_	PsimagLite/src/ProgressIndicator.h	/^		std::string caller_;$/;"	m	class:PsimagLite::ProgressIndicator
cartesian	PartialPsimag/Symmetry/Lattice.h	/^    CartesianPositionType cartesian(const CellPosition<OtherField,DIM,Algorithms>& pos) const {$/;"	f	class:psimag::Lattice
cartesianAsymmetricUnitVerticies	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    std::vector<CartesianPosition<Field,DIM> >  cartesianAsymmetricUnitVerticies(const LatticeTemplate<Field,DIM,Algorithms>& lat) const {$/;"	f	class:psimag::SpaceGroup
cartesianPosition	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    CartesianPositionType                     cartesianPosition;$/;"	m	class:psimag::AppliedSymmetryElement
cartesianPosition	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    CartesianPositionType    cartesianPosition;$/;"	m	class:psimag::AppliedSymmetryElement
cartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^  CartesianPosition<Field,2> cartesianPosition(IN_TYPE c0, IN_TYPE c1) {$/;"	f	namespace:psimag
cartesianPosition	PartialPsimag/Symmetry/CartesianPosition.h	/^  CartesianPosition<Field,3> cartesianPosition(IN_TYPE c0, IN_TYPE c1, IN_TYPE c2) {$/;"	f	namespace:psimag
cartesianPosition	PartialPsimag/Symmetry/Lattice.h	/^    CartesianPositionType cartesianPosition(const CellPosition<OtherField,DIM,Algorithms>& pos) const {$/;"	f	class:psimag::Lattice
cartesianPosition	PartialPsimag/Symmetry/Lattice.h	/^    CartesianPositionType cartesianPosition(const CellTranslation<OtherField,DIM>& trns) const {$/;"	f	class:psimag::Lattice
cartesianPositions	PartialPsimag/Symmetry/Pattern.h	/^    CartPositionsType       cartesianPositions;$/;"	m	class:psimag::Pattern
cartesianRotation	PartialPsimag/Symmetry/CellRotation.h	/^    CartesianRotation<Field, DIM> cartesianRotation(Lattice<In_Field,DIM,Algorithms> cell) {$/;"	f	class:psimag::CellRotation
cartesianTranslation	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    CartesianTranslationType                  cartesianTranslation;$/;"	m	class:psimag::AppliedSymmetryElement
cartesianTranslation	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    CartesianTranslationType cartesianTranslation;$/;"	m	class:psimag::AppliedSymmetryElement
cartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^  CartesianTranslation<Field,2> cartesianTranslation(IN_TYPE c0, IN_TYPE c1) {$/;"	f	namespace:psimag
cartesianTranslation	PartialPsimag/Symmetry/CartesianTranslation.h	/^  CartesianTranslation<Field,3> cartesianTranslation(IN_TYPE c0, IN_TYPE c1, IN_TYPE c2) {$/;"	f	namespace:psimag
cartesianTranslation	PartialPsimag/Symmetry/Lattice.h	/^    CartesianTranslationType cartesianTranslation(const CellPositionType& pos) const {$/;"	f	class:psimag::Lattice
cartesianTranslation	PartialPsimag/Symmetry/Lattice.h	/^    CartesianTranslationType cartesianTranslation(const CellTranslationType& trns) const {$/;"	f	class:psimag::Lattice
cartesianTranslation	PartialPsimag/Symmetry/Lattice.h	/^    CartesianTranslationType cartesianTranslation(const LatticeCoordinates<DIM>& latCoord) const {$/;"	f	class:psimag::Lattice
cartesianTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^    CartesianTranslation<Field,DIM> cartesianTranslation(Lattice<Field,DIM,Algorithms> lat) {$/;"	f	class:psimag::LatticeTranslation
cartesianTranslation	PartialPsimag/Symmetry/Pattern.h	/^    CartesianTranslationType cartesianTranslation(size_t posIndex) const {$/;"	f	class:psimag::Pattern
cc	Makefile	/^cc                   = mpicxx$/;"	m
cc	PsimagLite/src/JSON/JsonParser/Makefile	/^cc                   = gcc$/;"	m
cellContains	PartialPsimag/Symmetry/Lattice.h	/^    bool cellContains(const CartesianPositionType& cartPos) const {$/;"	f	class:psimag::Lattice
cellContains	PartialPsimag/Symmetry/Lattice.h	/^    bool cellContains(const CellPositionType& cellPos) const {$/;"	f	class:psimag::Lattice
cellDirection	PartialPsimag/Symmetry/CellDirection.h	/^  CellDirection<Field,2> cellDirection(IN_TYPE x, IN_TYPE y) {$/;"	f	namespace:psimag
cellDirection	PartialPsimag/Symmetry/CellDirection.h	/^  CellDirection<Field,3> cellDirection(IN_TYPE x, IN_TYPE y, IN_TYPE z) {$/;"	f	namespace:psimag
cellNewToOrig	PartialPsimag/Symmetry/LatticeTransformation.h	/^    MatrixType cellNewToOrig;$/;"	m	class:psimag::LatticeTransformation
cellOperation	PartialPsimag/Symmetry/Lattice.h	/^    void cellOperation(const SymmetryOperation<Field,DIM,Algorithms>& cartesianSymop,  $/;"	f	class:psimag::Lattice
cellOrigToNew	PartialPsimag/Symmetry/LatticeTransformation.h	/^    MatrixType cellOrigToNew;$/;"	m	class:psimag::LatticeTransformation
cellPosition	PartialPsimag/Symmetry/CellPosition.h	/^  CellPosition<Field,2,Algorithms> cellPosition(Field x, Field y) {$/;"	f	namespace:psimag
cellPosition	PartialPsimag/Symmetry/CellPosition.h	/^  CellPosition<Field,2,Algorithms> cellPosition(IN_TYPE t0, IN_TYPE t1) {$/;"	f	namespace:psimag
cellPosition	PartialPsimag/Symmetry/CellPosition.h	/^  CellPosition<Field,3,Algorithms> cellPosition(Field x, Field y, Field z) {$/;"	f	namespace:psimag
cellPosition	PartialPsimag/Symmetry/CellPosition.h	/^  CellPosition<Field,3,Algorithms> cellPosition(IN_TYPE t0, IN_TYPE t1, IN_TYPE t2) {$/;"	f	namespace:psimag
cellPosition	PartialPsimag/Symmetry/Lattice.h	/^    CellPosition<Field,DIM,Algorithms> cellPosition(const CartesianPositionType& pos) const {$/;"	f	class:psimag::Lattice
cellPosition	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    CellPosition<Field,DIM,Algorithms> cellPosition() const {$/;"	f	class:psimag::LatticeCoordinates
cellPosition	PartialPsimag/Symmetry/SymmetryElement.h	/^    CellPositionType        cellPosition;$/;"	m	class:psimag::SymmetryElement
cellPositions	PartialPsimag/Symmetry/Pattern.h	/^    CellPositionsType       cellPositions;$/;"	m	class:psimag::Pattern
cellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^  CellTranslation<Field,2> cellTranslation(IN_TYPE t0, IN_TYPE t1) {$/;"	f	namespace:psimag
cellTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^  CellTranslation<Field,3> cellTranslation(IN_TYPE t0, IN_TYPE t1, IN_TYPE t2) {$/;"	f	namespace:psimag
cellTranslation	PartialPsimag/Symmetry/Lattice.h	/^    CellTranslationType cellTranslation(const CartesianTranslationType& t) const {$/;"	f	class:psimag::Lattice
cellTranslation	PartialPsimag/Symmetry/Lattice.h	/^    CellTranslationType cellTranslation(const LatticeCoordinates<DIM>& latCoord, Field factor) const {$/;"	f	class:psimag::Lattice
cellTranslation	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    CellTranslation<Field,DIM> cellTranslation() const {$/;"	f	class:psimag::LatticeCoordinates
cellTranslation	PartialPsimag/Symmetry/Pattern.h	/^    CellTranslationType cellTranslation(size_t posIndex) const {$/;"	f	class:psimag::Pattern
centered	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    bool                                    centered;$/;"	m	class:psimag::SpaceGroup
centering	PartialPsimag/Symmetry/ConventionalLattice.h	/^    CenteringBase<Field,DIM> centering;$/;"	m	class:psimag::ConventionalLattice
chain_	PsimagLite/src/Geometry/GeometryFactory.h	/^		Chain* chain_;$/;"	m	class:PsimagLite::GeometryFactory
chargeFactor	parameters.h	/^		Field staticUFactor,chargeFactor,spinFactor;$/;"	m	class:rpa::parameters
chargeMatrix	1band_wSpin.h	/^		ComplexMatrixType   chargeMatrix;$/;"	m	class:rpa::SingleBand_wSpin
chargeMatrix	BSCCObilayer.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chargeMatrix	SrRuO_SO.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chargeMatrix	bilayer.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chargeMatrix	bilayerFESC.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chargeMatrix	coupledLadders.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chargeMatrix	orthoIIBilayer.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chargeMatrix	singleBand.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chargeMatrix	tbFromFile.h	/^		ComplexMatrixType chargeMatrix;$/;"	m	class:rpa::model
chebyshev_	PsimagLite/src/ChebyshevSerializer.h	/^		ChebyshevFunction<RealType> chebyshev_;$/;"	m	class:PsimagLite::ChebyshevSerializer
check	PartialPsimag/Symmetry/CartesianRotation.h	/^    void check() {$/;"	f	class:psimag::CartesianRotation
check	PartialPsimag/Symmetry/CellRotation.h	/^    void check() {$/;"	f	class:psimag::CellRotation
check	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void check() {$/;"	f	class:psimag::HermiteNormalForm
check	PartialPsimag/Symmetry/SymmetryOperation.h	/^    void check() {$/;"	f	class:psimag::SymmetryOperation
checkAppliedElements	PartialPsimag/Symmetry/Symmetry.h	/^    void checkAppliedElements() {}$/;"	f	class:psimag::Symmetry
checkDirection	PartialPsimag/Symmetry/SymmetryElement.h	/^    void checkDirection() const {$/;"	f	class:psimag::SymmetryElement
checkError	PsimagLite/src/ConcurrencyMpi.h	/^		void checkError(int x,const std::string& s)$/;"	f	class:PsimagLite::ConcurrencyMpi
checkTrailingWhite	PsimagLite/scripts/indentStrict.pl	/^sub checkTrailingWhite$/;"	s
chi0	pairing.h	/^		SuscType chi0;$/;"	m	class:rpa::pairing
chi0c	pairing.h	/^		SuscType chi0c;$/;"	m	class:rpa::pairing
chi0k	chi0.h	/^		VectorType chi0k;$/;"	m	class:rpa::calcChi0Matrix
chi0matrix	chi0Ofq.h	/^		ComplexMatrixType chi0matrix;$/;"	m	class:rpa::chi0ofq
chi0ofq	chi0Ofq.h	/^		chi0ofq(const rpa::parameters<Field,MatrixTemplate>& parameters, const rpa::greensFunction<Field,MatrixTemplate,ConcurrencyType>& green, ConcurrencyType& concurrency):$/;"	f	class:rpa::chi0ofq
chi0ofq	chi0Ofq.h	/^	class chi0ofq$/;"	c	namespace:rpa
chi0q	chi0.h	/^		chi0q(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::chi0q
chi0q	chi0.h	/^	class chi0q:$/;"	c	namespace:rpa
chi0s	pairing.h	/^		SuscType chi0s;$/;"	m	class:rpa::pairing
chiRPAc	pairing.h	/^		SuscType chiRPAc;$/;"	m	class:rpa::pairing
chiRPAs	pairing.h	/^		SuscType chiRPAs;$/;"	m	class:rpa::pairing
chiStore	pairing.h	/^		std::vector<SuscType> chiStore;$/;"	m	class:rpa::pairing
chia1	parameters.h	/^		std::vector<Field> chia1,chia2,chia3;$/;"	m	class:rpa::parameters
chia2	parameters.h	/^		std::vector<Field> chia1,chia2,chia3;$/;"	m	class:rpa::parameters
chia3	parameters.h	/^		std::vector<Field> chia1,chia2,chia3;$/;"	m	class:rpa::parameters
chifile	parameters.h	/^		std::string chifile;$/;"	m	class:rpa::parameters
chikk	pairing.h	/^		MatrixType chikk;$/;"	m	class:rpa::pairing
chiq	chi0Ofq.h	/^		std::vector<Field> chiq;$/;"	m	class:rpa::chi0ofq
circleCheck	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    bool circleCheck() {$/;"	f	class:psimag::AppliedSymmetryElement
circleCheck	PartialPsimag/Symmetry/SymmetryElement.h	/^    bool circleCheck(const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::SymmetryElement
circleCheck	PartialPsimag/Symmetry/SymmetryElement.h	/^    bool circleCheck(const SymmetryOperationType&         operation, $/;"	f	class:psimag::SymmetryElement
classes	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    typedef enum classes {$/;"	g	class:JsonParser::CharacterMapper
classify	PartialPsimag/Symmetry/SpaceGroupConstructor.h	/^    static void classify(ConventionalCrystal<Field, DIM, Occupant, Algorithms>& structure) {$/;"	f	class:psimag::SpaceGroupConstructor
classify	PartialPsimag/Symmetry/SpaceGroupConstructor2D.h	/^    static void classify(Crystal<Field, 2, Occupant, ConventionalLattice, Algorithms>& structure) {$/;"	f	class:psimag::SpaceGroupConstructor
clear	PsimagLite/src/CrsMatrix.h	/^		void clear()$/;"	f	class:PsimagLite::CrsMatrix
clear	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^    void clear() {$/;"	f	class:JsonParser::ParseBuffer
close	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  static bool close(const Field v1, const Field v2) { $/;"	f	class:psimag::BasicCrystalAlgorithms
close	PartialPsimag/Symmetry/CellParameters.h	/^    static bool close(Field v1, Field v2) {$/;"	f	class:psimag::CellParameters
close	PartialPsimag/Symmetry/ReducedLattice.h	/^    static bool close(const Field v1, const Field v2) {$/;"	f	class:psimag::ReducedLattice
close	PsimagLite/src/IoSimple.h	/^				void close() $/;"	f	class:PsimagLite::IoSimple::In
close	PsimagLite/src/IoSimple.h	/^			void close()$/;"	f	class:PsimagLite::IoSimple::Out
closeTo	PartialPsimag/Symmetry/CellPosition.h	/^    bool closeTo (const CellPositionType& other) const {$/;"	f	class:psimag::CellPosition
closeTo	PartialPsimag/Symmetry/CellTranslation.h	/^  bool closeTo(const SeitzVector<Field,DIM,IND>& v1,$/;"	f	namespace:psimag
clsName	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^     static std::string clsName(CharacterClass cls) {$/;"	f	class:JsonParser::CharacterMapper
clusterSize_	PsimagLite/src/Geometry/LadderBath.h	/^			size_t clusterSize_;$/;"	m	class:PsimagLite::LadderBath
col	PartialPsimag/Matrix.h	/^    T** col;$/;"	m	class:psimag::Matrix
colIndices	PartialPsimag/IndexedMatrix.h	/^    IndexType                   colIndices;$/;"	m	class:psimag::IndexedMatrix
colind_	PsimagLite/src/CrsMatrix.h	/^		std::vector<int> colind_;$/;"	m	class:PsimagLite::CrsMatrix
colind_	PsimagLite/src/SampleCRSMatrix.h	/^		std::vector<size_t> colind_;$/;"	m	class:PsimagLite::SampleCRSMatrix
collectName	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void collectName(std::wostringstream& nam) const {$/;"	f	class:JsonParser::Whatever
color	PartialPsimag/Symmetry/Occupant.h	/^    std::string color;$/;"	m	class:psimag::Occupant
cols_	PsimagLite/src/SparseRow.h	/^		ColumnsType cols_;$/;"	m	class:PsimagLite::SparseRow
combineRows	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void combineRows(Field a, size_t r1, size_t r2) {$/;"	f	class:psimag::HermiteNormalForm
comment	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    bool                 comment; $/;"	m	class:JsonParser::JsonParser
comment_begin_offset	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    size_t               comment_begin_offset;$/;"	m	class:JsonParser::JsonParser
compareAxisPositions	PartialPsimag/Symmetry/MetricTensor.h	/^    bool compareAxisPositions ( const size_t& i, const size_t& j) const {$/;"	f	class:psimag::MetricTensor
complexHopping	parameters.h	/^		bool complexHopping;$/;"	m	class:rpa::parameters
complex_value_type	PartialPsimag/RealPart.h	/^    typedef typename ComplexMatrixLikeType::value_type              complex_value_type;$/;"	t	class:psimag::RealPart
computeA	PsimagLite/src/LinearPrediction.h	/^		void computeA(MatrixType& A) const$/;"	f	class:PsimagLite::LinearPrediction
computeAandB	PsimagLite/src/ChebyshevSolver.h	/^		void computeAandB()$/;"	f	class:PsimagLite::ChebyshevSolver
computeB	PsimagLite/src/LinearPrediction.h	/^		void computeB(std::vector<FieldType>& B) const$/;"	f	class:PsimagLite::LinearPrediction
computeD	PsimagLite/src/LinearPrediction.h	/^		void computeD(MatrixType& A,std::vector<FieldType>& B)$/;"	f	class:PsimagLite::LinearPrediction
computeGnMuN	PsimagLite/src/ChebyshevSerializer.h	/^		void computeGnMuN( std::vector<RealType>& gnmn,std::vector<RealType>& gn) const$/;"	f	class:PsimagLite::ChebyshevSerializer
computeGroundState	PsimagLite/src/ChebyshevSolver.h	/^		void computeGroundState(RealType &gsEnergy,$/;"	f	class:PsimagLite::ChebyshevSolver
computeGroundState	PsimagLite/src/ChebyshevSolver.h	/^		void computeGroundState(RealType& gsEnergy,VectorType& z)$/;"	f	class:PsimagLite::ChebyshevSolver
computeGroundState	PsimagLite/src/LanczosSolver.h	/^		void computeGroundState(RealType &gsEnergy,$/;"	f	class:PsimagLite::LanczosSolver
computeGroundState	PsimagLite/src/LanczosSolver.h	/^		void computeGroundState(RealType& gsEnergy,VectorType& z)$/;"	f	class:PsimagLite::LanczosSolver
computeGroundStateTest	PsimagLite/src/ChebyshevSolver.h	/^		void computeGroundStateTest(RealType &gsEnergy,$/;"	f	class:PsimagLite::ChebyshevSolver
computeGroundStateTest	PsimagLite/src/LanczosSolver.h	/^		void computeGroundStateTest(RealType &gsEnergy,$/;"	f	class:PsimagLite::LanczosSolver
computeIndependence	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    bool computeIndependence;$/;"	m	class:psimag::BackSubstitution
computeLength	PsimagLite/scripts/functionSigIndent.pl	/^sub computeLength$/;"	s
computeM	chi0.h	/^	inline ComplexType computeM(size_t l1,size_t l2,size_t l3,size_t l4, size_t band1,size_t band2,$/;"	f	class:rpa::calcChi0Matrix
computeSolution	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    bool computeSolution;$/;"	m	class:psimag::BackSubstitution
conc	1band_wSpin.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::SingleBand_wSpin
conc	4Orbital.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::FourOrbital
conc	BSCCObilayer.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
conc	BaFeAs_5orb.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::BaFeAs
conc	FourOrbital.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::FourOrbital
conc	KFe2Se2.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::KFe2Se2
conc	SrRuO.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::SrRuO
conc	SrRuO_SO.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
conc	bands.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::Bands
conc	bandstructure.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::bandstructure
conc	bilayer.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
conc	bilayerFESC.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
conc	chi0.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::calcChi0Matrix
conc	chi0.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::chi0q
conc	chi0.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::susc
conc	chi0Ofq.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::chi0ofq
conc	coupledLadders.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
conc	ferminator.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::ferminator
conc	gap.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::gap
conc	gaps2D.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::gap2D
conc	gaps3D.h	/^        ConcurrencyType& conc;$/;"	m	class:rpa::gap3D
conc	momentumDomain.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::momentumDomain
conc	orthoIIBilayer.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
conc	pairing.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::pairing
conc	parameters.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::parameters
conc	rpa.h	/^			ConcurrencyType& conc;$/;"	m	class:rpa::interaction
conc	sepBasis.h	/^			ConcurrencyType& conc;$/;"	m	class:rpa::sepBasis
conc	singleBand.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
conc	susceptibility.h	/^			ConcurrencyType& conc;$/;"	m	class:rpa::susceptibility
conc	tbFromFile.h	/^		ConcurrencyType& conc;$/;"	m	class:rpa::model
concurrency_	PsimagLite/src/Range.h	/^		ConcurrencyType& concurrency_;$/;"	m	class:PsimagLite::Range
conj	PsimagLite/src/Complex.h	/^	double conj(double t) { return t; }$/;"	f	namespace:std
connected	PsimagLite/src/Geometry/Chain.h	/^			bool connected(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Chain
connected	PsimagLite/src/Geometry/Geometry.h	/^			bool connected(size_t smax,size_t emin,size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Geometry
connected	PsimagLite/src/Geometry/GeometryFactory.h	/^		bool connected(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::GeometryFactory
connected	PsimagLite/src/Geometry/GeometryTerm.h	/^			bool connected(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::GeometryTerm
connected	PsimagLite/src/Geometry/GeometryTerm.h	/^			bool connected(size_t smax,size_t emin,size_t i1,size_t i2) const$/;"	f	class:PsimagLite::GeometryTerm
connected	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		bool connected(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::KTwoNiFFour
connected	PsimagLite/src/Geometry/Ladder.h	/^		bool connected(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Ladder
connected	PsimagLite/src/Geometry/LadderBath.h	/^			bool connected(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderBath
connected	PsimagLite/src/Geometry/LadderX.h	/^			bool connected(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderX
connectedInCluster	PsimagLite/src/Geometry/LadderBath.h	/^			bool connectedInCluster(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderBath
connectionKind	PsimagLite/src/Geometry/Geometry.h	/^			size_t connectionKind(size_t smax,size_t ind,size_t jnd) const$/;"	f	class:PsimagLite::Geometry
constInverse	PartialPsimag/Symmetry/SeitzMatrix.h	/^    const SeitzMatrix<Field, DIM> constInverse() const {$/;"	f	class:psimag::SeitzMatrix
const_iterator	PartialPsimag/Matrix.h	/^    typedef const T*     const_iterator;$/;"	t	class:psimag::Matrix
const_iterator	PartialPsimag/TagAttributes.h	/^    typedef std::map<std::string, std::string>::const_iterator const_iterator;$/;"	t	class:psimag::TagAttributes
const_iterator	PartialPsimag/Vec.h	/^    typedef T const* const_iterator;$/;"	t	class:psimag::Vec
const_reference	PartialPsimag/Matrix.h	/^    typedef const T&     const_reference;$/;"	t	class:psimag::Matrix
constantValues	PsimagLite/src/Geometry/GeometryDirection.h	/^			bool constantValues() const$/;"	f	class:PsimagLite::GeometryDirection
consume	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    bool consume(wchar_t c) {$/;"	f	class:JsonParser::MatrixParser
consume	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    void consume(T& value) {$/;"	f	class:JsonParser::MatrixParser
consume	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    void consume(std::complex<T>& cmplx) {$/;"	f	class:JsonParser::MatrixParser
consumeMatrix	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    void consumeMatrix()  {$/;"	f	class:JsonParser::MatrixParser
content	PartialPsimag/Tag.h	/^    std::ostringstream  content;$/;"	m	class:psimag::Tag
conventionalCrystal	PartialPsimag/Symmetry/Crystal.h	/^    ConventionalCrystalType conventionalCrystal; $/;"	m	class:psimag::Crystal
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline    int convert<int>(const char* text) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline  Field convert(const char* text) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline  Field convert(const std::string text) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline  Field convert(double value) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline  Field convert(int value) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline  double convert<double>(const char* text) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline  double convert<double>(const std::string text) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^  inline  float convert<float>(const std::string text) {$/;"	f	namespace:psimag
convert	PartialPsimag/Symmetry/FieldConvert.h	/^inline float convert<float>(const char* text) {$/;"	f	namespace:psimag
copy	PartialPsimag/MatrixLike.h	/^    MatrixLikeType2& copy(const MatrixLikeType1& matrix1,$/;"	f	namespace:psimag::MatrixLike
copy	PartialPsimag/VectorLike.h	/^    VectorLikeType2& copy(const VectorLikeType1& vector,$/;"	f	namespace:psimag::VectorLike
copy	PsimagLite/src/JSON/MatrixLike.h	/^    MatrixLikeType2& copy(const MatrixLikeType1& matrix1,$/;"	f	namespace:psimag::MatrixLike
cos_alpha	PartialPsimag/Symmetry/CellParameters.h	/^    Field cos_alpha;  \/**< cos(alpha) **\/$/;"	m	class:psimag::CellParameters
cos_alpha	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  cos_alpha () const { return C() \/ (sqrt(A())*sqrt(B()));}$/;"	f	class:psimag::MetricTensor
cos_alpha	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  cos_alpha() const { return D() \/ (sqrt(B())*sqrt(C()));}$/;"	f	class:psimag::MetricTensor
cos_beta	PartialPsimag/Symmetry/CellParameters.h	/^    Field cos_beta;   \/**< cos(beta) **\/$/;"	m	class:psimag::CellParameters
cos_beta	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  cos_beta () const { return E() \/ (sqrt(C())*sqrt(A()));}$/;"	f	class:psimag::MetricTensor
cos_gamma	PartialPsimag/Symmetry/CellParameters.h	/^    Field cos_gamma;  \/**< cos(gamma) **\/$/;"	m	class:psimag::CellParameters
cos_gamma	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  cos_gamma () const { return F() \/ (sqrt(A())*sqrt(B()));}$/;"	f	class:psimag::MetricTensor
count	PsimagLite/src/BitManip.h	/^		inline int count (WordType b)$/;"	f	namespace:PsimagLite::BitManip
count	PsimagLite/src/IoSimple.h	/^				size_t count(const std::string& s)$/;"	f	class:PsimagLite::IoSimple::In
count	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    int count(std::string key) const {$/;"	f	class:JsonParser::Whatever
count	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    int count(std::wstring key) const {$/;"	f	class:JsonParser::Whatever
count	PsimagLite/src/JSON/JsonReader.h	/^    int count(const std::string key) const {$/;"	f	class:dca::JsonReader
countChars	PsimagLite/scripts/FunctionParsing.pm	/^sub countChars$/;"	s
countChars	PsimagLite/scripts/functionSigIndent.pl	/^sub countChars$/;"	s
countKernighan	PsimagLite/src/BitManip.h	/^		inline size_t countKernighan(WordType v)$/;"	f	namespace:PsimagLite::BitManip
couplingRatio	parameters.h	/^		Field couplingRatio;$/;"	m	class:rpa::parameters
crsMatrixToFullMatrix	PsimagLite/src/CrsMatrix.h	/^	inline void crsMatrixToFullMatrix(FullMatrixTemplate& m,const CrsMatrix<T>& crsMatrix)$/;"	f	namespace:PsimagLite
crystHarm	gaps2D.h	/^		FieldType (*crystHarm)(const std::vector<FieldType>&, $/;"	m	class:rpa::gap2D
crystHarm	gaps3D.h	/^        FieldType (*crystHarm)(const std::vector<FieldType>&, $/;"	m	class:rpa::gap3D
crystHarm2D	gaps3D.h	/^        FieldType (*crystHarm2D)(const std::vector<FieldType>&, $/;"	m	class:rpa::gap3D
crystHarmIm	gaps3D.h	/^        FieldType (*crystHarmIm)(const std::vector<FieldType>&, $/;"	m	class:rpa::gap3D
crystHarmIm2D	gaps3D.h	/^        FieldType (*crystHarmIm2D)(const std::vector<FieldType>&, $/;"	m	class:rpa::gap3D
crystal	PartialPsimag/Symmetry/SuperCrystal.h	/^    const CrystalType&             crystal;                       \/**  The Crystal that this is a SuperCrystal of. *\/$/;"	m	class:psimag::SuperCrystal
ctx	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    ContextType           ctx;$/;"	m	class:JsonParser::JsonParser
currentMode	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    const ModeType& currentMode() {$/;"	f	class:JsonParser::ModesMixin
currentObject	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    Whatever& currentObject() {$/;"	f	class:JsonParser::DefaultContext
cutoff	PsimagLite/src/ChebyshevSerializer.h	/^		size_t cutoff;$/;"	m	struct:PsimagLite::KernelPolynomialParameters
d	PartialPsimag/Symmetry/Mat/Mat.h	/^    LocalType d;$/;"	m	class:psimag::Mat
d	PartialPsimag/Vec.h	/^    T d[2];$/;"	m	class:psimag::Vec
d	PartialPsimag/Vec.h	/^    T d[3];$/;"	m	class:psimag::Vec
d	PartialPsimag/Vec.h	/^    T d[DIM];$/;"	m	class:psimag::Vec
dGInverse	momentumDomain.h	/^		MatrixType dGInverse;$/;"	m	class:rpa::momentumDomain
d_	PsimagLite/src/LinearPrediction.h	/^		std::vector<FieldType> d_;$/;"	m	class:PsimagLite::LinearPrediction
damp	parameters.h	/^		Field damp;$/;"	m	class:rpa::parameters
data	PartialPsimag/Matrix.h	/^    T* data;$/;"	m	class:psimag::Matrix
data	Plot_ek_high_sym.dat.py	/^data=loadtxt(".\/ek_high_sym.dat")$/;"	v
dataMatrices_	PsimagLite/src/Geometry/GeometryDirection.h	/^			std::vector<MatrixType> dataMatrices_;$/;"	m	class:PsimagLite::GeometryDirection
dataNumbers_	PsimagLite/src/Geometry/GeometryDirection.h	/^			std::vector<RealType> dataNumbers_;$/;"	m	class:PsimagLite::GeometryDirection
dataType_	PsimagLite/src/Geometry/GeometryDirection.h	/^			size_t dataType_;$/;"	m	class:PsimagLite::GeometryDirection
data_	PsimagLite/src/ContinuedFractionCollection.h	/^		std::vector<ContinuedFractionType> data_;$/;"	m	class:PsimagLite::ContinuedFractionCollection
data_	PsimagLite/src/LanczosVectors.h	/^		DenseMatrixType* data_;$/;"	m	class:PsimagLite::LanczosVectors
data_	PsimagLite/src/Matrix.h	/^		std::vector<T> data_;$/;"	m	class:PsimagLite::Matrix
data_	PsimagLite/src/MemoryUsage.h	/^		std::string data_;$/;"	m	class:PsimagLite::MemoryUsage
dblMatrices	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, const psimag::Matrix<double>*> dblMatrices;$/;"	m	class:dca::JSN
dca	PsimagLite/src/JSON/JSN_Writer.h	/^namespace dca {$/;"	n
dca	PsimagLite/src/JSON/JsonReader.h	/^namespace dca {$/;"	n
dca_JSN_Writer_H	PsimagLite/src/JSON/JSN_Writer.h	/^#define dca_JSN_Writer_H$/;"	d
decomposition	PsimagLite/src/ChebyshevSolver.h	/^		void decomposition(const VectorType& initVector,$/;"	f	class:PsimagLite::ChebyshevSolver
decomposition	PsimagLite/src/LanczosSolver.h	/^		void decomposition(const VectorType& initVector,$/;"	f	class:PsimagLite::LanczosSolver
decrement	PartialPsimag/MatrixLike.h	/^    MatrixLikeType& decrement(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
decrement	PartialPsimag/VectorLike.h	/^    VectorLikeType& decrement(VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
decrement	PsimagLite/src/JSON/MatrixLike.h	/^    MatrixLikeType& decrement(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
degrees	PartialPsimag/Symmetry/CellParameters.h	/^  static Field degrees(Field radians) {$/;"	f	namespace:psimag
delElements	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    static void delElements() {$/;"	f	class:psimag::SymmetryElements
delimiters	PartialPsimag/TagAttributeParser.h	/^    const string     delimiters;$/;"	m	class:psimag::TagAttributeParser
delta	PsimagLite/src/PlotParams.h	/^	RealType delta;$/;"	m	struct:PsimagLite::PlotParams
deltaOmega	PsimagLite/src/PlotParams.h	/^	RealType deltaOmega;$/;"	m	struct:PsimagLite::PlotParams
deltaU	parameters.h	/^		std::vector<Field> deltaU;$/;"	m	class:rpa::parameters
deltakF	ferminator.h	/^		VectorType deltakF,vkF,gammaB1GkF;$/;"	m	class:rpa::ferminator
deltakF	pairing.h	/^		std::vector<FieldType> deltakF;$/;"	m	class:rpa::pairing
deltax	parameters.h	/^		Field deltax;$/;"	m	class:rpa::parameters
deltay	parameters.h	/^		Field deltay;$/;"	m	class:rpa::parameters
deltaz	parameters.h	/^		Field deltaz;$/;"	m	class:rpa::parameters
den	PartialPsimag/Symmetry/rational.h	/^  Int num, den; \/\/ numerator, denominator$/;"	m	class:rational
denominator	PartialPsimag/Symmetry/rational.h	/^  Int denominator(){return den;}$/;"	f	class:rational
det	PartialPsimag/Symmetry/Lattice.h	/^    Field                       det;            $/;"	m	class:psimag::Lattice
determinant	PartialPsimag/Symmetry/CartesianRotation.h	/^    const Field determinant() {$/;"	f	class:psimag::CartesianRotation
determinant	PartialPsimag/Symmetry/CellRotation.h	/^    const Field determinant() {$/;"	f	class:psimag::CellRotation
determinant	PartialPsimag/Symmetry/SeitzMatrix.h	/^    Field determinant() const {$/;"	f	class:psimag::SeitzMatrix
diag	PsimagLite/src/Matrix.h	/^	void diag(Matrix<double> &m,std::vector<double> &eigs,char option)$/;"	f	namespace:PsimagLite
diag	PsimagLite/src/Matrix.h	/^	void diag(Matrix<std::complex<double> > &m,std::vector<double> &eigs,char option)$/;"	f	namespace:PsimagLite
diag	PsimagLite/src/Matrix.h	/^	void diag(Matrix<std::complex<float> > &m,std::vector<float> &eigs,char option)$/;"	f	namespace:PsimagLite
diag	bands.h	/^		void diag(VectorType& eigenvals, ComplexMatrixType& matrix)$/;"	f	class:rpa::Bands
diagonalize	PsimagLite/src/ContinuedFraction.h	/^		void diagonalize()$/;"	f	class:PsimagLite::ContinuedFraction
diff	PartialPsimag/Symmetry/SymmetryElement.h	/^  void diff (std::ostream& os, $/;"	f	namespace:psimag
diffSiteTableXML	PartialPsimag/Symmetry/Pattern.h	/^  Tag diffSiteTableXML(const Pattern<Field,DIM,Occupant,Algorithms>& pat,$/;"	f	namespace:psimag
difference	PartialPsimag/VectorLike.h	/^    difference(const VectorLikeType1& vector1,$/;"	f	namespace:psimag::VectorLike
differenceFor	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    bool differenceFor(const SymmetryOperationType&  symmetryOperation) {$/;"	f	class:psimag::LatticeWithPattern
differenceFor	PartialPsimag/Symmetry/OriginLocator.h	/^    bool differenceFor(const SymmetryOperationType&  symmetryOperation) {$/;"	f	class:psimag::OriginLocator
differenceFor	PartialPsimag/Symmetry/PatternWithLattice.h	/^    bool differenceFor(const SymmetryOperationType&  symmetryOperation) {$/;"	f	class:psimag::PatternWithLattice
dim	1band_wSpin.h	/^		size_t dim;$/;"	m	class:rpa::SingleBand_wSpin
dim	4Orbital.h	/^		size_t dim;$/;"	m	class:rpa::FourOrbital
dim	BSCCObilayer.h	/^		size_t dim;$/;"	m	class:rpa::model
dim	BaFeAs_5orb.h	/^		size_t dim;$/;"	m	class:rpa::BaFeAs
dim	FourOrbital.h	/^		size_t dim;$/;"	m	class:rpa::FourOrbital
dim	KFe2Se2.h	/^		size_t dim;$/;"	m	class:rpa::KFe2Se2
dim	SrRuO.h	/^		size_t dim;$/;"	m	class:rpa::SrRuO
dim	SrRuO_SO.h	/^		size_t dim;$/;"	m	class:rpa::model
dim	bands.h	/^		size_t dim;$/;"	m	class:rpa::Bands
dim	bilayer.h	/^		size_t dim;$/;"	m	class:rpa::model
dim	bilayerFESC.h	/^		size_t dim;$/;"	m	class:rpa::model
dim	coupledLadders.h	/^		size_t dim;$/;"	m	class:rpa::model
dim	momentumDomain.h	/^		size_t dim;$/;"	m	class:rpa::momentumDomain
dim	orthoIIBilayer.h	/^		size_t dim;$/;"	m	class:rpa::model
dim	pairing.h	/^		const size_t& dim;$/;"	m	class:rpa::pairing
dim	singleBand.h	/^		size_t dim;$/;"	m	class:rpa::model
dim	tbFromFile.h	/^		size_t dim;$/;"	m	class:rpa::model
dimension	parameters.h	/^		size_t dimension;$/;"	m	class:rpa::parameters
dirId_	PsimagLite/src/Geometry/GeometryDirection.h	/^			size_t dirId_;$/;"	m	class:PsimagLite::GeometryDirection
directions_	PsimagLite/src/Geometry/GeometryTerm.h	/^			std::vector<GeometryDirectionType> directions_;$/;"	m	class:PsimagLite::GeometryTerm
dirs	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t dirs() const { return dirs_; } \/\/ <-- move elsewhere FIXME$/;"	f	class:PsimagLite::GeometryFactory
dirs_	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t dirs_; \/\/ move to object.dirs()$/;"	m	class:PsimagLite::GeometryFactory
dispersion	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def dispersion(self,k,kz):$/;"	m	class:RPA
dispersion	PythonScripts/Sr2RuO4.py	/^        def dispersion(self,k,sigma=+1):$/;"	m	class:RPA
display	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void display() {$/;"	f	class:psimag::HermiteNormalForm
distance	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    Field                                     distance;$/;"	m	class:psimag::AppliedSymmetryElement
distance	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    Field                    distance;$/;"	m	class:psimag::AppliedSymmetryElement
distanceTo	PartialPsimag/Symmetry/TestPattern.h	/^    Field distanceTo(const PatternType& otherPattern) const{$/;"	f	class:psimag::TestPattern
distanceTo	PartialPsimag/Symmetry/TestPattern.h	/^    Field distanceTo(const SymmetryOperationType& symOp) const{$/;"	f	class:psimag::TestPattern
divide	PartialPsimag/MatrixLike.h	/^    MatrixLikeType& divide(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
divide	PartialPsimag/VectorLike.h	/^    VectorLikeType& divide(VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
divide	PsimagLite/src/JSON/MatrixLike.h	/^    MatrixLikeType& divide(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
docType	PartialPsimag/XMLHeading.h	/^    DocType     docType;$/;"	m	class:psimag::XMLHeading
docTypeString	PartialPsimag/XMLHeading.h	/^    const std::string docTypeString() const {$/;"	f	class:psimag::XMLHeading
doubleVector	PartialPsimag/MatrixLike.h	/^      const DoubleVectorType& doubleVector;$/;"	m	class:psimag::MatrixLike::DoubleVectorWrap
doubleVector	PsimagLite/src/JSON/MatrixLike.h	/^      const DoubleVectorType& doubleVector;$/;"	m	class:psimag::MatrixLike::DoubleVectorWrap
dummy	PartialPsimag/Symmetry/TypeManip.h	/^            struct Big { char dummy[2]; };$/;"	m	struct:psimag::TypeManip_Private::ConversionHelper::Big
dummy_	PsimagLite/src/LanczosVectors.h	/^		VectorElementType dummy_;$/;"	m	class:PsimagLite::LanczosVectors
dumpMeshXML	PartialPsimag/Symmetry/fetchGeometry2D.h	/^  void dumpMeshXML(const std::string outputDir, const std::string name, const Matrix<Field>& mesh)  {$/;"	f	namespace:rpa
dumpMeshXML	PartialPsimag/Symmetry/fetchMesh.h	/^  void dumpMeshXML(const std::string outputDir, const std::string name, const Matrix<Field>& mesh)  {$/;"	f	namespace:rpa
dumpXML	PartialPsimag/Symmetry/SuperCrystal.h	/^    void dumpXML(const std::string outputDir, const std::string name, const ObjectType& obj) const {$/;"	f	class:psimag::SuperCrystal
dumpXML	PartialPsimag/Symmetry/SuperCrystal.h	/^    void dumpXML(std::string directoryName) const {$/;"	f	class:psimag::SuperCrystal
dwave	CrystalHarmonics2D.h	/^	FieldType dwave(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
dwavePhenomKFe2Se2	CrystalHarmonics2D.h	/^	FieldType dwavePhenomKFe2Se2(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
dwavePhenomKFe2Se2_overdoped	CrystalHarmonics2D.h	/^		FieldType dwavePhenomKFe2Se2_overdoped(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
dwaveRPAKFe2Se2_1	CrystalHarmonics2D.h	/^	FieldType dwaveRPAKFe2Se2_1(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
dwaveRPAKFe2Se2_2	CrystalHarmonics2D.h	/^	FieldType dwaveRPAKFe2Se2_2(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
dwaveRPAKFe2Se2_3	CrystalHarmonics2D.h	/^	FieldType dwaveRPAKFe2Se2_3(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
dwaveRot	CrystalHarmonics2D.h	/^	FieldType dwaveRot(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
dx	bands.h	/^		std::vector<Field> dx,dy,dz,ht;$/;"	m	class:rpa::Bands
dx	bandstructure.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::bandstructure
dx	tbFromFile.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::model
dy	bands.h	/^		std::vector<Field> dx,dy,dz,ht;$/;"	m	class:rpa::Bands
dy	bandstructure.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::bandstructure
dy	tbFromFile.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::model
dz	bands.h	/^		std::vector<Field> dx,dy,dz,ht;$/;"	m	class:rpa::Bands
dz	bandstructure.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::bandstructure
dz	tbFromFile.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::model
eigen	PythonScripts/Plot_Gap_jsn.py	/^def eigen(file = "Gap.jsn",firstBZ=True,returnEvec=0):$/;"	f
eigen	bandstructure.h	/^		void eigen(VectorType& eigenvals, ComplexMatrixType& matrix) const {$/;"	f	class:rpa::bandstructure
eigen	pairing.h	/^	void eigen(MatrixType& matrix, VectorType& wr, MatrixType& vr) const {$/;"	f	class:rpa::pairing
eigen	utilities.h	/^void eigen(std::vector<FieldType>& eigenvals, MatrixTemplate<std::complex<FieldType> >& matrix) {$/;"	f
eigs_	PsimagLite/src/ContinuedFraction.h	/^		std::vector<RealType> eigs_;$/;"	m	class:PsimagLite::ContinuedFraction
ek	PythonScripts/MayaVi_Plot_of_FS.py	/^		ek = bands[:,i].reshape(nkx,nky,nkz,order='F')$/;"	v
ek	PythonScripts/Sr2RuO4.py	/^        ek = ctypeslib.as_ctypes(zeros((NInt,nOrb),dtype='float'))$/;"	v	class:RPA
ek	bandstructure.h	/^		std::vector<VectorType> ek;$/;"	m	class:rpa::bandstructure
ek_along_high_sym_dir	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def ek_along_high_sym_dir(self):$/;"	m	class:RPA
ek_along_high_sym_dir	PythonScripts/CoupledLadders.py	/^	def ek_along_high_sym_dir(self):$/;"	m	class:CoupledLadders
ekq	bandstructure.h	/^		std::vector<VectorType> ekq;$/;"	m	class:rpa::bandstructure
element	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    SymmetryElement< Field, DIM, Algorithms>  element;$/;"	m	class:psimag::AppliedSymmetryElement
elements	PartialPsimag/Tag.h	/^    Elements            elements;$/;"	m	class:psimag::Tag
elements_	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    static std::vector<SymmetryElementType*> elements_() {$/;"	f	class:psimag::SymmetryElements
end	PartialPsimag/Matrix.h	/^    const_iterator end() const { return data+(nCol-1)*lDim+nRow; }$/;"	f	class:psimag::Matrix
end	PartialPsimag/Matrix.h	/^    iterator       end()   { return data+(nCol-1)*lDim+nRow; }$/;"	f	class:psimag::Matrix
end	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^   static AppliedSymmetryElementIterator end(const SpaceGroupType& sg, const AppliedSymmetryElementsType& allEl) {$/;"	f	class:psimag::AppliedSymmetryElementIterator
end	PartialPsimag/TagAttributes.h	/^    const_iterator end()   const { return attrs.end();   }$/;"	f	class:psimag::TagAttributes
end	PartialPsimag/Vec.h	/^    const_iterator end() const { return &(d[2]); }$/;"	f	class:psimag::Vec
end	PartialPsimag/Vec.h	/^    const_iterator end() const { return &(d[3]); }$/;"	f	class:psimag::Vec
end	PartialPsimag/Vec.h	/^    const_iterator end() const { return &(d[DIM]); }$/;"	f	class:psimag::Vec
end	PartialPsimag/Vec.h	/^    iterator end() { return &(d[2]); }$/;"	f	class:psimag::Vec
end	PartialPsimag/Vec.h	/^    iterator end() { return &(d[3]); }$/;"	f	class:psimag::Vec
end	PartialPsimag/Vec.h	/^    iterator end() { return &(d[DIM]); }$/;"	f	class:psimag::Vec
end	PsimagLite/src/Range.h	/^		bool end() const { return step_>=total_; }$/;"	f	class:PsimagLite::Range
end	PsimagLite/src/Range.h	/^		bool end() const$/;"	f	class:PsimagLite::Range
endObjectOrArray	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void endObjectOrArray() {$/;"	f	class:JsonParser::DefaultContext
endOperations	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    endOperations(const Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>& symmetry) {$/;"	f	class:psimag::SpaceGroup
endPos	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    int endPos;$/;"	m	class:JsonParser::MatrixParser
endPos	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    int            endPos;$/;"	m	class:JsonParser::Whatever
eps_	PsimagLite/src/AlmostEqual.h	/^		const RealType& eps_;$/;"	m	class:PsimagLite::AlmostEqual
eps_	PsimagLite/src/LanczosSolver.h	/^		RealType eps_;$/;"	m	class:PsimagLite::LanczosSolver
equals	PartialPsimag/MatrixLike.h	/^    bool equals(const MatrixLikeType1& matrix1,$/;"	f	namespace:psimag::MatrixLike
equals	PartialPsimag/VectorLike.h	/^    bool equals(const VectorLikeType1& vector1,$/;"	f	namespace:psimag::VectorLike
equals	PsimagLite/src/JSON/MatrixLike.h	/^    bool equals(const MatrixLikeType1& matrix1,$/;"	f	namespace:psimag::MatrixLike
eraseRowAndColumn	PsimagLite/src/JSON/Transposer.h	/^    void eraseRowAndColumn(size_t r, size_t c){$/;"	f	class:psimag::Transposed
escaped	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    bool                 escaped; $/;"	m	class:JsonParser::JsonParser
exists	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists     = false;$/;"	m	struct:psimag::Conversion
exists	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists     = sizeof(typename H::Small) == sizeof((H::Test(H::MakeT())));$/;"	m	struct:psimag::Conversion
exists	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists     = true;$/;"	m	class:psimag::Conversion
exists	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists     = true;$/;"	m	struct:psimag::Conversion
exists2Way	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists2Way = exists && Conversion<U, T>::exists;$/;"	m	struct:psimag::Conversion
exists2Way	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists2Way = false;$/;"	m	struct:psimag::Conversion
exists2Way	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists2Way = true;$/;"	m	class:psimag::Conversion
exists2Way	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool exists2Way = true;$/;"	m	struct:psimag::Conversion
expandChiQtoChiKKP	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def expandChiQtoChiKKP(self):$/;"	m	class:RPA
expandChiQtoChiKKP_v2	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def expandChiQtoChiKKP_v2(self):$/;"	m	class:RPA
expectedRotationAngle	PartialPsimag/Symmetry/SymmetryElement.h	/^  Field expectedRotationAngle(const std::string& type) {$/;"	f	namespace:psimag
expectedSense	PartialPsimag/Symmetry/SymmetryElement.h	/^  int expectedSense(const std::string& type) {$/;"	f	namespace:psimag
expectedTrace	PartialPsimag/Symmetry/SymmetryElement.h	/^  int expectedTrace(const std::string& type) {$/;"	f	namespace:psimag
explicitSpin	parameters.h	/^		bool explicitSpin;$/;"	m	class:rpa::parameters
extendMultiplicationTable	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    size_t extendMultiplicationTable(size_t                                    lastSize,$/;"	f	class:psimag::GroupMultiplicationTable
extendMultiplicationTable	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    size_t extendMultiplicationTable(size_t i, size_t j, $/;"	f	class:psimag::GroupMultiplicationTable
extendMultiplicationTable	PartialPsimag/Symmetry/Star.h	/^    size_t extendMultiplicationTable(size_t                                    lastSize,$/;"	f	class:psimag::Star
extendMultiplicationTable	PartialPsimag/Symmetry/Star.h	/^    size_t extendMultiplicationTable(size_t i, size_t j, $/;"	f	class:psimag::Star
externalProduct	PsimagLite/src/CrsMatrix.h	/^	void externalProduct(CrsMatrix<T>  &B,CrsMatrix<T> const &A,int nout,$/;"	f	namespace:PsimagLite
externalProduct	PsimagLite/src/CrsMatrix.h	/^	void externalProduct(CrsMatrix<T>  &C,CrsMatrix<T> const &A,CrsMatrix<T> const &B)$/;"	f	namespace:PsimagLite
externalProduct	PsimagLite/src/CrsMatrix.h	/^	void externalProduct(CrsMatrix<T>  &C,CrsMatrix<T> const &A,CrsMatrix<T> const &B,const std::vector<int>& signs,bool option=false)$/;"	f	namespace:PsimagLite
family	PartialPsimag/KISS.h	/^    void family(seed_type a, seed_type b)$/;"	f	class:psimag::KISS
fermi	PsimagLite/src/Fermi.h	/^	FieldType fermi(const FieldType& x)$/;"	f	namespace:PsimagLite
fermi	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def fermi(self,k,kz):$/;"	m	class:RPA
fermi	PythonScripts/Sr2RuO4.py	/^        def fermi(self,energy):$/;"	m	class:RPA
fermi	bands.h	/^		inline FieldType fermi(const FieldType& energy, const FieldType& invT) {$/;"	f	class:rpa::Bands
fermi	bandstructure.h	/^		inline FieldType fermi(const FieldType& energy, const FieldType& invT) {$/;"	f	class:rpa::bandstructure
fermiPrime	PsimagLite/src/Fermi.h	/^	FieldType fermiPrime(const FieldType& x)$/;"	f	namespace:PsimagLite
fermiVelocity2D	bands.h	/^		FieldType fermiVelocity2D(VectorType& k, size_t band) {$/;"	f	class:rpa::Bands
ferminator	ferminator.h	/^	class ferminator {$/;"	c	namespace:rpa
ferminator	ferminator.h	/^	ferminator(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::ferminator
fetchGeometry1D	PartialPsimag/Symmetry/fetchGeometry1D.h	/^  void fetchGeometry1D(int length1d,$/;"	f	namespace:rpa
fetchGeometry2D	PartialPsimag/Symmetry/fetchGeometry2D.h	/^  void fetchGeometry2D(Field latticeA_length, $/;"	f	namespace:rpa
fetchGroupAction	PartialPsimag/Symmetry/fetchGeometry2D.h	/^  void fetchGroupAction(const SymmetryType&        symmetry,$/;"	f	namespace:rpa
fetchMeshGeometry	PartialPsimag/Symmetry/fetchMesh.h	/^  void fetchMeshGeometry(int dim,$/;"	f	namespace:rpa
fetchMeshGeometry	PartialPsimag/Symmetry/fetchMeshWignerSeitz.h	/^  void fetchMeshGeometry(int dim,$/;"	f	namespace:rpa
fetchMeshGeometry1D	PartialPsimag/Symmetry/fetchGeometry1D.h	/^  void fetchMeshGeometry1D(int length1d,$/;"	f	namespace:rpa
fetchMeshGeometry1D	PartialPsimag/Symmetry/fetchMesh.h	/^  void fetchMeshGeometry1D(int length1d,int numPoints, psimag::Matrix<Field>& sitesKmesh)$/;"	f	namespace:rpa
fetchMeshGeometry2D	PartialPsimag/Symmetry/fetchGeometry2D.h	/^  void fetchMeshGeometry2D(Field latticeA_length, $/;"	f	namespace:rpa
fetchMeshGeometry2D	PartialPsimag/Symmetry/fetchMesh.h	/^  void fetchMeshGeometry2D(Field latticeA_length, Field latticeB_length, Field latticeAngle,$/;"	f	namespace:rpa
file	PythonScripts/Calc_lambda.py	/^    file = sys.argv[1]$/;"	v
file	PythonScripts/Plot_Gap_jsn.py	/^    file = sys.argv[1]$/;"	v
file	PythonScripts/Plot_chiRPA_qxqy.py	/^    	file = sys.argv[1]$/;"	v
file	chi0.h	/^		std::string file;$/;"	m	class:rpa::chi0q
fileID	PythonScripts/Plot_chiRPA_w.py	/^    fileID = sys.argv[1]$/;"	v
fileID	parameters.h	/^		std::string fileID;$/;"	m	class:rpa::parameters
fileName	PsimagLite/src/JSON/JsonReader.h	/^    std::string                          fileName;$/;"	m	class:dca::JsonReader
filename	PsimagLite/src/IoSimple.h	/^				const char* filename() const $/;"	f	class:PsimagLite::IoSimple::In
filename	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    std::string          filename;$/;"	m	class:JsonParser::JsonParser
filename	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    std::string    filename;$/;"	m	class:JsonParser::Whatever
filename_	PsimagLite/src/IoSimple.h	/^				std::string filename_;$/;"	m	class:PsimagLite::IoSimple::In
filename_	PsimagLite/src/IoSimple.h	/^			std::string filename_;$/;"	m	class:PsimagLite::IoSimple::Out
fillAdditionalData	PsimagLite/src/Geometry/Geometry.h	/^			void fillAdditionalData(AdditionalDataType& additionalData,size_t term,size_t ind,size_t jnd) const$/;"	f	class:PsimagLite::Geometry
fillAdditionalData	PsimagLite/src/Geometry/GeometryFactory.h	/^		void fillAdditionalData(AdditionalDataType& additionalData,size_t ind,size_t jnd) const$/;"	f	class:PsimagLite::GeometryFactory
fillAdditionalData	PsimagLite/src/Geometry/GeometryTerm.h	/^			void fillAdditionalData(AdditionalDataType& additionalData,size_t ind,size_t jnd) const$/;"	f	class:PsimagLite::GeometryTerm
fillAdditionalData	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		void fillAdditionalData(AdditionalData& additionalData,size_t ind,size_t jnd) const$/;"	f	class:PsimagLite::KTwoNiFFour
fillMatrix	PsimagLite/src/SampleCRSMatrix.h	/^		void fillMatrix(std::vector<size_t>& rows,std::vector<size_t>& cols,$/;"	f	class:PsimagLite::SampleCRSMatrix
fillRandomVector	PsimagLite/drivers/testCRSMatrix.cpp	/^void fillRandomVector(std::vector<RealType>& x,RealType maxValue)$/;"	f
fill_per_window	PythonScripts/Sr2RuO4.py	/^        def fill_per_window(self,args):$/;"	m	class:RPA
filterMeshPoints	PartialPsimag/Symmetry/fetchMeshWignerSeitz.h	/^  void filterMeshPoints(psimag::Matrix<Field>& sitesKmesh,psimag::Matrix<Field> const &meshPoints,psimag::Matrix<Field> const &sitesK)$/;"	f	namespace:rpa
fin_	PsimagLite/src/IoSimple.h	/^				std::ifstream 	fin_;$/;"	m	class:PsimagLite::IoSimple::In
finalize	PartialPsimag/Symmetry/LatticeTransformation.h	/^    void finalize()   {$/;"	f	class:psimag::LatticeTransformation
finalize	PartialPsimag/Symmetry/OriginLocator.h	/^    void finalize() {$/;"	f	class:psimag::OriginLocator
finalize	PsimagLite/src/SparseRow.h	/^		size_t finalize(CrsMatrixType& matrix)$/;"	f	class:PsimagLite::SparseRow
findEntry	PsimagLite/src/MemoryUsage.h	/^		long findEntry(const std::string& label)$/;"	f	class:PsimagLite::MemoryUsage
findIndex	PartialPsimag/Symmetry/Star.h	/^    int findIndex(const SymmetryType&          symmetry, $/;"	f	class:psimag::Star
findLowestLoad	PsimagLite/src/Range.h	/^		size_t findLowestLoad(std::vector<size_t> const &loads) const$/;"	f	class:PsimagLite::Range
findMaxEdof	PsimagLite/src/Geometry/GeometryTerm.h	/^			void findMaxEdof()$/;"	f	class:PsimagLite::GeometryTerm
findRange	PsimagLite/src/AkimaSpline.h	/^		size_t findRange(const RealType& x) const$/;"	f	class:AkimaSpline
findTypeOfSite	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		PairType findTypeOfSite(size_t site) const$/;"	f	class:PsimagLite::KTwoNiFFour
first	PartialPsimag/Matrix.h	/^    T&             first() { return data[0]; }$/;"	f	class:psimag::Matrix
first	PartialPsimag/Matrix.h	/^    const T&       first() const {return data[0]; }$/;"	f	class:psimag::Matrix
fixEvecs	parameters.h	/^		bool fixEvecs;$/;"	m	class:rpa::parameters
fixdr	bands.h	/^		void fixdr() {$/;"	f	class:rpa::Bands
fixdr	tbFromFile.h	/^		void fixdr() { \/\/ This is to shift position of all orbitals to the same site$/;"	f	class:rpa::model
fixedPoint	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SeitzPositionType fixedPoint() {$/;"	f	class:psimag::SymmetryOperation
flag_indep	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    Vec<bool,         NCOL>        flag_indep;$/;"	m	class:psimag::BackSubstitution
flatMap	PsimagLite/src/JSON/JsonReader.h	/^    FlatMapType                          flatMap;$/;"	m	class:dca::JsonReader
flattenInto	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void flattenInto(FlatMapType& flatMap, const std::wstring prefix=L"") const {$/;"	f	class:JsonParser::Whatever
foo	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    static bool foo() { return false;}$/;"	f	class:JsonParser::CharacterMapper
found	PsimagLite/src/Minimizer.h	/^		void found(VectorType& minVector,gsl_vector* x,size_t iter)$/;"	f	class:PsimagLite::Minimizer
fourfold	PartialPsimag/Symmetry/CellRotation.h	/^		   twofold=2, threefold=3,  fourfold=4, sixfold=6 } RotationType;$/;"	e	enum:psimag::CellRotation::__anon62
fourfoldInv	PartialPsimag/Symmetry/CellRotation.h	/^    typedef enum { sixfoldInv=-6, fourfoldInv=-4, threefoldInv=-3, twofoldInv=-2, inversion=-1, identity=1, $/;"	e	enum:psimag::CellRotation::__anon62
fout_	PsimagLite/src/IoSimple.h	/^			std::ofstream* fout_;$/;"	m	class:PsimagLite::IoSimple::Out
fringe	PsimagLite/src/Geometry/Chain.h	/^			bool fringe(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::Chain
fringe	PsimagLite/src/Geometry/GeometryFactory.h	/^		bool fringe(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::GeometryFactory
fringe	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		bool fringe(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::KTwoNiFFour
fringe	PsimagLite/src/Geometry/Ladder.h	/^		bool fringe(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::Ladder
fringe	PsimagLite/src/Geometry/LadderBath.h	/^			bool fringe(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::LadderBath
fringe	PsimagLite/src/Geometry/LadderX.h	/^			bool fringe(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::LadderX
fringe0	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		bool fringe0(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::KTwoNiFFour
fringe1	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		bool fringe1(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::KTwoNiFFour
fringe2	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		bool fringe2(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::KTwoNiFFour
fringe3	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		bool fringe3(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::KTwoNiFFour
fringeInCluster	PsimagLite/src/Geometry/LadderBath.h	/^			bool fringeInCluster(size_t i,size_t smax,size_t emin) const$/;"	f	class:PsimagLite::LadderBath
from	PartialPsimag/Symmetry/Mat/MatDet.h	/^      static const T& from(const M& m) {$/;"	f	class:psimag::DET::get
from	PartialPsimag/Symmetry/Mat/MatInverse.h	/^      static T& from(MR& im) {$/;"	f	class:psimag::AssembleInverse2::get
from	PartialPsimag/Symmetry/Mat/MatInverse.h	/^      static T& from(MR& im) {$/;"	f	class:psimag::AssembleInverse3::get
from	PartialPsimag/Symmetry/Mat/MatInverse.h	/^      static const T& from(const M& m) {$/;"	f	class:psimag::AssembleInverse2::get
from	PartialPsimag/Symmetry/Mat/MatInverse.h	/^      static const T& from(const M& m) {$/;"	f	class:psimag::AssembleInverse3::get
from	PartialPsimag/Symmetry/Mat/MatMult.h	/^      static T from(const MatTypeO& m) {                    \/\/ &*&*&*&* can we have it both ways does it make a difference?$/;"	f	class:psimag::MatMultVecPos::getO
from	PartialPsimag/Symmetry/Mat/MatMult.h	/^      static TR& from(MatTypeR& m) {$/;"	f	class:psimag::MatMultVecRow::get
from	PartialPsimag/Symmetry/Mat/MatMult.h	/^      static const T from(const MatTypeO& m) {$/;"	f	class:psimag::MatMultVecPos::getO
from	PartialPsimag/Symmetry/Mat/MatMult.h	/^      static const T& from(const MatType& m) {$/;"	f	class:psimag::MatMultVecPos::get
from	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^      static T& from(MR& im) {$/;"	f	class:psimag::TRANSPOSE_ELS::get
from	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^      static const T& from(const M& m) {$/;"	f	class:psimag::TRANSPOSE_ELS::get
fsfile	parameters.h	/^		std::string fsfile;$/;"	m	class:rpa::parameters
fullMatrixToCrsMatrix	PsimagLite/src/CrsMatrix.h	/^	void fullMatrixToCrsMatrix(CrsMatrix<T>& crsMatrix, const FullMatrixTemplate& a)$/;"	f	namespace:PsimagLite
function	PsimagLite/src/GslWrapper.h	/^			GslWrapperFunctionType function;$/;"	m	struct:PsimagLite::GslWrapper::gsl_function
function	interpolation.h	/^		const std::vector<SuscType>& function;$/;"	m	class:rpa::interpolation
functionFor	PsimagLite/src/AkimaSpline.h	/^		RealType functionFor(const RealType& x,size_t i) const$/;"	f	class:AkimaSpline
function_	PsimagLite/src/Minimizer.h	/^		FunctionType& function_;$/;"	m	class:PsimagLite::Minimizer
functorDwave	CrystalHarmonics.h	/^	class functorDwave {$/;"	c	namespace:rpa
functorDwaveRot	CrystalHarmonics.h	/^	class functorDwaveRot {$/;"	c	namespace:rpa
functorSwave	CrystalHarmonics.h	/^	class functorSwave {$/;"	c	namespace:rpa
functorSwaveRot	CrystalHarmonics.h	/^	class functorSwaveRot {$/;"	c	namespace:rpa
g	chi0Ofq.h	/^		const rpa::greensFunction<Field,MatrixTemplate,ConcurrencyType>& g;$/;"	m	class:rpa::chi0ofq
gAmpl	parameters.h	/^		std::string gAmpl;$/;"	m	class:rpa::parameters
gMatrix	sepBasis.h	/^			MatrixType gMatrix;$/;"	m	class:rpa::sepBasis
gamma	PartialPsimag/Symmetry/CellParameters.h	/^    Field gamma;      \/**< The angle between a and b. **\/$/;"	m	class:psimag::CellParameters
gamma	PartialPsimag/Symmetry/MetricTensor.h	/^    Field  gamma()      const { return acos(cos_gamma())*180.0\/PI; }$/;"	f	class:psimag::MetricTensor
gammaB1GkF	ferminator.h	/^		VectorType deltakF,vkF,gammaB1GkF;$/;"	m	class:rpa::ferminator
gammaPP	pairing.h	/^		MatrixType gammaPP;$/;"	m	class:rpa::pairing
gammaZ	pairing.h	/^		MatrixType gammaZ;$/;"	m	class:rpa::pairing
gap	gap.h	/^		gap(const rpa::parameters<Field,MatrixTemplate>& parameters,$/;"	f	class:rpa::gap
gap	gap.h	/^	class gap {$/;"	c	namespace:rpa
gap2D	gaps2D.h	/^		gap2D() {}$/;"	f	class:rpa::gap2D
gap2D	gaps2D.h	/^		gap2D(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::gap2D
gap2D	gaps2D.h	/^	class gap2D {    \/\/ simple s+- for 5-orbital 1111 model 2D$/;"	c	namespace:rpa
gap3D	gaps3D.h	/^        gap3D() {}$/;"	f	class:rpa::gap3D
gap3D	gaps3D.h	/^        gap3D(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, \/\/ not const because param.parity will be set according to gap symmetry$/;"	f	class:rpa::gap3D
gap3D	gaps3D.h	/^    class gap3D {    \/\/ simple s+- for 5-orbital 1111 model 2D$/;"	c	namespace:rpa
gapk	bandstructure.h	/^		std::vector<std::vector<ComplexType> > gapk;$/;"	m	class:rpa::bandstructure
gapkq	bandstructure.h	/^		std::vector<std::vector<ComplexType> > gapkq;$/;"	m	class:rpa::bandstructure
garbage_	PsimagLite/src/ConcurrencyMpi.h	/^		std::vector<CommType*> garbage_;$/;"	m	class:PsimagLite::ConcurrencyMpi
gather	PsimagLite/src/ConcurrencyMpi.h	/^		void gather(std::vector<PsimagLite::Matrix<double> > &v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
gather	PsimagLite/src/ConcurrencySerial.h	/^		void gather(DataType &v,CommType mpiComm=COMM_WORLD) { }$/;"	f	class:PsimagLite::ConcurrencySerial
gcd	PartialPsimag/Symmetry/rational.h	/^template<class Int> Int gcd(Int a, Int b)$/;"	f
generateCartesianPositions	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    void generateCartesianPositions() {$/;"	f	class:psimag::LatticeWithPattern
generateCartesianPositions	PartialPsimag/Symmetry/PatternWithLattice.h	/^    void generateCartesianPositions() {$/;"	f	class:psimag::PatternWithLattice
generateCellPositions	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    void generateCellPositions()  {$/;"	f	class:psimag::LatticeWithPattern
generateCellPositions	PartialPsimag/Symmetry/PatternWithLattice.h	/^    void generateCellPositions()  {$/;"	f	class:psimag::PatternWithLattice
generateMeshPoints	PartialPsimag/Symmetry/fetchMeshWignerSeitz.h	/^  void generateMeshPoints(int                    dim,$/;"	f	namespace:rpa
geometryFactory_	PsimagLite/src/Geometry/GeometryDirection.h	/^			const GeometryFactoryType* geometryFactory_;$/;"	m	class:PsimagLite::GeometryDirection
geometryFactory_	PsimagLite/src/Geometry/GeometryTerm.h	/^			GeometryFactory geometryFactory_;$/;"	m	class:PsimagLite::GeometryTerm
get	PartialPsimag/Symmetry/Mat/MatDet.h	/^    template<size_t R, size_t C> class get {$/;"	c	class:psimag::DET
get	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    template<size_t R, size_t C> class get {$/;"	c	class:psimag::AssembleInverse2
get	PartialPsimag/Symmetry/Mat/MatInverse.h	/^    template<size_t R, size_t C> class get {$/;"	c	class:psimag::AssembleInverse3
get	PartialPsimag/Symmetry/Mat/MatMult.h	/^    template<size_t R, size_t C> class get {$/;"	c	class:psimag::MatMultVecPos
get	PartialPsimag/Symmetry/Mat/MatMult.h	/^    template<size_t R, size_t C> class get {$/;"	c	class:psimag::MatMultVecRow
get	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^    template<size_t R, size_t C> class get {$/;"	c	class:psimag::TRANSPOSE_ELS
get	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void get (T& value) {$/;"	f	class:JsonParser::Whatever
getAppliedElement	PartialPsimag/Symmetry/Symmetry.h	/^    AppliedSymmetryElementType& getAppliedElement(int id) {$/;"	f	class:psimag::Symmetry
getArgs	PsimagLite/scripts/FunctionParsing.pm	/^sub getArgs$/;"	s
getArgs	PsimagLite/scripts/functionSigIndent.pl	/^sub getArgs$/;"	s
getAxis	PartialPsimag/Symmetry/CellRotation.h	/^    CellDirection<Field, DIM> getAxis() {$/;"	f	class:psimag::CellRotation
getBands	1band_wSpin.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::SingleBand_wSpin
getBands	4Orbital.h	/^		inline void getBands(const VectorType k, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::FourOrbital
getBands	BSCCObilayer.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
getBands	BaFeAs_5orb.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::BaFeAs
getBands	FourOrbital.h	/^		inline void getBands(const VectorType k,  VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::FourOrbital
getBands	KFe2Se2.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::KFe2Se2
getBands	SrRuO.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::SrRuO
getBands	SrRuO_SO.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
getBands	bandstructure.h	/^		inline void getBands(const VectorType& k,VectorType& eigenvals,ComplexMatrixType& eigenvects,$/;"	f	class:rpa::bandstructure
getBands	bilayer.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
getBands	bilayerFESC.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
getBands	coupledLadders.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
getBands	orthoIIBilayer.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
getBands	singleBand.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
getBands	tbFromFile.h	/^		inline void getBands(const VectorType k, VectorType& eigenvals, ComplexMatrixType& eigenvects, int spin=1) {$/;"	f	class:rpa::model
getBasicToken	PartialPsimag/TagAttributeParser.h	/^    bool getBasicToken() {$/;"	f	class:psimag::TagAttributeParser
getBasisVectors	PartialPsimag/Symmetry/Lattice.h	/^    void getBasisVectors(Matrix<Field>& basisVectors) {$/;"	f	class:psimag::Lattice
getBasisVectors	PartialPsimag/Symmetry/Lattice.h	/^    void getBasisVectors(std::vector<std::vector<Field> >& basisVectors) {$/;"	f	class:psimag::Lattice
getCartesianPosition	PartialPsimag/Symmetry/Star.h	/^    const CartesianPositionType& getCartesianPosition(size_t posIndex, const SymmetryType& symmetry) const {$/;"	f	class:psimag::Star
getCellPosition	PartialPsimag/Symmetry/Star.h	/^    const CellPositionType&   getCellPosition(size_t posIndex, const SymmetryType& symmetry) const {$/;"	f	class:psimag::Star
getChi0forQ	pairing.h	/^		void getChi0forQ(VectorType& q, SuscType& chi) {$/;"	f	class:rpa::pairing
getClusterSite	PsimagLite/src/Geometry/LadderBath.h	/^			PairType getClusterSite(size_t i) const$/;"	f	class:PsimagLite::LadderBath
getCol	PartialPsimag/Matrix.h	/^    RowSlice<ThisType> getCol(size_t colIndex)  {$/;"	f	class:psimag::Matrix
getCol	PartialPsimag/Matrix.h	/^    VectorType& getCol(size_t col, VectorType& result) const {$/;"	f	class:psimag::Matrix
getCol	PartialPsimag/Matrix.h	/^    const RowSlice<const ThisType> getCol(size_t colIndex) const {$/;"	f	class:psimag::Matrix
getCol	PsimagLite/src/CrsMatrix.h	/^		const int& getCol(int i) const { return colind_[i]; }$/;"	f	class:PsimagLite::CrsMatrix
getColumn	PsimagLite/src/LanczosSolver.h	/^		void getColumn(MatrixType const &mat,VectorType& x,size_t col)$/;"	f	class:PsimagLite::LanczosSolver
getCommFromSegments	PsimagLite/src/ConcurrencyMpi.h	/^		CommType getCommFromSegments(MPI_Group origGroup,std::vector<int>& rv)$/;"	f	class:PsimagLite::ConcurrencyMpi
getComponentWriter	PsimagLite/src/JSON/JSN_Writer.h	/^    ThisType& getComponentWriter(std::string key) { return writers[key]; }$/;"	f	class:dca::JSN
getCvQualifiers	PsimagLite/scripts/functionSigIndent.pl	/^sub getCvQualifiers$/;"	s
getDouble	PartialPsimag/Symmetry/AbstractRat.h	/^    double getDouble() {$/;"	f	class:psimag::AbstractRat
getEkAndAk	bandstructure.h	/^		void getEkAndAk(VectorType& kvec, VectorType& eigenvals, ComplexMatrixType& eigenvects, int spin=1)  {$/;"	f	class:rpa::bandstructure
getEqual	PartialPsimag/TagAttributeParser.h	/^    bool getEqual() {$/;"	f	class:psimag::TagAttributeParser
getEscapedCharacter	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    static wchar_t getEscapedCharacter(std::wistream& inputStream) {$/;"	f	class:JsonParser::CharacterMapper
getFirstPart	PsimagLite/scripts/FunctionParsing.pm	/^sub getFirstPart$/;"	s
getFirstPart	PsimagLite/scripts/functionSigIndent.pl	/^sub getFirstPart$/;"	s
getFloat	PartialPsimag/Symmetry/AbstractRat.h	/^	float getFloat() { return float(getDouble()); }$/;"	f	class:psimag::AbstractRat
getFunctionName	PsimagLite/scripts/pTeX.pl	/^sub getFunctionName$/;"	s
getGFor	sepBasis.h	/^		Field getGFor(const size_t iB,const size_t l1,const size_t l2) {$/;"	f	class:rpa::sepBasis
getGeometry	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t getGeometry(const std::string& s) const$/;"	f	class:PsimagLite::GeometryFactory
getGeometry1D	PartialPsimag/Symmetry/PsimagGeometry.h	/^	     void getGeometry1D(int length1d,$/;"	f	class:rpa::PsimagGeometry
getGeometry2D	PartialPsimag/Symmetry/PsimagGeometry.h	/^	     void getGeometry2D(Field latticeA_length, $/;"	f	class:rpa::PsimagGeometry
getIndexFor	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    static int getIndexFor(std::string name) {$/;"	f	class:psimag::SymmetryElements
getInt	PartialPsimag/Symmetry/FieldParser.h	/^inline  IntType getInt(const std::string& intString) {$/;"	f	namespace:psimag
getIntPair	PartialPsimag/Symmetry/FieldParser.h	/^    std::pair<IntType, IntType> getIntPair(const std::string& inString) {$/;"	f	class:psimag::FieldParser
getInterval	PsimagLite/src/AkimaSpline.h	/^		IntervalType getInterval() const { return interval_; }$/;"	f	class:AkimaSpline
getKeyValuePair	PartialPsimag/TagAttributeParser.h	/^    bool getKeyValuePair() {$/;"	f	class:psimag::TagAttributeParser
getLabel	PsimagLite/scripts/indentStrict.pl	/^sub getLabel$/;"	s
getLattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    LatticeType getLattice() {$/;"	f	class:psimag::ReciprocalLattice
getLevel	PsimagLite/scripts/FunctionParsing.pm	/^sub getLevel$/;"	s
getLevel	PsimagLite/scripts/functionSigIndent.pl	/^sub getLevel$/;"	s
getMeshGeometry	PartialPsimag/Symmetry/PsimagGeometry.h	/^	     void getMeshGeometry(int dim,$/;"	f	class:rpa::PsimagGeometry
getNetDirectionFor	PartialPsimag/Symmetry/SymmetryOperation.h	/^  const LatticeCoordinates<2> getNetDirectionFor(const CellPosition<Field,2,Algorithms>&  pt1,$/;"	f	namespace:psimag
getNextCharacterAndClass	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    std::pair<wchar_t,CharacterClass> getNextCharacterAndClass(std::wistream& inputStream) {$/;"	f	class:JsonParser::JsonParser
getNextFunction	PsimagLite/scripts/FunctionParsing.pm	/^sub getNextFunction$/;"	s
getO	PartialPsimag/Symmetry/Mat/MatMult.h	/^    template<size_t R, size_t C> class getO {$/;"	c	class:psimag::MatMultVecPos
getOccupant	PartialPsimag/Symmetry/Pattern.h	/^    const Occupant& getOccupant(int posIndex) const { $/;"	f	class:psimag::Pattern
getOccupant	PartialPsimag/Symmetry/PatternData.h	/^    const Occupant& getOccupant(CellPositionType& position) const { $/;"	f	class:psimag::PatternData
getOccupant	PartialPsimag/Symmetry/Star.h	/^    const Occupant& getOccupant(size_t posIndex, const SymmetryType& symmetry) const {$/;"	f	class:psimag::Star
getPostQualifier	PsimagLite/scripts/FunctionParsing.pm	/^sub getPostQualifier$/;"	s
getPostQualifier	PsimagLite/scripts/functionSigIndent.pl	/^sub getPostQualifier$/;"	s
getPrime	PartialPsimag/Symmetry/AbstractRat.h	/^    int getPrime(const size_t idx) const {$/;"	f	class:psimag::AbstractRat
getPrime	PartialPsimag/Symmetry/FieldParser.h	/^    IntType getPrime(std::string& term){$/;"	f	class:psimag::FieldParser
getPrimeIndex	PartialPsimag/Symmetry/AbstractRat.h	/^    size_t getPrimeIndex(const int prime) const {$/;"	f	class:psimag::AbstractRat
getQuotedOrBasicToken	PartialPsimag/TagAttributeParser.h	/^    bool getQuotedOrBasicToken() {$/;"	f	class:psimag::TagAttributeParser
getQuotedToken	PartialPsimag/TagAttributeParser.h	/^    bool getQuotedToken() {$/;"	f	class:psimag::TagAttributeParser
getRating	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    Field getRating( const Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>& symmetry) {$/;"	f	class:psimag::SpaceGroup
getRational	PartialPsimag/Symmetry/AbstractRat.h	/^    Rat& getRational(Rat& result) {$/;"	f	class:psimag::AbstractRat
getReciprocalSuperCrystalPattern	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    const PatternType getReciprocalSuperCrystalPattern() const {$/;"	f	class:psimag::SuperCrystalBuilder
getRow	PartialPsimag/Matrix.h	/^    RowSlice<ThisType> getRow(size_t rowIndex)  {$/;"	f	class:psimag::Matrix
getRow	PartialPsimag/Matrix.h	/^    VectorType& getRow(size_t row, VectorType& result) const {$/;"	f	class:psimag::Matrix
getRowPtr	PsimagLite/src/CrsMatrix.h	/^		const int& getRowPtr(size_t i) const { assert(i<rowptr_.size()); return rowptr_[i]; }$/;"	f	class:PsimagLite::CrsMatrix
getSegmentsAdjuct	PsimagLite/src/ConcurrencyMpi.h	/^		void getSegmentsAdjuct(std::vector<int>& rv,size_t numberOfSegments,size_t segmentSize,size_t r)$/;"	f	class:PsimagLite::ConcurrencyMpi
getSegmentsDirect	PsimagLite/src/ConcurrencyMpi.h	/^		void getSegmentsDirect(std::vector<int>& rv,size_t numberOfSegments,size_t segmentSize,size_t r)$/;"	f	class:PsimagLite::ConcurrencyMpi
getSlope	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  Field getSlope(const LatticeCoordinates<2> coord) {$/;"	f	namespace:psimag
getSpacesAndTabs	PsimagLite/scripts/spacesIntoTabs.pl	/^sub getSpacesAndTabs$/;"	s
getStateActionPair	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^    static Pair getStateActionPair(StateType state, CharacterClass cls) {$/;"	f	class:JsonParser::AugmentedStateTranslationTable
getSubLatticeVecCoords	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    const SubLatticeVecCoordsType& getSubLatticeVecCoords() const {$/;"	f	class:psimag::SuperCrystalBuilder
getSubstituteSite	PsimagLite/src/Geometry/Chain.h	/^			size_t getSubstituteSite(size_t smax,size_t emin,size_t siteNew2) const$/;"	f	class:PsimagLite::Chain
getSubstituteSite	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t getSubstituteSite(size_t smax,size_t emin,size_t siteNew2) const$/;"	f	class:PsimagLite::GeometryFactory
getSubstituteSite	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t getSubstituteSite(size_t smax,size_t emin,size_t siteNew2) const$/;"	f	class:PsimagLite::KTwoNiFFour
getSubstituteSite	PsimagLite/src/Geometry/Ladder.h	/^		size_t getSubstituteSite(size_t smax,size_t emin,size_t siteNew2) const$/;"	f	class:PsimagLite::Ladder
getSubstituteSite	PsimagLite/src/Geometry/LadderBath.h	/^			size_t getSubstituteSite(size_t smax,size_t emin,size_t siteNew2) const$/;"	f	class:PsimagLite::LadderBath
getSubstituteSite	PsimagLite/src/Geometry/LadderX.h	/^			size_t getSubstituteSite(size_t smax,size_t emin,size_t siteNew2) const$/;"	f	class:PsimagLite::LadderX
getSurroundingIndices	momentumDomain.h	/^		void getSurroundingIndices(VectorType& q, $/;"	f	class:rpa::momentumDomain
getTerm	PartialPsimag/Symmetry/FieldParser.h	/^    void getTerm(const std::string& termStr){$/;"	f	class:psimag::FieldParser
getTiledLatticeWithPattern	PartialPsimag/Symmetry/FloodTiler.h	/^    LatticeWithPatternType getTiledLatticeWithPattern() {$/;"	f	class:psimag::FloodTiler
getTimeDate	PsimagLite/src/HostInfo.h	/^		std::string getTimeDate()$/;"	f	class:PsimagLite::HostInfo
getTranslation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    const TranslationType& getTranslation() {$/;"	f	class:psimag::SeitzMatrix
getTranslationPart	PartialPsimag/Symmetry/Glide2D.h	/^    static TranslationType getTranslationPart(CartesianTranslationType glideVector, $/;"	f	class:psimag::Glide
getValue	PsimagLite/src/CrsMatrix.h	/^		const T& getValue(int i) const { return values_[i]; }$/;"	f	class:PsimagLite::CrsMatrix
getVectorSize	PsimagLite/src/Geometry/Chain.h	/^			size_t getVectorSize(size_t dirId) const$/;"	f	class:PsimagLite::Chain
getVectorSize	PsimagLite/src/Geometry/GeometryDirection.h	/^			size_t getVectorSize(const std::string& s)$/;"	f	class:PsimagLite::GeometryDirection
getVectorSize	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t getVectorSize(size_t dirId) const$/;"	f	class:PsimagLite::GeometryFactory
getVectorSize	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t getVectorSize(size_t dirId) const$/;"	f	class:PsimagLite::KTwoNiFFour
getVectorSize	PsimagLite/src/Geometry/Ladder.h	/^		size_t getVectorSize(size_t dirId) const$/;"	f	class:PsimagLite::Ladder
getVectorSize	PsimagLite/src/Geometry/LadderBath.h	/^			size_t getVectorSize(size_t dirId) const$/;"	f	class:PsimagLite::LadderBath
getVectorSize	PsimagLite/src/Geometry/LadderX.h	/^			size_t getVectorSize(size_t dirId) const$/;"	f	class:PsimagLite::LadderX
getWhiteSpace	PartialPsimag/TagAttributeParser.h	/^    bool getWhiteSpace() {$/;"	f	class:psimag::TagAttributeParser
get_FSpoints	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def get_FSpoints(self,nk=1024):$/;"	m	class:RPA
glideFraction	PartialPsimag/Symmetry/SymmetryElement.h	/^    Field                   glideFraction;$/;"	m	class:psimag::SymmetryElement
glueArgs	PsimagLite/scripts/FunctionParsing.pm	/^sub glueArgs$/;"	s
glueArgs	PsimagLite/scripts/functionSigIndent.pl	/^sub glueArgs$/;"	s
greensFunction	greensFunction.h	/^	class greensFunction:$/;"	c	namespace:rpa
greensFunction	greensFunction.h	/^	greensFunction(const rpa::parameters<Field,MatrixTemplate>& parameters):$/;"	f	class:rpa::greensFunction
gridspec	PythonScripts/Bandstructure.py	/^import matplotlib.gridspec as gridspec$/;"	i
gridspec	PythonScripts/Plot_chiRPA_w.py	/^import matplotlib.gridspec as gridspec$/;"	i
ground	PsimagLite/src/LanczosSolver.h	/^		void ground(RealType &s,int n, const TridiagonalMatrixType& ab,std::vector<RealType>& gs)$/;"	f	class:PsimagLite::LanczosSolver
group	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    GroupType                          group;$/;"	m	class:psimag::GroupMultiplicationTable
group	PartialPsimag/Symmetry/Star.h	/^    GroupType                group;$/;"	m	class:psimag::Star
group	PartialPsimag/Symmetry/SymmetryGroup.h	/^    const GroupType&                         group;           \/\/ kept in multiplication table$/;"	m	class:psimag::SymmetryGroup
groupAction	PartialPsimag/Symmetry/Star.h	/^    Matrix<int>              groupAction;$/;"	m	class:psimag::Star
groupAction	PartialPsimag/Symmetry/SymmetryGroup.h	/^    GroupActionType                          groupAction;$/;"	m	class:psimag::SymmetryGroup
gslS_	PsimagLite/src/Minimizer.h	/^		gsl_multimin_fminimizer *gslS_;$/;"	m	class:PsimagLite::Minimizer
gslT_	PsimagLite/src/Minimizer.h	/^		const gsl_multimin_fminimizer_type *gslT_;$/;"	m	class:PsimagLite::Minimizer
gsl_error_handler_t	PsimagLite/src/GslWrapper.h	/^		typedef void (* gsl_error_handler_t) (const char *,const char *,int,int);$/;"	t	class:PsimagLite::GslWrapper
gsl_function	PsimagLite/src/GslWrapper.h	/^		struct gsl_function {$/;"	s	class:PsimagLite::GslWrapper
gsl_integration_qagp	PsimagLite/src/GslWrapper.h	/^		int gsl_integration_qagp (const gsl_function * f, double * pts, size_t npts, double epsabs, $/;"	f	class:PsimagLite::GslWrapper
gsl_integration_workspace	PsimagLite/src/GslWrapper.h	/^		typedef DummyType gsl_integration_workspace;$/;"	t	class:PsimagLite::GslWrapper
gsl_integration_workspace_alloc	PsimagLite/src/GslWrapper.h	/^		gsl_integration_workspace * gsl_integration_workspace_alloc (size_t n) const$/;"	f	class:PsimagLite::GslWrapper
gsl_integration_workspace_free	PsimagLite/src/GslWrapper.h	/^		void gsl_integration_workspace_free (gsl_integration_workspace * w) const$/;"	f	class:PsimagLite::GslWrapper
gsl_set_error_handler	PsimagLite/src/GslWrapper.h	/^		gsl_error_handler_t  gsl_set_error_handler (gsl_error_handler_t  new_handler) const$/;"	f	class:PsimagLite::GslWrapper
handle	PsimagLite/src/Geometry/Chain.h	/^			size_t handle(size_t i,size_t j) const$/;"	f	class:PsimagLite::Chain
handle	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t handle(size_t i,size_t j) const$/;"	f	class:PsimagLite::GeometryFactory
handle	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t handle(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::KTwoNiFFour
handle	PsimagLite/src/Geometry/Ladder.h	/^		size_t handle(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Ladder
handle	PsimagLite/src/Geometry/LadderBath.h	/^			size_t handle(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderBath
handle	PsimagLite/src/Geometry/LadderX.h	/^			size_t handle(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderX
handleInCluster	PsimagLite/src/Geometry/LadderBath.h	/^			size_t handleInCluster(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::LadderBath
hasNonBlank	utilities.h	/^bool hasNonBlank(const std::string& b)$/;"	f
hasSameAction	PartialPsimag/Symmetry/GroupAction.h	/^    bool hasSameAction(int op1, int op2) const {$/;"	f	class:psimag::GroupAction
has_fixed_range	PartialPsimag/KISS.h	/^    static const bool has_fixed_range = false;$/;"	m	class:psimag::KISS
hermiteNormalForm	PartialPsimag/Symmetry/SymmetryOperation.h	/^    HermiteNormalFormType hermiteNormalForm() const {$/;"	f	class:psimag::SymmetryOperation
hookForZ	PsimagLite/src/LanczosVectors.h	/^		void hookForZ(VectorType& z,const std::vector<RealType>& c)$/;"	f	class:PsimagLite::LanczosVectors
hookForZ	PsimagLite/src/LanczosVectors.h	/^		void hookForZ(const VectorType& y,$/;"	f	class:PsimagLite::LanczosVectors
ht	bands.h	/^		std::vector<Field> dx,dy,dz,ht;$/;"	m	class:rpa::Bands
ht	bandstructure.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::bandstructure
ht	tbFromFile.h	/^		VectorType dx,dy,dz,ht;$/;"	m	class:rpa::model
hyb	parameters.h	/^		bool hyb;$/;"	m	class:rpa::parameters
hybBand1	parameters.h	/^		size_t hybBand1;$/;"	m	class:rpa::parameters
hybBand2	parameters.h	/^		size_t hybBand2;$/;"	m	class:rpa::parameters
hybStrength	parameters.h	/^		Field hybStrength;$/;"	m	class:rpa::parameters
i	PartialPsimag/KISS.h	/^    seed_type i,j,k;  \/\/ these constitute the state of the generator$/;"	m	class:psimag::KISS
iOfOmega	PsimagLite/src/ChebyshevSerializer.h	/^		RealType iOfOmega(const RealType& z,RealType offset,int isign) const$/;"	f	class:PsimagLite::ChebyshevSerializer
iOfOmega	PsimagLite/src/ContinuedFraction.h	/^		ComplexType iOfOmega(const ComplexType& z,RealType offset,int isign) const$/;"	f	class:PsimagLite::ContinuedFraction
id	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    int                                       id;$/;"	m	class:psimag::AppliedSymmetryElement
id	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    int                      id;$/;"	m	class:psimag::AppliedSymmetryElement
id	PartialPsimag/Symmetry/Occupant.h	/^    std::string id;$/;"	m	class:psimag::Occupant
id	PartialPsimag/Symmetry/SymmetryElement.h	/^    int                     id;$/;"	m	class:psimag::SymmetryElement
ident	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    static SymmetryOperationType ident() {$/;"	f	class:psimag::SymmetryOperations
identity	PartialPsimag/Symmetry/CellRotation.h	/^    typedef enum { sixfoldInv=-6, fourfoldInv=-4, threefoldInv=-3, twofoldInv=-2, inversion=-1, identity=1, $/;"	e	enum:psimag::CellRotation::__anon62
ignore	PartialPsimag/TagAttributeParser.h	/^    const string     ignore;$/;"	m	class:psimag::TagAttributeParser
ignoreTillSeperator	PartialPsimag/TagAttributeParser.h	/^    bool ignoreTillSeperator() {$/;"	f	class:psimag::TagAttributeParser
ii	coupledLadders.h	/^		const ComplexType ii;$/;"	m	class:rpa::model
ii	rpa.h	/^			ComplexType ii;$/;"	m	class:rpa::interaction
ii	singleBand.h	/^		const ComplexType ii;$/;"	m	class:rpa::model
ik_2_ikxiky	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def ik_2_ikxiky(self,ik):$/;"	m	class:RPA
ik_2_ikxiky	PythonScripts/Sr2RuO4.py	/^        def ik_2_ikxiky(self,ik):$/;"	m	class:RPA
ikxiky_2_ik	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def ikxiky_2_ik(self,ikx,iky):$/;"	m	class:RPA
ikxiky_2_ik	PythonScripts/Sr2RuO4.py	/^        def ikxiky_2_ik(self,ikx,iky):$/;"	m	class:RPA
imag	PsimagLite/src/Complex.h	/^	double imag(double t) { return 0.0; }$/;"	f	namespace:std
imp	PythonScripts/Bandstructure.py	/^import imp$/;"	i
imp	PythonScripts/Calc_lambda.py	/^import imp$/;"	i
imp	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^import imp$/;"	i
imp	PythonScripts/CoupledLadders.py	/^import imp$/;"	i
imp	PythonScripts/Plot_chiRPA_w.py	/^import imp$/;"	i
imp	PythonScripts/Sr2RuO4.py	/^import imp$/;"	i
imp	PythonScripts/plotChiRPAAlongHighSym.py	/^import imp$/;"	i
inOrder	PartialPsimag/Symmetry/Lattice.h	/^    CartesianTranslationType inOrder(size_t i) {$/;"	f	class:psimag::Lattice
increment	PartialPsimag/MatrixLike.h	/^    MatrixLikeType& increment(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
increment	PartialPsimag/VectorLike.h	/^    VectorLikeType& increment(VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
increment	PsimagLite/src/JSON/MatrixLike.h	/^    MatrixLikeType& increment(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
index	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static size_t index(size_t row, size_t col) {$/;"	f	class:psimag::ColMajorTraits
index	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static size_t index(size_t row, size_t col) {$/;"	f	class:psimag::ConstantTraits
index	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static size_t index(size_t row, size_t col) {$/;"	f	class:psimag::RowMajorTraits
index	PsimagLite/src/Geometry/GeometryFactory.h	/^		int index(size_t i1,size_t edof1,size_t edofTotal) const$/;"	f	class:PsimagLite::GeometryFactory
index	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		int index(size_t i,size_t orb) const$/;"	f	class:PsimagLite::KTwoNiFFour
index	PsimagLite/src/Range.h	/^		size_t index() const { return myIndices_[step_]; }$/;"	f	class:PsimagLite::Range
index	PsimagLite/src/Range.h	/^		size_t index() const { return step_; }$/;"	f	class:PsimagLite::Range
index	momentumDomain.h	/^		size_t index(size_t ikx,size_t iky,size_t ikz=0) const {$/;"	f	class:rpa::momentumDomain
index2Components	momentumDomain.h	/^		MatrixIntType index2Components;$/;"	m	class:rpa::momentumDomain
indexFor	PartialPsimag/Symmetry/Symmetry.h	/^    int indexFor(int id) {$/;"	f	class:psimag::Symmetry
indexOf	PartialPsimag/Symmetry/Pattern.h	/^    size_t indexOf(const CellPositionType& position) const {$/;"	f	class:psimag::Pattern
indexOfAdd	momentumDomain.h	/^		MatrixIntType indexOfAdd;$/;"	m	class:rpa::momentumDomain
indexToOrb	parameters.h	/^		IntMatrixType indexToOrb;$/;"	m	class:rpa::parameters
indexToiq	susceptibility.h	/^			std::vector<size_t> indexToiq;$/;"	m	class:rpa::susceptibility
indexToiw	susceptibility.h	/^			std::vector<size_t> indexToiw;$/;"	m	class:rpa::susceptibility
indicesOfThisProc_	PsimagLite/src/Range.h	/^		std::vector<std::vector<size_t> > indicesOfThisProc_; \/\/ given rank and step it maps the index$/;"	m	class:PsimagLite::Range
info	PsimagLite/src/ChebyshevSolver.h	/^		void info(RealType energyTmp,const VectorType& x,std::ostream& os)$/;"	f	class:PsimagLite::ChebyshevSolver
info	PsimagLite/src/LanczosSolver.h	/^		void info(RealType energyTmp,const VectorType& x,std::ostream& os)$/;"	f	class:PsimagLite::LanczosSolver
init	PartialPsimag/Matrix.h	/^    void init(bool own,size_type m,size_type n, size_type ld) $/;"	f	class:psimag::Matrix
init	PartialPsimag/Symmetry/GroupAction.h	/^    void init()$/;"	f	class:psimag::GroupAction
init	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    void init(const AppliedSymmetryElementsPtrType& initialElements)$/;"	f	class:psimag::GroupMultiplicationTable
init	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    void init(const AppliedSymmetryElementsType& initialElements)$/;"	f	class:psimag::GroupMultiplicationTable
init	PartialPsimag/Symmetry/Orbits.h	/^    void init(const std::vector<AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> *>& appliedElements,$/;"	f	class:psimag::Orbits
init	PartialPsimag/Symmetry/Star.h	/^    void init(const SymmetryType& symmetry)$/;"	f	class:psimag::Star
init	PartialPsimag/Symmetry/SymmetryGroup.h	/^    void init(const AppliedSymmetryElementsPtrType& initalAppliedElements)$/;"	f	class:psimag::SymmetryGroup
init	PartialPsimag/Symmetry/SymmetryGroup.h	/^    void init(const AppliedSymmetryElementsType& initalAppliedElements)$/;"	f	class:psimag::SymmetryGroup
init	PsimagLite/src/Geometry/GeometryFactory.h	/^		void init(IoType& io,const std::string& s,size_t linSize)$/;"	f	class:PsimagLite::GeometryFactory
init	PsimagLite/src/Range.h	/^		void init(const std::vector<size_t>& weights,CommType mpiComm)$/;"	f	class:PsimagLite::Range
init	greensFunction.h	/^	void init() {$/;"	f	class:rpa::greensFunction
initFlags	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void initFlags() {$/;"	f	class:psimag::BackSubstitution
initKernel	PsimagLite/src/ChebyshevSerializer.h	/^		void initKernel(std::vector<RealType>& gn,$/;"	f	class:PsimagLite::ChebyshevSerializer
initKernelJackson	PsimagLite/src/ChebyshevSerializer.h	/^		void initKernelJackson(std::vector<RealType>& gn) const$/;"	f	class:PsimagLite::ChebyshevSerializer
initKernelLorentz	PsimagLite/src/ChebyshevSerializer.h	/^		void initKernelLorentz(std::vector<RealType>& gn,$/;"	f	class:PsimagLite::ChebyshevSerializer
initialize	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    void initialize(size_t number_, $/;"	f	class:psimag::SpaceGroup
input	PartialPsimag/Symmetry/FieldParser.h	/^    std::string  input;$/;"	m	class:psimag::FieldParser
input	PartialPsimag/TagAttributeParser.h	/^    const string     input;$/;"	m	class:psimag::TagAttributeParser
inputStream	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    std::wifstream& inputStream;$/;"	m	class:JsonParser::MatrixParser
insert	PartialPsimag/Symmetry/PatternData.h	/^    void insert(const Occupant& occupant, const CellPositionType& cellPosition) {$/;"	f	class:psimag::PatternData
insertRaw	PartialPsimag/Symmetry/PatternData.h	/^    void insertRaw(const Occupant& occupant, const CellPositionType& cellPosition) {$/;"	f	class:psimag::PatternData
insertSkipDup	PartialPsimag/Symmetry/PatternData.h	/^    void insertSkipDup(const Occupant& occupant, const CellPositionType& cellPosition) {$/;"	f	class:psimag::PatternData
inside	PartialPsimag/Symmetry/FloodTiler.h	/^    std::map<CoordType, bool>       inside;$/;"	m	class:psimag::FloodTiler
inspectEigenvector	tbFromFile.h	/^		bool inspectEigenvector(ComplexMatrixType& matrix, size_t colIndex) {$/;"	f	class:rpa::model
intMatrices	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, const psimag::Matrix<int>*>    intMatrices;$/;"	m	class:dca::JSN
intensity_	PsimagLite/src/ContinuedFraction.h	/^		std::vector<RealType> intensity_;$/;"	m	class:PsimagLite::ContinuedFraction
interaction	rpa.h	/^		interaction(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::interaction
interaction	rpa.h	/^	class interaction {$/;"	c	namespace:rpa
interactionEmery	rpa_CuO.h	/^		interactionEmery(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters):$/;"	f	class:rpa::interactionEmery
interactionEmery	rpa_CuO.h	/^	class interactionEmery { $/;"	c	namespace:rpa
intercept	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,2> intercept(const SeitzPosition<Field,2>& position1, $/;"	f	namespace:psimag
interp2d	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^		from scipy.interpolate import interp2d$/;"	i
interpolateChi	parameters.h	/^		size_t interpolateChi;$/;"	m	class:rpa::parameters
interpolateChi_	pairing.h	/^		size_t interpolateChi_;$/;"	m	class:rpa::pairing
interpolateNqx	parameters.h	/^		size_t interpolateNqx;$/;"	m	class:rpa::parameters
interpolateNqz	parameters.h	/^		size_t interpolateNqz;$/;"	m	class:rpa::parameters
interpolation	interpolation.h	/^		interpolation(const momentumDomain<FieldType,MatrixTemplate,ConcurrencyType>& kMeshIn,$/;"	f	class:rpa::interpolation
interpolation	interpolation.h	/^	class interpolation{$/;"	c	namespace:rpa
interval_	PsimagLite/src/AkimaSpline.h	/^		IntervalType interval_;$/;"	m	class:AkimaSpline
intvectors	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, std::vector<int> >             intvectors;$/;"	m	class:dca::JSN
inv	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianRotation<Field, DIM>* inv;$/;"	m	class:psimag::CartesianRotation
inv	PartialPsimag/Symmetry/CellRotation.h	/^    CellRotation<Field, DIM>* inv;$/;"	m	class:psimag::CellRotation
invRotation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    RotationType             invRotation;$/;"	m	class:psimag::SeitzMatrix
invSet	PartialPsimag/Symmetry/CartesianRotation.h	/^    bool        invSet;$/;"	m	class:psimag::CartesianRotation
invSet	PartialPsimag/Symmetry/CellRotation.h	/^    bool        invSet;$/;"	m	class:psimag::CellRotation
invSet	PartialPsimag/Symmetry/SeitzMatrix.h	/^    bool                     invSet;$/;"	m	class:psimag::SeitzMatrix
invT	chi0.h	/^		FieldType invT;$/;"	m	class:rpa::calcChi0Matrix
invTranslation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    TranslationType          invTranslation;$/;"	m	class:psimag::SeitzMatrix
inverse	PartialPsimag/Symmetry/CartesianRotation.h	/^    const CartesianRotation<Field, DIM>& inverse() {$/;"	f	class:psimag::CartesianRotation
inverse	PartialPsimag/Symmetry/CellRotation.h	/^    const CellRotation<Field, DIM>& inverse() {$/;"	f	class:psimag::CellRotation
inverse	PartialPsimag/Symmetry/LatticeTransformation.h	/^    InverseLatticeTransformationType inverse()   {$/;"	f	class:psimag::LatticeTransformation
inverse	PartialPsimag/Symmetry/SeitzMatrix.h	/^    const SeitzMatrix<Field, DIM> inverse()  {$/;"	f	class:psimag::SeitzMatrix
inverse	PartialPsimag/Symmetry/SeitzMatrix.h	/^    const SeitzMatrix<Field, DIM> inverse() const {$/;"	f	class:psimag::SeitzMatrix
inverseBasis	PartialPsimag/Symmetry/Lattice.h	/^    MatType                     inverseBasis;     $/;"	m	class:psimag::Lattice
inverseBasisSet	PartialPsimag/Symmetry/Lattice.h	/^    bool                        inverseBasisSet;  $/;"	m	class:psimag::Lattice
inversion	PartialPsimag/Symmetry/CellRotation.h	/^    typedef enum { sixfoldInv=-6, fourfoldInv=-4, threefoldInv=-3, twofoldInv=-2, inversion=-1, identity=1, $/;"	e	enum:psimag::CellRotation::__anon62
invert	PartialPsimag/Matrix.h	/^  void invert(psimag::Matrix<T> &A)$/;"	f	namespace:psimag
involuntaryContextSwitches	PsimagLite/src/Rusage.h	/^		long involuntaryContextSwitches() const { return rusage_.ru_nivcsw; }$/;"	f	class:PsimagLite::Rusage
iqcalc	pairing.h	/^		size_t iqcalc;$/;"	m	class:rpa::pairing
isClosestToZero	PartialPsimag/Symmetry/fetchMeshWignerSeitz.h	/^  bool isClosestToZero(std::vector<Field> const &thisMeshPoint,psimag::Matrix<Field> const &sitesK,int i)$/;"	f	namespace:rpa
isDiagonal	PsimagLite/src/CrsMatrix.h	/^	bool isDiagonal(const CrsMatrix<T>& A) $/;"	f	namespace:PsimagLite
isHermitian	PsimagLite/src/CrsMatrix.h	/^	bool isHermitian(const CrsMatrix<T>& A,bool doThrow=false)$/;"	f	namespace:PsimagLite
isHermitian	PsimagLite/src/Matrix.h	/^	bool isHermitian(Matrix<T> const &A,bool verbose=false)$/;"	f	namespace:PsimagLite
isHyZero	PsimagLite/src/LanczosVectors.h	/^		bool isHyZero(const VectorType& y,$/;"	f	class:PsimagLite::LanczosVectors
isInVector	PsimagLite/scripts/functionSigIndent.pl	/^sub isInVector$/;"	s
isInVector	PsimagLite/src/Vector.h	/^	int isInVector(std::vector<X> const &natBasis,Y const &v)$/;"	f	namespace:PsimagLite
isInverted	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		bool isInverted(size_t i) const$/;"	f	class:PsimagLite::KTwoNiFFour
isNegative	PartialPsimag/Symmetry/CellTranslation.h	/^  bool isNegative(const SeitzVector<Field,DIM,IND>& v) {$/;"	f	namespace:psimag
isRedundantAction	PartialPsimag/Symmetry/GroupAction.h	/^    bool isRedundantAction(int op, std::vector<int>& ops) const {$/;"	f	class:psimag::GroupAction
isState	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^    static bool isState(StatesAndActionsType stateOrAction) {$/;"	f	class:JsonParser::StatesAndActionsMixin
isStrict_	PsimagLite/src/Range.h	/^		bool isStrict_; \/\/ does nproc need to divide total?$/;"	m	class:PsimagLite::Range
isTheIdentity	PsimagLite/src/CrsMatrix.h	/^	bool isTheIdentity(const CrsMatrix<T>& A) $/;"	f	namespace:PsimagLite
isTheIdentity	PsimagLite/src/Matrix.h	/^	bool isTheIdentity(Matrix<T> const &a)$/;"	f	namespace:PsimagLite
isVertical	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  inline bool isVertical(LatticeCoordinates<2> coord) {$/;"	f	namespace:psimag
isWhiteSpace	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    static bool isWhiteSpace(CharacterClass nextClass) {$/;"	f	class:JsonParser::CharacterMapper
isZero	PsimagLite/src/Matrix.h	/^	bool isZero(Matrix<std::complex<T> > const &a)$/;"	f	namespace:PsimagLite
isZero	PsimagLite/src/Matrix.h	/^	bool isZero(const PsimagLite::Matrix<T>& m)$/;"	f	namespace:PsimagLite
is_legal_white_space	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    static bool is_legal_white_space(const std::wstring& s) {$/;"	f	class:JsonParser::CharacterMapper
isign	PsimagLite/src/ParametersForSolver.h	/^		int isign;$/;"	m	struct:PsimagLite::ParametersForSolver
isign_	PsimagLite/src/ContinuedFraction.h	/^		int isign_;$/;"	m	class:PsimagLite::ContinuedFraction
iterationCount	PsimagLite/src/JSON/OperationClosure.h	/^    size_t iterationCount;$/;"	m	class:psimag::UnaryOperationClosure
iterator	PartialPsimag/Matrix.h	/^    typedef T*           iterator;$/;"	t	class:psimag::Matrix
iterator	PartialPsimag/Vec.h	/^    typedef T* iterator;$/;"	t	class:psimag::Vec
j	PartialPsimag/KISS.h	/^    seed_type i,j,k;  \/\/ these constitute the state of the generator$/;"	m	class:psimag::KISS
k	PartialPsimag/KISS.h	/^    seed_type i,j,k;  \/\/ these constitute the state of the generator$/;"	m	class:psimag::KISS
k	sepBasis.h	/^			VectorType& k;$/;"	m	class:rpa::sepBasis
k0	gaps3D.h	/^        std::vector<FieldType> k0;$/;"	m	class:rpa::gap3D
kDomain	bandstructure.h	/^		typedef momentumDomain<Field,MatrixTemplate,ConcurrencyType> kDomain;$/;"	t	class:rpa::bandstructure
kFtoBand	ferminator.h	/^		VectorIntType kFtoBand;$/;"	m	class:rpa::ferminator
kFtoBand	pairing.h	/^		std::vector<int> kFtoBand;$/;"	m	class:rpa::pairing
kFx	ferminator.h	/^		VectorType kFx,kFy,kFz;$/;"	m	class:rpa::ferminator
kFy	ferminator.h	/^		VectorType kFx,kFy,kFz;$/;"	m	class:rpa::ferminator
kFz	ferminator.h	/^		VectorType kFx,kFy,kFz;$/;"	m	class:rpa::ferminator
kMap	susceptibility.h	/^			bool kMap;$/;"	m	class:rpa::susceptibility
kMap_	chi0.h	/^		bool kMap_;$/;"	m	class:rpa::calcChi0Matrix
kMesh	interpolation.h	/^		const momentumDomain<Field,MatrixTemplate,ConcurrencyType>&	kMesh;$/;"	m	class:rpa::interpolation
kMesh	pairing.h	/^		momentumDomain<FieldType,psimag::Matrix,ConcurrencyType> kMesh;$/;"	m	class:rpa::pairing
kToik	momentumDomain.h	/^		void kToik(VectorType& k, size_t& ik, Field& residue, bool map1BZ = false) const {$/;"	f	class:rpa::momentumDomain
kTrafo	parameters.h	/^		size_t kTrafo;$/;"	m	class:rpa::parameters
key	PartialPsimag/TagAttributes.h	/^    std::string                         key;$/;"	m	class:psimag::TagAttributesClosure
key	PsimagLite/src/JSON/JSN_Writer.h	/^      std::string key;$/;"	m	class:dca::JSN::KeyReference
key	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    std::wstring              key;$/;"	m	class:JsonParser::DefaultContext
kill	PartialPsimag/Matrix.h	/^    void kill () {$/;"	f	class:psimag::Matrix
kmesh	bandstructure.h	/^		const kDomain& kmesh;$/;"	m	class:rpa::bandstructure
kmesh	chi0.h	/^		const momentumDomain<Field,MatrixTemplate,ConcurrencyType>& kmesh;$/;"	m	class:rpa::calcChi0Matrix
kmesh_	bandstructure.h	/^		kDomain kmesh_;$/;"	m	class:rpa::bandstructure
ktwoniffour_	PsimagLite/src/Geometry/GeometryFactory.h	/^		KTwoNiFFour* ktwoniffour_;$/;"	m	class:PsimagLite::GeometryFactory
kz	gaps3D.h	/^        std::vector<std::vector<FieldType> > kz;$/;"	m	class:rpa::gap3D
kz2D	parameters.h	/^		Field kz2D;$/;"	m	class:rpa::parameters
l2norm	PartialPsimag/Symmetry/SeitzVector.h	/^    Field l2norm ()  { $/;"	f	class:psimag::SeitzVector
lDim	PartialPsimag/Matrix.h	/^    size_type nRow,nCol,lDim;$/;"	m	class:psimag::Matrix
l_dim	PartialPsimag/Matrix.h	/^    size_type l_dim() const { return lDim; }$/;"	f	class:psimag::Matrix
label	PsimagLite/src/Geometry/Chain.h	/^			std::string label() const$/;"	f	class:PsimagLite::Chain
label	PsimagLite/src/Geometry/Geometry.h	/^			std::string label(size_t i) const { return terms_[i].label(); }$/;"	f	class:PsimagLite::Geometry
label	PsimagLite/src/Geometry/GeometryFactory.h	/^		std::string label() const$/;"	f	class:PsimagLite::GeometryFactory
label	PsimagLite/src/Geometry/GeometryTerm.h	/^			std::string label() const$/;"	f	class:PsimagLite::GeometryTerm
label	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		std::string label() const$/;"	f	class:PsimagLite::KTwoNiFFour
label	PsimagLite/src/Geometry/Ladder.h	/^		std::string label() const$/;"	f	class:PsimagLite::Ladder
label	PsimagLite/src/Geometry/LadderBath.h	/^			std::string label() const$/;"	f	class:PsimagLite::LadderBath
label	PsimagLite/src/Geometry/LadderX.h	/^			std::string label() const$/;"	f	class:PsimagLite::LadderX
ladder_	PsimagLite/src/Geometry/GeometryFactory.h	/^		Ladder* ladder_;$/;"	m	class:PsimagLite::GeometryFactory
ladder_	PsimagLite/src/Geometry/LadderBath.h	/^			LadderType ladder_;$/;"	m	class:PsimagLite::LadderBath
ladder_	PsimagLite/src/Geometry/LadderX.h	/^			LadderType ladder_; \/\/ owner$/;"	m	class:PsimagLite::LadderX
ladderbath_	PsimagLite/src/Geometry/GeometryFactory.h	/^		LadderBath* ladderbath_;$/;"	m	class:PsimagLite::GeometryFactory
ladderize	PsimagLite/src/Geometry/LadderBath.h	/^			void ladderize(size_t& i1,size_t& i2) const$/;"	f	class:PsimagLite::LadderBath
ladderx_	PsimagLite/src/Geometry/GeometryFactory.h	/^		LadderX* ladderx_;$/;"	m	class:PsimagLite::GeometryFactory
lambda	PsimagLite/src/ChebyshevSerializer.h	/^		RealType lambda;$/;"	m	struct:PsimagLite::KernelPolynomialParameters
lambda_SO	parameters.h	/^		Field lambda_SO;$/;"	m	class:rpa::parameters
lanczosVectors_	PsimagLite/src/ChebyshevSolver.h	/^		LanczosVectorsType lanczosVectors_;$/;"	m	class:PsimagLite::ChebyshevSolver
lanczosVectors_	PsimagLite/src/LanczosSolver.h	/^		LanczosVectorsType lanczosVectors_;$/;"	m	class:PsimagLite::LanczosSolver
last	PartialPsimag/Matrix.h	/^    T&             last() { return col[nCol-1][nRow-1]; }$/;"	f	class:psimag::Matrix
last	PartialPsimag/Matrix.h	/^    const T&       last() const { return col[nCol-1][nRow-1]; }$/;"	f	class:psimag::Matrix
lastItemType	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    JsonType              lastItemType;    $/;"	m	class:JsonParser::JsonParser
lastRow	PartialPsimag/Symmetry/SeitzMatrix.h	/^    LastRowType              lastRow;$/;"	m	class:psimag::SeitzMatrix
latpat	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    const LatticeWithPatternType&      latpat;$/;"	m	class:psimag::GroupMultiplicationTable
latpat	PartialPsimag/Symmetry/Symmetry.h	/^    const LatticeWithPatternType latpat;$/;"	m	class:psimag::Symmetry
latpat	PartialPsimag/Symmetry/SymmetryGroup.h	/^    const LatticeWithPatternType&            latpat;$/;"	m	class:psimag::SymmetryGroup
lattice	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    const LatticeType& lattice;$/;"	m	class:psimag::ReciprocalLattice
latticeCoordinate	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  LatticeCoordinates<2> latticeCoordinate(Field slope) {$/;"	f	namespace:psimag
latticeCoordinate	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  LatticeCoordinates<2> latticeCoordinate(const CellTranslation<Field,2>& trans) {$/;"	f	namespace:psimag
latticeCoordinate	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  inline LatticeCoordinates<2> latticeCoordinate(int t0, int t1) {$/;"	f	namespace:psimag
latticeCoordinate	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  inline LatticeCoordinates<3> latticeCoordinate(int t0, int t1, int t2) {$/;"	f	namespace:psimag
latticeDistance	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    Field                                     latticeDistance;$/;"	m	class:psimag::AppliedSymmetryElement
latticeDistance	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    Field                    latticeDistance;$/;"	m	class:psimag::AppliedSymmetryElement
latticeTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^  LatticeTranslation<2> latticeTranslation(int t0, int t1) {$/;"	f	namespace:psimag
latticeTranslation	PartialPsimag/Symmetry/LatticeTranslation.h	/^  LatticeTranslation<2> latticeTranslation(int t0, int t1, int t2) {$/;"	f	namespace:psimag
leg_	PsimagLite/src/Geometry/Chain.h	/^			size_t leg_;$/;"	m	class:PsimagLite::Chain
leg_	PsimagLite/src/Geometry/Ladder.h	/^		size_t leg_;$/;"	m	class:PsimagLite::Ladder
leg_	PsimagLite/src/Geometry/LadderX.h	/^			size_t leg_;$/;"	m	class:PsimagLite::LadderX
len	PartialPsimag/TagAttributeParser.h	/^    string::size_type len;$/;"	m	class:psimag::TagAttributeParser
length	PartialPsimag/Symmetry/CartesianTranslation.h	/^    Field length() const {$/;"	f	class:psimag::CartesianTranslation
length	PartialPsimag/Symmetry/SeitzTranslation.h	/^    Field length(const Mat< Field, DIM, DIM  >& metric) {$/;"	f	class:psimag::SeitzTranslation
length	PartialPsimag/Symmetry/SeitzVector.h	/^  MatField length(SeitzVector<VecField,DIM,0> v, MatType<MatField,DIM,DIM> metric) {$/;"	f	namespace:psimag
length	PartialPsimag/VectorLike.h	/^    typename VectorLikeType::value_type length(const VectorLikeType& vector) {$/;"	f	namespace:psimag::VectorLike
lhs	PartialPsimag/OperationClosure.h	/^    const Operand1Type& lhs;$/;"	m	class:psimag::OperationClosure
lhs	PsimagLite/src/JSON/OperationClosure.h	/^    const Operand1Type& lhs;$/;"	m	class:psimag::OperationClosure
linSize_	PsimagLite/src/Geometry/Chain.h	/^			size_t linSize_;$/;"	m	class:PsimagLite::Chain
linSize_	PsimagLite/src/Geometry/Geometry.h	/^			size_t linSize_;$/;"	m	class:PsimagLite::Geometry
linSize_	PsimagLite/src/Geometry/GeometryTerm.h	/^			size_t linSize_;$/;"	m	class:PsimagLite::GeometryTerm
linSize_	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t linSize_;$/;"	m	class:PsimagLite::KTwoNiFFour
linSize_	PsimagLite/src/Geometry/Ladder.h	/^		size_t linSize_;$/;"	m	class:PsimagLite::Ladder
linSize_	PsimagLite/src/Geometry/LadderBath.h	/^			size_t linSize_;$/;"	m	class:PsimagLite::LadderBath
linSize_	PsimagLite/src/Geometry/LadderX.h	/^			size_t linSize_;$/;"	m	class:PsimagLite::LadderX
load	PartialPsimag/Matrix.h	/^    void load(std::string directory, int number)$/;"	f	class:psimag::Matrix
load	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^    static void load(const LatticeType& lattice, $/;"	f	class:psimag::SymmetryOperations
loadCartesian	PartialPsimag/Symmetry/Pattern.h	/^    void loadCartesian(Matrix<Field>& mat) {$/;"	f	class:psimag::Pattern
loadCellPositions	PartialPsimag/Symmetry/OriginLocator.h	/^    void loadCellPositions() {$/;"	f	class:psimag::OriginLocator
loadCellPositions	PartialPsimag/Symmetry/Pattern.h	/^    void loadCellPositions(Matrix<Field>& mat) {$/;"	f	class:psimag::Pattern
loadCellPositionsInto	PartialPsimag/Symmetry/PatternData.h	/^    void loadCellPositionsInto (PatternType& pat)  const {$/;"	f	class:psimag::PatternData
loadGroupData	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    void loadGroupData() {$/;"	f	class:psimag::SpaceGroup
loadMacros	PsimagLite/scripts/pTeX.pl	/^sub loadMacros$/;"	s
loadMatrixLikeFromFile	PsimagLite/src/JSON/JsonReader.h	/^  void loadMatrixLikeFromFile(MatrixLikeType& mat,$/;"	f	namespace:dca
loadPatternData	PartialPsimag/Symmetry/fetchGeometry2D.h	/^  void loadPatternData(int numPoints, $/;"	f	namespace:rpa
loadPatternData	PartialPsimag/Symmetry/fetchMesh.h	/^  void loadPatternData(int numPoints, PatternData<Field,DIM,Occupant,Algorithms>& patternData ) {$/;"	f	namespace:rpa
loadSpaceGroupData	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    void loadSpaceGroupData() {$/;"	f	class:psimag::SpaceGroup
loadVector	parameters.h	/^			void loadVector(std::vector<FieldType>& v,const std::string& vstring)$/;"	f	class:rpa::parameters
loadVector	utilities.h	/^void loadVector(std::vector<FieldType>& v,const std::string& myfile)$/;"	f
loaded	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    bool                                    loaded;$/;"	m	class:psimag::SpaceGroup
logfermi	PsimagLite/src/Fermi.h	/^	FieldType logfermi(const FieldType& x)$/;"	f	namespace:PsimagLite
lookFor	PsimagLite/src/JSON/JsonReader.h	/^    const JsonAccessor& lookFor(const std::string key) const {$/;"	f	class:dca::JsonReader
loopCreate	PsimagLite/src/NoPthreads.h	/^			void loopCreate(size_t total,PthreadFunctionHolderType& pfh)$/;"	f	class:PsimagLite::NoPthreads
loopCreate	PsimagLite/src/Pthreads.h	/^			void loopCreate(size_t total,PthreadFunctionHolderType& pfh)$/;"	f	class:PsimagLite::Pthreads
lotaMemory	PsimagLite/src/LanczosVectors.h	/^		bool lotaMemory() const { return lotaMemory_; }$/;"	f	class:PsimagLite::LanczosVectors
lotaMemory	PsimagLite/src/ParametersForSolver.h	/^		bool lotaMemory;$/;"	m	struct:PsimagLite::ParametersForSolver
lotaMemory_	PsimagLite/src/LanczosVectors.h	/^		bool lotaMemory_;$/;"	m	class:PsimagLite::LanczosVectors
m	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    const HermiteNormalForm<Field,NROW,NCOL>& m;$/;"	m	class:psimag::BackSubstitution
mag2	PartialPsimag/Symmetry/TestPattern.h	/^    Field mag2(size_t pos1, size_t pos2, const PatternType& otherPattern) const {$/;"	f	class:psimag::TestPattern
magnitude	PartialPsimag/Symmetry/SeitzMatrix.h	/^    Field magnitude() const {$/;"	f	class:psimag::SeitzMatrix
main	PsimagLite/drivers/akimaSpline.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/combineContinuedFraction.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/concurrencyTest.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/continuedFraction.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/continuedFractionCollection.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/jsonExample.cpp	/^int main(int argc,char *argv[]) {$/;"	f
main	PsimagLite/drivers/kernelPolynomial.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/linearPrediction.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/minimizer.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/randomTest.cpp	/^int main(int argc,char* argv[])$/;"	f
main	PsimagLite/drivers/range.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/testCRSMatrix.cpp	/^int main(int argc,char *argv[])$/;"	f
main	PsimagLite/drivers/testLapack.cpp	/^int main()$/;"	f
main	PsimagLite/src/JSON/JsonParser/main.cpp	/^int main(int argc,char *argv[]) {$/;"	f
main	main.cpp	/^int main(int argc,char *argv[])$/;"	f
make	PartialPsimag/Symmetry/CellPosition.h	/^    ThisType make(IN_TYPE x, IN_TYPE y) {$/;"	f	class:psimag::CellPosition
make	PartialPsimag/Symmetry/CellPosition.h	/^    ThisType make(IN_TYPE x, IN_TYPE y, IN_TYPE z) {$/;"	f	class:psimag::CellPosition
makeAcute	PartialPsimag/Symmetry/ReducedLattice.h	/^    void makeAcute(size_t b1i, size_t b2i) { negate(b2i); }$/;"	f	class:psimag::ReducedLattice
makeAppliedSymmetryElementsTag	PartialPsimag/Symmetry/SymmetryGroup.h	/^    Tag makeAppliedSymmetryElementsTag(const std::string& name="AppliedSymmetryElements") const {$/;"	f	class:psimag::SymmetryGroup
makeBasisFor	PartialPsimag/Symmetry/CellParameters.h	/^    void makeBasisFor(Lattice<Field,1,LAlgorithms>& cell) {$/;"	f	class:psimag::CellParameters
makeBasisFor	PartialPsimag/Symmetry/CellParameters.h	/^    void makeBasisFor(Lattice<Field,2,LAlgorithms>& cell) const {$/;"	f	class:psimag::CellParameters
makeBasisFor	PartialPsimag/Symmetry/CellParameters.h	/^    void makeBasisFor(Lattice<Field,3,LAlgorithms>& cell) {$/;"	f	class:psimag::CellParameters
makeDiagonal	PsimagLite/src/CrsMatrix.h	/^		void makeDiagonal(int rank,T const &value=0) $/;"	f	class:PsimagLite::CrsMatrix
makeOrbitFor	PartialPsimag/Symmetry/Orbits.h	/^    size_t makeOrbitFor(size_t posIndex,$/;"	f	class:psimag::Orbits
makeOrbitFor	PartialPsimag/Symmetry/Star.h	/^    size_t makeOrbitFor(size_t posIndex, const SymmetryType& symmetry) {$/;"	f	class:psimag::Star
mapTo1BZ	momentumDomain.h	/^		void mapTo1BZ(VectorType& k) const {$/;"	f	class:rpa::momentumDomain
mat	PartialPsimag/IndexedMatrix.h	/^    const MatrixLikeType&       mat;$/;"	m	class:psimag::IndexedMatrix
mat	PartialPsimag/MatrixSlice.h	/^    MatrixLikeType&       mat;$/;"	m	class:psimag::ColSlice
mat	PartialPsimag/MatrixSlice.h	/^    MatrixLikeType&       mat;$/;"	m	class:psimag::RowSlice
mat	PartialPsimag/RealPart.h	/^    ComplexMatrixLikeType&       mat;$/;"	m	class:psimag::RealPart
mat	PsimagLite/src/JSON/JsonParser/MatrixParser.h	/^    MatrixLikeType& mat;$/;"	m	class:JsonParser::MatrixParser
mat	PsimagLite/src/JSON/Transposer.h	/^    MatrixLikeType mat;$/;"	m	class:psimag::Transposed
mat	PsimagLite/src/JSON/Transposer.h	/^    MatrixLikeType& mat;$/;"	m	class:psimag::Transposer
matMul	utilities.h	/^inline void matMul(ComplexMatrixType& matrix0, ComplexMatrixType& matrix1, ComplexMatrixType& matrix2) {$/;"	f
mat_	PsimagLite/src/ChebyshevSolver.h	/^		MatrixType const& mat_;$/;"	m	class:PsimagLite::ChebyshevSolver
mat_	PsimagLite/src/LanczosSolver.h	/^		MatrixType const& mat_;$/;"	m	class:PsimagLite::LanczosSolver
mat_	PsimagLite/src/LanczosVectors.h	/^		const MatrixType& mat_;$/;"	m	class:PsimagLite::LanczosVectors
matplotlib	Plot_ek_high_sym.dat.py	/^import matplotlib.pyplot as plt$/;"	i
matplotlib	PythonScripts/Bandstructure.py	/^import matplotlib$/;"	i
matplotlib	PythonScripts/Bandstructure.py	/^import matplotlib.gridspec as gridspec$/;"	i
matplotlib	PythonScripts/Bandstructure.py	/^import matplotlib.pyplot as plt$/;"	i
matplotlib	PythonScripts/Calc_lambda.py	/^import matplotlib$/;"	i
matplotlib	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^import matplotlib$/;"	i
matplotlib	PythonScripts/CoupledLadders.py	/^import matplotlib$/;"	i
matplotlib	PythonScripts/Plot_chiRPA_w.py	/^import matplotlib$/;"	i
matplotlib	PythonScripts/Plot_chiRPA_w.py	/^import matplotlib.gridspec as gridspec$/;"	i
matplotlib	PythonScripts/Plot_chiRPA_w.py	/^import matplotlib.pyplot as plt$/;"	i
matplotlib	PythonScripts/Sr2RuO4.py	/^import matplotlib$/;"	i
matplotlib	PythonScripts/plotChiRPAAlongHighSym.py	/^import matplotlib$/;"	i
matrixRank	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t matrixRank(size_t linSize,size_t maxEdof) const$/;"	f	class:PsimagLite::GeometryFactory
matrixRank	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t matrixRank() const$/;"	f	class:PsimagLite::KTwoNiFFour
matrixVectorProduct	PsimagLite/src/ChebyshevSolver.h	/^			void matrixVectorProduct (VectorType &x,const VectorType &y) const$/;"	f	class:PsimagLite::ChebyshevSolver::InternalMatrix
matrixVectorProduct	PsimagLite/src/CrsMatrix.h	/^		void matrixVectorProduct (std::vector<S> &x, std::vector<S> const &y) const$/;"	f	class:PsimagLite::CrsMatrix
matrixVectorProduct	PsimagLite/src/SampleCRSMatrix.h	/^		void matrixVectorProduct(std::vector<T>& x, const std::vector<T>& y) const$/;"	f	class:PsimagLite::SampleCRSMatrix
matrixVectorProduct	PsimagLite/src/SparseRow.h	/^		ValueType matrixVectorProduct(const VectorType& y) const$/;"	f	class:PsimagLite::SparseRow
matx_	PsimagLite/src/ChebyshevSolver.h	/^			const MatrixType& matx_;$/;"	m	class:PsimagLite::ChebyshevSolver::InternalMatrix
max	PartialPsimag/KISS.h	/^    static result_type max() { return 1; }$/;"	f	class:psimag::KISS
maxConnections	PsimagLite/src/Geometry/Geometry.h	/^			size_t maxConnections(size_t termId = 0) const$/;"	f	class:PsimagLite::Geometry
maxConnections	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t maxConnections() const { return maxConnections_; }$/;"	f	class:PsimagLite::GeometryFactory
maxConnections	PsimagLite/src/Geometry/GeometryTerm.h	/^			size_t maxConnections() const$/;"	f	class:PsimagLite::GeometryTerm
maxConnections	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t maxConnections() const$/;"	f	class:PsimagLite::KTwoNiFFour
maxConnections	PsimagLite/src/Geometry/LadderBath.h	/^			size_t maxConnections() const$/;"	f	class:PsimagLite::LadderBath
maxConnections_	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t maxConnections_;$/;"	m	class:PsimagLite::GeometryFactory
maxContainedLatticeCoordinate	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  LatticeCoordinates<2> maxContainedLatticeCoordinate(const CellTranslation<Field,2>& trans) {$/;"	f	namespace:psimag
maxEdof_	PsimagLite/src/Geometry/GeometryTerm.h	/^			size_t maxEdof_;$/;"	m	class:PsimagLite::GeometryTerm
maxIter_	PsimagLite/src/Minimizer.h	/^		size_t maxIter_;$/;"	m	class:PsimagLite::Minimizer
maxKeyWidth	PsimagLite/src/JSON/JSN_Writer.h	/^    int maxKeyWidth( const MapType<std::string, ValType>& map) {$/;"	f	class:dca::JSN
maxKeyWidth	PsimagLite/src/JSON/JSN_Writer.h	/^    int maxKeyWidth() const {$/;"	f	class:dca::JSN
maxSet	PsimagLite/src/Rusage.h	/^		long maxSet() const { return rusage_.ru_maxrss; }$/;"	f	class:PsimagLite::Rusage
max_size	PartialPsimag/Matrix.h	/^    size_type max_size() const { return lDim*nCol; }$/;"	f	class:psimag::Matrix
memory	PsimagLite/src/Rusage.h	/^		long memory()$/;"	f	class:PsimagLite::Rusage
meshDistance	PartialPsimag/Symmetry/fetchMeshWignerSeitz.h	/^  Field meshDistance(std::vector<Field> const &v1,std::vector<Field> const &v2)$/;"	f	namespace:rpa
message_	PsimagLite/src/Profiling.h	/^			std::string message_;$/;"	m	class:PsimagLite::Profiling
messagesReceived	PsimagLite/src/Rusage.h	/^		long messagesReceived() const { return rusage_.ru_msgrcv; }$/;"	f	class:PsimagLite::Rusage
messagesSent	PsimagLite/src/Rusage.h	/^		long messagesSent() const { return rusage_.ru_msgsnd; }$/;"	f	class:PsimagLite::Rusage
metric	PartialPsimag/Symmetry/Lattice.h	/^    MetricType                  metric;         $/;"	m	class:psimag::Lattice
metricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^    const MetricTensor<Field,DIM>& metricTensor;$/;"	m	class:psimag::MetricTensorSortHelper
metricTensor	PartialPsimag/Symmetry/MetricTensor.h	/^  MetricTensor<Field,DIM> metricTensor(Lattice<Field,DIM,Algorithms>& cell) {$/;"	f	namespace:psimag
millerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^  MillerDirection<Field,2> millerDirection(IN_TYPE t0, IN_TYPE t1) {$/;"	f	namespace:psimag
millerDirection	PartialPsimag/Symmetry/MillerDirection.h	/^  MillerDirection<Field,2> millerDirection(IN_TYPE t0, IN_TYPE t1, IN_TYPE t2) {$/;"	f	namespace:psimag
min	PartialPsimag/KISS.h	/^    static result_type min() { return 0; }$/;"	f	class:psimag::KISS
minDistance	PartialPsimag/Symmetry/TestPattern.h	/^    Field minDistance(size_t pos1, $/;"	f	class:psimag::TestPattern
mirrorLineIntercept	PartialPsimag/Symmetry/SymmetryOperation.h	/^  mirrorLineIntercept(const CellPosition<Field,2,Algorithms>&  pt1,$/;"	f	namespace:psimag
mirrorSheet	ferminator.h	/^	void mirrorSheet() {$/;"	f	class:rpa::ferminator
mlab	PythonScripts/MayaVi_Plot_of_FS.py	/^from mayavi import mlab$/;"	i
modeName	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    std::string modeName(ModeType m) {$/;"	f	class:JsonParser::ModesMixin
mode_	PsimagLite/src/ChebyshevSolver.h	/^		size_t mode_;$/;"	m	class:PsimagLite::ChebyshevSolver
mode_	PsimagLite/src/LanczosSolver.h	/^		size_t mode_;$/;"	m	class:PsimagLite::LanczosSolver
model	BSCCObilayer.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	BSCCObilayer.h	/^	class model {$/;"	c	namespace:rpa
model	SrRuO_SO.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	SrRuO_SO.h	/^	class model {$/;"	c	namespace:rpa
model	bandstructure.h	/^		ModelType& model;$/;"	m	class:rpa::bandstructure
model	bilayer.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	bilayer.h	/^	class model {$/;"	c	namespace:rpa
model	bilayerFESC.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	bilayerFESC.h	/^	class model {$/;"	c	namespace:rpa
model	chi0.h	/^		model<FieldType, MatrixTemplate, ConcurrencyType> model;$/;"	m	class:rpa::chi0q
model	coupledLadders.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	coupledLadders.h	/^	class model {$/;"	c	namespace:rpa
model	gaps3D.h	/^        ModelType& model;$/;"	m	class:rpa::gap3D
model	orthoIIBilayer.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	orthoIIBilayer.h	/^	class model {$/;"	c	namespace:rpa
model	pairing.h	/^		rpa::model<Field,MatrixTemplate,ConcurrencyType>& model;$/;"	m	class:rpa::pairing
model	rpa.h	/^			model<FieldType, MatrixTemplate, ConcurrencyType> model;$/;"	m	class:rpa::interaction
model	singleBand.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	singleBand.h	/^	class model {$/;"	c	namespace:rpa
model	susceptibility.h	/^			rpa::model<Field,MatrixTemplate,ConcurrencyType>& model;$/;"	m	class:rpa::susceptibility
model	tbFromFile.h	/^		model(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, ConcurrencyType& concurrency):$/;"	f	class:rpa::model
model	tbFromFile.h	/^	class model {$/;"	c	namespace:rpa
modes	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    typedef enum modes {$/;"	g	class:JsonParser::ModesMixin
modulus	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  static Field modulus(const Field v1, const Field v2) {  $/;"	f	class:psimag::BasicCrystalAlgorithms
momenta	momentumDomain.h	/^		MatrixType momenta;$/;"	m	class:rpa::momentumDomain
moments_	PsimagLite/src/ChebyshevSerializer.h	/^		std::vector<RealType> moments_;$/;"	m	class:PsimagLite::ChebyshevSerializer
momentumDomain	momentumDomain.h	/^		momentumDomain(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, $/;"	f	class:rpa::momentumDomain
momentumDomain	momentumDomain.h	/^		momentumDomain(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::momentumDomain
momentumDomain	momentumDomain.h	/^	class momentumDomain{$/;"	c	namespace:rpa
momentumDomain1	chi0Ofq.h	/^		const momentumDomain<Field,psimag::Matrix>& momentumDomain1;$/;"	m	class:rpa::chi0ofq
momentumDomain1	greensFunction.h	/^		momentumDomain<Field,psimag::Matrix> momentumDomain1;$/;"	m	class:rpa::greensFunction
mpl	Plot_ek_high_sym.dat.py	/^import matplotlib as mpl$/;"	i
mpl	PythonScripts/Bandstructure.py	/^import matplotlib as mpl$/;"	i
mpl	PythonScripts/Plot_chiRPA_w.py	/^import matplotlib as mpl$/;"	i
msg	PsimagLite/src/JSON/OperationClosure.h	/^    std::string msg;$/;"	m	class:psimag::UnaryOperationClosure
msize	1band_wSpin.h	/^		size_t msize;$/;"	m	class:rpa::SingleBand_wSpin
msize	SrRuO_SO.h	/^		size_t msize;$/;"	m	class:rpa::model
msize	chi0.h	/^		size_t msize;$/;"	m	class:rpa::calcChi0Matrix
msize	chi0.h	/^		size_t nOrb, msize;$/;"	m	class:rpa::chi0q
msize	chi0.h	/^		size_t nOrb,msize;$/;"	m	class:rpa::susc
msize	chi0Ofq.h	/^		size_t msize;$/;"	m	class:rpa::chi0ofq
msize	coupledLadders.h	/^		size_t msize;$/;"	m	class:rpa::model
msize	pairing.h	/^		size_t msize;$/;"	m	class:rpa::pairing
msize	rpa.h	/^			size_t nOrb,msize;$/;"	m	class:rpa::interaction
msize	rpa_CuO.h	/^			size_t nOrb,msize;$/;"	m	class:rpa::interactionEmery
msize	singleBand.h	/^		size_t msize;$/;"	m	class:rpa::model
msize	susceptibility.h	/^			size_t msize;$/;"	m	class:rpa::susceptibility
mu	BSCCObilayer.h	/^		Field t,tp,tpp,tperp,mu;$/;"	m	class:rpa::model
mu	parameters.h	/^		Field  mu;$/;"	m	class:rpa::parameters
multiplicationTable	PartialPsimag/Symmetry/Star.h	/^    Matrix<int>              multiplicationTable;$/;"	m	class:psimag::Star
multiplicationTable	PartialPsimag/Symmetry/SymmetryGroup.h	/^    GroupMultiplicationTableType             multiplicationTable;$/;"	m	class:psimag::SymmetryGroup
multiply	PsimagLite/src/CrsMatrix.h	/^	void multiply(CrsMatrix<S> &C,CrsMatrix<S> const &A,CrsMatrix<S2> const &B)$/;"	f	namespace:PsimagLite
multiply	PsimagLite/src/CrsMatrix.h	/^	void multiply(std::vector<S>& v2, const CrsMatrix<S>& m, const std::vector<S>& v1)$/;"	f	namespace:PsimagLite
multiplyScalar	PsimagLite/src/CrsMatrix.h	/^	void multiplyScalar(CrsMatrix<S> &ret,CrsMatrix<S> const &s,T const &v)$/;"	f	namespace:PsimagLite
multiplyTc	PsimagLite/src/CrsMatrix.h	/^	Matrix<T> multiplyTc(const CrsMatrix<T>& a,const CrsMatrix<T>& b)$/;"	f	namespace:PsimagLite
multiplyTransposeConjugate	PsimagLite/src/Matrix.h	/^	Matrix<T> multiplyTransposeConjugate($/;"	f	namespace:PsimagLite
multiprocessing	PythonScripts/test.py	/^import multiprocessing $/;"	i
mutex	PsimagLite/src/Pthreads.h	/^	pthread_mutex_t* mutex;$/;"	m	struct:PthreadFunctionStruct
mutex_	PsimagLite/src/Pthreads.h	/^			pthread_mutex_t mutex_;$/;"	m	class:PsimagLite::Pthreads
myFunction	PsimagLite/src/Minimizer.h	/^	typename FunctionType::FieldType myFunction(const gsl_vector *v, void *params)$/;"	f	namespace:PsimagLite
myIndex	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    int            myIndex;$/;"	m	class:JsonParser::Whatever
myIndices_	PsimagLite/src/Range.h	/^		std::vector<size_t> myIndices_; \/\/ indices assigned to this processor$/;"	m	class:PsimagLite::Range
myKey	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    std::wstring   myKey;$/;"	m	class:JsonParser::Whatever
myhandler	PsimagLite/scripts/colorOutput.pl	/^sub myhandler$/;"	s
mylist	PythonScripts/test.py	/^mylist = [1,2,3,4] $/;"	v
nCol	PartialPsimag/Matrix.h	/^    size_type nRow,nCol,lDim;$/;"	m	class:psimag::Matrix
nCol	PsimagLite/src/Geometry/GeometryDirection.h	/^			size_t nCol() const$/;"	f	class:PsimagLite::GeometryDirection
nLines	bands.h	/^		int nLines;$/;"	m	class:rpa::Bands
nLines	bandstructure.h	/^		int nLines;$/;"	m	class:rpa::bandstructure
nLines	tbFromFile.h	/^		int nLines;$/;"	m	class:rpa::model
nOrb	chi0.h	/^		size_t nOrb, msize;$/;"	m	class:rpa::chi0q
nOrb	chi0.h	/^		size_t nOrb,msize;$/;"	m	class:rpa::susc
nOrb	chi0.h	/^		size_t nOrb;$/;"	m	class:rpa::calcChi0Matrix
nOrb	chi0Ofq.h	/^		size_t nOrb;$/;"	m	class:rpa::chi0ofq
nOrb	greensFunction.h	/^		size_t nOrb;$/;"	m	class:rpa::greensFunction
nOrb	pairing.h	/^		const size_t& nOrb,nk;$/;"	m	class:rpa::pairing
nOrb	parameters.h	/^		size_t nOrb;$/;"	m	class:rpa::parameters
nOrb	rpa.h	/^			size_t nOrb,msize;$/;"	m	class:rpa::interaction
nOrb	rpa_CuO.h	/^			size_t nOrb,msize;$/;"	m	class:rpa::interactionEmery
nOrbAtom	parameters.h	/^		std::vector<int> nOrbAtom;$/;"	m	class:rpa::parameters
nOrbAtomStr	parameters.h	/^		std::string nOrbAtomStr;$/;"	m	class:rpa::parameters
nRow	PartialPsimag/Matrix.h	/^    size_type nRow,nCol,lDim;$/;"	m	class:psimag::Matrix
nRow	PsimagLite/src/Geometry/GeometryDirection.h	/^			size_t nRow() const$/;"	f	class:PsimagLite::GeometryDirection
nSheets	ferminator.h	/^		size_t nkPerSheet,nSheets,nTotal;$/;"	m	class:rpa::ferminator
nSitesPerUnitCell	parameters.h	/^		size_t nSitesPerUnitCell;$/;"	m	class:rpa::parameters
nTotal	ferminator.h	/^		size_t nkPerSheet,nSheets,nTotal;$/;"	m	class:rpa::ferminator
nTotal	pairing.h	/^		size_t nTotal;$/;"	m	class:rpa::pairing
n_	PsimagLite/src/Geometry/GeometryFactory.h	/^		size_t n_;$/;"	m	class:PsimagLite::GeometryFactory
n_	PsimagLite/src/PackIndices.h	/^		size_t n_;$/;"	m	class:PsimagLite::PackIndices
n_col	PartialPsimag/IndexedMatrix.h	/^    inline size_t n_col() const { return colIndices.size(); }$/;"	f	class:psimag::IndexedMatrix
n_col	PartialPsimag/Matrix.h	/^    size_type n_col() const { return nCol; }$/;"	f	class:psimag::Matrix
n_col	PartialPsimag/MatrixLike.h	/^      size_t n_col() const { return doubleVector[0].size(); }$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
n_col	PartialPsimag/MatrixSlice.h	/^    inline size_t n_col() const { return 1; }$/;"	f	class:psimag::TransposedRowSlice
n_col	PartialPsimag/MatrixSlice.h	/^    inline size_t n_col() const { return mat.n_col(); }$/;"	f	class:psimag::RowSlice
n_col	PartialPsimag/MatrixSlice.h	/^    size_t n_col() const { return 1;           }$/;"	f	class:psimag::ColSlice
n_col	PartialPsimag/MatrixSlice.h	/^    size_t n_col() const { return this-> mat.n_row();  }$/;"	f	class:psimag::TransposedColSlice
n_col	PartialPsimag/RealPart.h	/^    inline size_t n_col() const { return mat.n_col(); }$/;"	f	class:psimag::RealPart
n_col	PsimagLite/src/JSON/MatrixLike.h	/^      size_t n_col() const { return doubleVector[0].size(); }$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
n_col	PsimagLite/src/JSON/Transposer.h	/^    size_t n_col() const { return mat.n_row(); }$/;"	f	class:psimag::Transposed
n_col	PsimagLite/src/JSON/Transposer.h	/^    size_t n_col() const { return mat.n_row(); }$/;"	f	class:psimag::Transposer
n_col	PsimagLite/src/LanczosVectors.h	/^		size_t n_col() const { return data_->n_col(); }$/;"	f	class:PsimagLite::LanczosVectors
n_col	PsimagLite/src/Matrix.h	/^		size_t n_col() const { return ncol_; } \/\/ legacy name$/;"	f	class:PsimagLite::Matrix
n_roots	PartialPsimag/Symmetry/AbstractRat.h	/^    static const size_t n_roots;  \/\/= 8$/;"	m	class:psimag::AbstractRat
n_roots	PartialPsimag/Symmetry/AbstractRat.h	/^  const size_t AbstractRat<IntType>::n_roots=8;$/;"	m	class:psimag::AbstractRat
n_row	PartialPsimag/IndexedMatrix.h	/^    inline size_t n_row() const { return rowIndices.size(); }$/;"	f	class:psimag::IndexedMatrix
n_row	PartialPsimag/Matrix.h	/^    size_type n_row() const { return nRow; }$/;"	f	class:psimag::Matrix
n_row	PartialPsimag/MatrixLike.h	/^      size_t n_row() const { return doubleVector.size(); }$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
n_row	PartialPsimag/MatrixSlice.h	/^    inline size_t n_row() const { return 1;           }$/;"	f	class:psimag::RowSlice
n_row	PartialPsimag/MatrixSlice.h	/^    inline size_t n_row() const { return this->mat.n_col();           }$/;"	f	class:psimag::TransposedRowSlice
n_row	PartialPsimag/MatrixSlice.h	/^    size_t n_row() const { return 1;                   }$/;"	f	class:psimag::TransposedColSlice
n_row	PartialPsimag/MatrixSlice.h	/^    size_t n_row() const { return mat.n_row(); }$/;"	f	class:psimag::ColSlice
n_row	PartialPsimag/RealPart.h	/^    inline size_t n_row() const { return mat.n_row(); }$/;"	f	class:psimag::RealPart
n_row	PsimagLite/src/JSON/MatrixLike.h	/^      size_t n_row() const { return doubleVector.size(); }$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
n_row	PsimagLite/src/JSON/Transposer.h	/^    size_t n_row() const { return mat.n_col(); }$/;"	f	class:psimag::Transposed
n_row	PsimagLite/src/JSON/Transposer.h	/^    size_t n_row() const { return mat.n_col(); }$/;"	f	class:psimag::Transposer
n_row	PsimagLite/src/LanczosVectors.h	/^		size_t n_row() const { return data_->n_row(); }$/;"	f	class:PsimagLite::LanczosVectors
n_row	PsimagLite/src/Matrix.h	/^		size_t n_row() const { return nrow_; } \/\/ legacy name$/;"	f	class:PsimagLite::Matrix
name	PartialPsimag/Symmetry/BravaisType.h	/^    std::string name;$/;"	m	class:psimag::BravaisType
name	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static char* name() {return "ConstantTraits";}\\$/;"	f	class:psimag::ConstantTraits
name	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static char* name() {return "DoubleIndex";}$/;"	f	class:psimag::DoubleIndexTraits
name	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static char* name() {return "DoubleIndex";}\\$/;"	f	class:psimag::ReverseDoubleIndexTraits
name	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static char* name() {return "RowMajor";}$/;"	f	class:psimag::RowMajorTraits
name	PartialPsimag/Symmetry/Mat/MatTraits.h	/^    static const char* name() {return "ColMajor";}\\$/;"	f	class:psimag::ColMajorTraits
name	PartialPsimag/Symmetry/Occupant.h	/^    std::string name;$/;"	m	class:psimag::Occupant
name	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^    static const char* name() {return "SeitzMatrix";}$/;"	f	class:psimag::SeitzMatrixTraits
name	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    std::string                             name;$/;"	m	class:psimag::SpaceGroup
name	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    static const std::string name() {$/;"	f	class:psimag::SpaceGroupData
name	PartialPsimag/Symmetry/SymmetryElement.h	/^    std::string             name;$/;"	m	class:psimag::SymmetryElement
name	PartialPsimag/Symmetry/SymmetryOperation.h	/^    std::string             name;$/;"	m	class:psimag::SymmetryOperation
name	PartialPsimag/Tag.h	/^    std::string         name;$/;"	m	class:psimag::Tag
name	PsimagLite/src/ConcurrencyMpi.h	/^		std::string name() const { return "mpi"; }$/;"	f	class:PsimagLite::ConcurrencyMpi
name	PsimagLite/src/ConcurrencySerial.h	/^		std::string name() const { return "serial"; }$/;"	f	class:PsimagLite::ConcurrencySerial
name	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^    static std::string  name(StatesAndActionsType stateOrAction) {$/;"	f	class:JsonParser::StatesAndActionsMixin
name	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^    static std::string  name(StateType state) {$/;"	f	class:JsonParser::StatesMixin
name	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    std::wstring name() const {$/;"	f	class:JsonParser::Whatever
name_	PsimagLite/src/LineMarker.h	/^		std::string name_;$/;"	m	class:PsimagLite::LineMarker
nbands	1band_wSpin.h	/^		FieldType nbands;$/;"	m	class:rpa::SingleBand_wSpin
nbands	4Orbital.h	/^		FieldType nbands;$/;"	m	class:rpa::FourOrbital
nbands	BSCCObilayer.h	/^		FieldType nbands;$/;"	m	class:rpa::model
nbands	BaFeAs_5orb.h	/^		FieldType nbands;$/;"	m	class:rpa::BaFeAs
nbands	FourOrbital.h	/^		FieldType nbands;$/;"	m	class:rpa::FourOrbital
nbands	KFe2Se2.h	/^		FieldType nbands;$/;"	m	class:rpa::KFe2Se2
nbands	PythonScripts/MayaVi_Plot_of_FS.py	/^nbands = bands.shape[1]-3$/;"	v
nbands	SrRuO.h	/^		FieldType nbands;$/;"	m	class:rpa::SrRuO
nbands	SrRuO_SO.h	/^		FieldType nbands;$/;"	m	class:rpa::model
nbands	bands.h	/^		FieldType nbands;$/;"	m	class:rpa::Bands
nbands	bandstructure.h	/^		size_t nbands;$/;"	m	class:rpa::bandstructure
nbands	bilayer.h	/^		FieldType nbands;$/;"	m	class:rpa::model
nbands	bilayerFESC.h	/^		FieldType nbands;$/;"	m	class:rpa::model
nbands	coupledLadders.h	/^		FieldType nbands;$/;"	m	class:rpa::model
nbands	gap.h	/^		size_t nbands;$/;"	m	class:rpa::gap
nbands	gaps2D.h	/^		size_t nbands;$/;"	m	class:rpa::gap2D
nbands	gaps3D.h	/^        size_t nbands;$/;"	m	class:rpa::gap3D
nbands	orthoIIBilayer.h	/^		FieldType nbands;$/;"	m	class:rpa::model
nbands	singleBand.h	/^		FieldType nbands;$/;"	m	class:rpa::model
nbands	tbFromFile.h	/^		FieldType nbands;$/;"	m	class:rpa::model
ncol_	PsimagLite/src/Matrix.h	/^		size_t nrow_,ncol_;$/;"	m	class:PsimagLite::Matrix
needsDelete_	PsimagLite/src/LanczosVectors.h	/^		bool needsDelete_;$/;"	m	class:PsimagLite::LanczosVectors
negate	PartialPsimag/Symmetry/ReducedLattice.h	/^    void negate(size_t r) {$/;"	f	class:psimag::ReducedLattice
negateCol	PartialPsimag/Symmetry/Mat/Mat.h	/^    void negateCol(size_t c) {$/;"	f	class:psimag::Mat
negateCol	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void negateCol(size_t i) { rotation.negateCol(i);}$/;"	f	class:psimag::SeitzMatrix
negateRow	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void negateRow(size_t row) {$/;"	f	class:psimag::HermiteNormalForm
negateRow	PartialPsimag/Symmetry/Mat/Mat.h	/^    void negateRow(size_t r) {$/;"	f	class:psimag::Mat
negateRow	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void negateRow(size_t i) { rotation.negateRow(i);}$/;"	f	class:psimag::SeitzMatrix
neighbors	PsimagLite/src/Geometry/GeometryUtils.h	/^		bool neighbors(size_t i1,size_t i2)$/;"	f	namespace:PsimagLite::GeometryUtils
netDirection	PartialPsimag/Symmetry/SymmetryElement.h	/^    LatticeCoordinatesType  netDirection;$/;"	m	class:psimag::SymmetryElement
netReduce	PartialPsimag/Symmetry/CellTranslation.h	/^  void netReduce(CellTranslation<Field,DIM>& trans) {$/;"	f	namespace:psimag
newCommFromSegments	PsimagLite/src/ConcurrencyMpi.h	/^		CommPairType newCommFromSegments(size_t numberOfSegments,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
newCommFromSegments	PsimagLite/src/ConcurrencySerial.h	/^		CommPairType newCommFromSegments(size_t x,CommType mpiComm=0)$/;"	f	class:PsimagLite::ConcurrencySerial
newState	PsimagLite/src/JSON/JsonParser/AugmentedStateTransitionTable.h	/^      StateType               newState;$/;"	m	class:JsonParser::AugmentedStateTranslationTable::Pair
next	PsimagLite/src/Range.h	/^		void next()$/;"	f	class:PsimagLite::Range
next_	PsimagLite/src/RandomForTests.h	/^		int next_;$/;"	m	class:PsimagLite::RandomForTests
nk	Plot_ek_high_sym.dat.py	/^nk = data.shape[0]$/;"	v
nk	bands.h	/^		size_t nk;$/;"	m	class:rpa::Bands
nk	momentumDomain.h	/^		size_t nk;$/;"	m	class:rpa::momentumDomain
nk	pairing.h	/^		const size_t& nOrb,nk;$/;"	m	class:rpa::pairing
nkBands	parameters.h	/^		size_t nkBands;$/;"	m	class:rpa::parameters
nkF	pairing.h	/^		size_t nkF;$/;"	m	class:rpa::pairing
nkFI	pairing.h	/^		int nkFI;$/;"	m	class:rpa::pairing
nkInt	parameters.h	/^		size_t nkInt; $/;"	m	class:rpa::parameters
nkIntz	parameters.h	/^		size_t nkIntz; $/;"	m	class:rpa::parameters
nkPerSheet	ferminator.h	/^		size_t nkPerSheet,nSheets,nTotal;$/;"	m	class:rpa::ferminator
nkPerSheet	parameters.h	/^		size_t nkPerSheet;$/;"	m	class:rpa::parameters
nktot	chi0.h	/^		size_t nktot;$/;"	m	class:rpa::calcChi0Matrix
nktot	chi0Ofq.h	/^		size_t nktot;$/;"	m	class:rpa::chi0ofq
nktot	greensFunction.h	/^		size_t nktot;$/;"	m	class:rpa::greensFunction
nktot	momentumDomain.h	/^		size_t nktot;$/;"	m	class:rpa::momentumDomain
nkx	PythonScripts/MayaVi_Plot_of_FS.py	/^nkx = int(sqrt(bands.shape[0]\/nkz))$/;"	v
nky	PythonScripts/MayaVi_Plot_of_FS.py	/^nky=nkx$/;"	v
nkz	PythonScripts/MayaVi_Plot_of_FS.py	/^nkz = unique(bands[:,2]).shape[0]$/;"	v
nkz	momentumDomain.h	/^		size_t nkz;$/;"	m	class:rpa::momentumDomain
nonZero	PsimagLite/src/CrsMatrix.h	/^		int nonZero() const { return colind_.size(); }		$/;"	f	class:PsimagLite::CrsMatrix
norm	PsimagLite/src/Complex.h	/^	double norm(double t)$/;"	f	namespace:std
norm	PsimagLite/src/Vector.h	/^	X norm(std::vector<X> const &v)$/;"	f	namespace:PsimagLite
norm	PsimagLite/src/Vector.h	/^	X norm(std::vector<std::complex<X> > const &v)$/;"	f	namespace:PsimagLite
normalization	pairing.h	/^		VectorType normalization;$/;"	m	class:rpa::pairing
normalize	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  static Field normalize(const Field v1) { $/;"	f	class:psimag::BasicCrystalAlgorithms
normalize	PartialPsimag/Symmetry/CellPosition.h	/^    ThisType& normalize()  {       \/\/ &*&*&*&* this is used a lot probably should do a foreach2 here$/;"	f	class:psimag::CellPosition
normalize	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    LatticeCoordinates<DIM> normalize() const {$/;"	f	class:psimag::LatticeCoordinates
normalize	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void normalize() {$/;"	f	class:psimag::HermiteNormalForm
normalize	PartialPsimag/Symmetry/SymmetryElement.h	/^  void normalize(SymmetryElement<Field,2,Algorithms>& element) {   $/;"	f	namespace:psimag
normalize	PartialPsimag/Symmetry/SymmetryOperation.h	/^    void normalize()  {$/;"	f	class:psimag::SymmetryOperation
normalize	tbFromFile.h	/^		void normalize(ComplexMatrixType& matrix, size_t colIndex) {$/;"	f	class:rpa::model
normalizeCellPositions	PartialPsimag/Symmetry/Pattern.h	/^    void normalizeCellPositions() {$/;"	f	class:psimag::Pattern
normalizeGlide	PartialPsimag/Symmetry/CellTranslation.h	/^  void normalizeGlide(CellTranslation<Field,DIM>& trans) {$/;"	f	namespace:psimag
normalizeTranslation	PartialPsimag/Symmetry/CellTranslation.h	/^  CellTranslation<Field,DIM> normalizeTranslation(CellTranslation<Field,DIM>& trans) {$/;"	f	namespace:psimag
normalizeVector	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  static void normalizeVector(VectorType& v) { $/;"	f	class:psimag::BasicCrystalAlgorithms
nprocs	PsimagLite/src/Concurrency.h	/^		int nprocs(int dummy= -1) { return 1; }$/;"	f	class:PsimagLite::Concurrency
nprocs	PsimagLite/src/ConcurrencyMpi.h	/^		int nprocs(CommType mpiComm=COMM_WORLD) $/;"	f	class:PsimagLite::ConcurrencyMpi
nprocs	PsimagLite/src/ConcurrencySerial.h	/^		int nprocs(CommType comm1=COMM_WORLD) { return 1;}$/;"	f	class:PsimagLite::ConcurrencySerial
nprocs_	PsimagLite/src/Range.h	/^		size_t nprocs_;$/;"	m	class:PsimagLite::Range
nq1	susceptibility.h	/^			size_t nq1;$/;"	m	class:rpa::susceptibility
nq2	susceptibility.h	/^			size_t nq2;$/;"	m	class:rpa::susceptibility
nq3	susceptibility.h	/^			size_t nq3;$/;"	m	class:rpa::susceptibility
nqx	parameters.h	/^		size_t nqx,nqy,nqz;$/;"	m	class:rpa::parameters
nqy	parameters.h	/^		size_t nqx,nqy,nqz;$/;"	m	class:rpa::parameters
nqz	parameters.h	/^		size_t nqx,nqy,nqz;$/;"	m	class:rpa::parameters
nrow_	PsimagLite/src/Matrix.h	/^		size_t nrow_,ncol_;$/;"	m	class:PsimagLite::Matrix
nthreads_	PsimagLite/src/Pthreads.h	/^			static size_t nthreads_;$/;"	m	class:PsimagLite::Pthreads
nthreads_	PsimagLite/src/Pthreads.h	/^	size_t Pthreads<PthreadFunctionHolderType>::nthreads_=1;$/;"	m	class:PsimagLite::Pthreads
ntypeName	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    static std::string ntypeName(WhateverType t) {$/;"	f	class:JsonParser::Whatever
null	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    const Whatever& null() {$/;"	f	class:JsonParser::Whatever
nullSize	PsimagLite/src/LanczosVectors.h	/^		size_t nullSize() const$/;"	f	class:PsimagLite::LanczosVectors
num	PartialPsimag/Symmetry/rational.h	/^  Int num, den; \/\/ numerator, denominator$/;"	m	class:rational
numChar	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    size_t               numChar;$/;"	m	class:JsonParser::JsonParser
numElements	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    size_t                             numElements;$/;"	m	class:psimag::AppliedSymmetryElementIterator
numLines	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    size_t               numLines;$/;"	m	class:JsonParser::JsonParser
numOperations	PartialPsimag/Symmetry/GroupAction.h	/^    size_t numOperations;$/;"	m	class:psimag::GroupAction
numOperations	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    size_t numOperations() const {$/;"	f	class:psimag::SpaceGroup
numPatternPos	PartialPsimag/Symmetry/GroupAction.h	/^    size_t numPatternPos;$/;"	m	class:psimag::GroupAction
numPatternPos	PartialPsimag/Symmetry/Orbits.h	/^        size_t                                   numPatternPos;$/;"	m	class:psimag::Orbits
numPatternPos	PartialPsimag/Symmetry/Star.h	/^    size_t                   numPatternPos;$/;"	m	class:psimag::Star
numPatternPos	PartialPsimag/Symmetry/SymmetryGroup.h	/^    size_t                                   numPatternPos;$/;"	m	class:psimag::SymmetryGroup
numStringToFraction	PartialPsimag/Symmetry/FieldParser.h	/^std::pair<IntType, IntType> numStringToFraction(std::string decimalString) {$/;"	f	namespace:psimag
number	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    size_t                                  number;$/;"	m	class:psimag::SpaceGroup
numberOfOperations	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^    size_t                             numberOfOperations;$/;"	m	class:psimag::GroupMultiplicationTable
numberOfOperations	PartialPsimag/Symmetry/SymmetryGroup.h	/^    size_t                                   numberOfOperations;$/;"	m	class:psimag::SymmetryGroup
numberOfQ	susceptibility.h	/^			size_t numberOfQ;$/;"	m	class:rpa::susceptibility
numberOfSites	PsimagLite/src/Geometry/Geometry.h	/^			size_t numberOfSites() const { return linSize_; }$/;"	f	class:PsimagLite::Geometry
numbers	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, double>                        numbers;$/;"	m	class:dca::JSN
numerator	PartialPsimag/Symmetry/rational.h	/^  Int numerator(){return num;}$/;"	f	class:rational
nw	parameters.h	/^		size_t nw;$/;"	m	class:rpa::parameters
nw	susceptibility.h	/^			size_t nw;$/;"	m	class:rpa::susceptibility
nwn	chi0Ofq.h	/^		size_t nwn;$/;"	m	class:rpa::chi0ofq
nwn	greensFunction.h	/^		size_t nwn;$/;"	m	class:rpa::greensFunction
nwn	parameters.h	/^		size_t nwn;$/;"	m	class:rpa::parameters
occupant	PartialPsimag/Symmetry/OccupantClosure.h	/^    const Occupant&   occupant;$/;"	m	class:psimag::OccupantClosure
occupant	PartialPsimag/Symmetry/Pattern.h	/^    std::vector<int>        occupant; $/;"	m	class:psimag::Pattern
occupant	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    Occupant                occupant;$/;"	m	class:psimag::SuperCrystalBuilder
occupantDistanceTo	PartialPsimag/Symmetry/TestPattern.h	/^    Field occupantDistanceTo(size_t occIndx, const PatternType& otherPattern) const {$/;"	f	class:psimag::TestPattern
occupantNumPositions	PartialPsimag/Symmetry/Pattern.h	/^    std::vector<int>        occupantNumPositions;$/;"	m	class:psimag::Pattern
occupantPositions	PartialPsimag/Symmetry/PatternData.h	/^    OccupantMap      occupantPositions;$/;"	m	class:psimag::PatternData
occupantStart	PartialPsimag/Symmetry/Pattern.h	/^    std::vector<int>        occupantStart;   $/;"	m	class:psimag::Pattern
occupants	PartialPsimag/Symmetry/Pattern.h	/^    std::vector<Occupant>   occupants; $/;"	m	class:psimag::Pattern
occupants	PartialPsimag/Symmetry/PatternData.h	/^    Occupants        occupants;$/;"	m	class:psimag::PatternData
of	PartialPsimag/Symmetry/Mat/MatDet.h	/^    static T of(const MatType& m) {$/;"	f	class:psimag::DET
offset	PsimagLite/src/JSON/JSN_Writer.h	/^    mutable int  offset;$/;"	m	class:dca::JSN
omega	susceptibility.h	/^			VectorType omega;$/;"	m	class:rpa::susceptibility
omega1	PsimagLite/src/PlotParams.h	/^	RealType omega1;$/;"	m	struct:PsimagLite::PlotParams
omega2	PsimagLite/src/PlotParams.h	/^	RealType omega2;$/;"	m	struct:PsimagLite::PlotParams
oneOverA	PsimagLite/src/ParametersForSolver.h	/^		RealType oneOverA,b;$/;"	m	struct:PsimagLite::ParametersForSolver
oneStepDecomposition	PsimagLite/src/ChebyshevSolver.h	/^		void oneStepDecomposition(VectorType& x,$/;"	f	class:PsimagLite::ChebyshevSolver
oneStepDecomposition	PsimagLite/src/LanczosSolver.h	/^		void oneStepDecomposition($/;"	f	class:PsimagLite::LanczosSolver
open	PsimagLite/src/IoSimple.h	/^				void open(std::string const &fn)$/;"	f	class:PsimagLite::IoSimple::In
open	PsimagLite/src/IoSimple.h	/^			void open($/;"	f	class:PsimagLite::IoSimple::Out
operand	PartialPsimag/OperationClosure.h	/^    const OperandType& operand;$/;"	m	class:psimag::UnaryOperationClosure
operand	PsimagLite/src/JSON/OperationClosure.h	/^    const OperandType& operand;$/;"	m	class:psimag::UnaryOperationClosure
operation	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    SymmetryOperationType                     operation;$/;"	m	class:psimag::AppliedSymmetryElement
operation	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    SymmetryOperationType    operation;$/;"	m	class:psimag::AppliedSymmetryElement
operation	PartialPsimag/Symmetry/Mirror2D.h	/^    static SymmetryOperationType operation(const CartesianTranslationType& mirrorLine) {$/;"	f	class:psimag::Mirror
operation	PartialPsimag/Symmetry/Mirror2D.h	/^    static SymmetryOperationType operation(const CartesianTranslationType& mirrorLine, $/;"	f	class:psimag::Mirror
operationFor	PartialPsimag/Symmetry/FourFold2D.h	/^    static SymmetryOperationType operationFor (const SymmetryElementType&           element,$/;"	f	class:psimag::FourFold
operationFor	PartialPsimag/Symmetry/FourFoldN2D.h	/^    static SymmetryOperationType operationFor (const SymmetryElementType&           element,$/;"	f	class:psimag::FourFoldN
operationFor	PartialPsimag/Symmetry/Glide2D.h	/^    static SymmetryOperationType operationFor(const SymmetryElementType&         element, $/;"	f	class:psimag::Glide
operationFor	PartialPsimag/Symmetry/IdentityElement2D.h	/^    static SymmetryOperationType operationFor(const SymmetryElementType&           element,$/;"	f	class:psimag::IdentityElement
operationFor	PartialPsimag/Symmetry/Mirror2D.h	/^    static SymmetryOperationType operationFor(const SymmetryElementType&         element, $/;"	f	class:psimag::Mirror
operationFor	PartialPsimag/Symmetry/SixFold2D.h	/^    static SymmetryOperationType operationFor(const SymmetryElementType&         element, $/;"	f	class:psimag::SixFold
operationFor	PartialPsimag/Symmetry/SixFoldN2D.h	/^    static SymmetryOperationType operationFor(const SymmetryElementType&         element, $/;"	f	class:psimag::SixFoldN
operationFor	PartialPsimag/Symmetry/SymmetryElement.h	/^    static SymmetryOperationType operationFor (const SymmetryElementType& element,$/;"	f	class:psimag::SymmetryElement
operationFor	PartialPsimag/Symmetry/ThreeFold2D.h	/^    static SymmetryOperationType operationFor (const SymmetryElementType&           element,$/;"	f	class:psimag::ThreeFold
operationFor	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    static SymmetryOperationType operationFor (const SymmetryElementType&           element,$/;"	f	class:psimag::ThreeFoldN
operationFor	PartialPsimag/Symmetry/TwoFold2D.h	/^    static SymmetryOperationType operationFor (const SymmetryElementType&           element,$/;"	f	class:psimag::TwoFold
operationIds	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    std::vector<int>                        operationIds;$/;"	m	class:psimag::SpaceGroup
operations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^     static void operations(std::vector<int>& ids) $/;"	f	class:psimag::SpaceGroupData
operations	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    static void operations(std::vector<int>& ids) $/;"	f	class:psimag::SpaceGroupData
operator !=	PartialPsimag/Matrix.h	/^  bool Matrix<T>::operator != (const Matrix<T>& m)$/;"	f	class:psimag::Matrix
operator !=	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    bool operator!= (const AppliedSymmetryElementIteratorType& other) { return (position != other.position); }$/;"	f	class:psimag::AppliedSymmetryElementIterator
operator !=	PartialPsimag/Symmetry/rational.h	/^  bool operator!=(rational<Int> v) { return (num!=v.num) || (den!=v.den); }$/;"	f	class:rational
operator !=	PartialPsimag/Vec.h	/^  bool operator != (const Vec<T,DIM>& a, const Vec<T,DIM>& b)$/;"	f	namespace:psimag
operator %	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,3,IND> operator % (const SeitzVector<Field,2,IND>& a, const SeitzVector<Field,2,IND>& b) $/;"	f	namespace:psimag
operator %	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,3,IND> operator % (const SeitzVector<Field,3,IND>& a, const SeitzVector<Field,3,IND>& b) $/;"	f	namespace:psimag
operator %	PartialPsimag/Vec.h	/^  T operator % (const Vec<T,2>& a, const Vec<T,2>& b)$/;"	f	namespace:psimag
operator %	PartialPsimag/Vec.h	/^  Vec<T,3> operator % (const Vec<T,3>& a, const Vec<T,3>& b)$/;"	f	namespace:psimag
operator ()	CrystalHarmonics.h	/^		FieldType operator()(const std::vector<FieldType>& kvector, $/;"	f	class:rpa::functorDwave
operator ()	CrystalHarmonics.h	/^		FieldType operator()(const std::vector<FieldType>& kvector, $/;"	f	class:rpa::functorDwaveRot
operator ()	CrystalHarmonics.h	/^		FieldType operator()(const std::vector<FieldType>& kvector, $/;"	f	class:rpa::functorSwave
operator ()	CrystalHarmonics.h	/^		FieldType operator()(const std::vector<FieldType>& kvector, $/;"	f	class:rpa::functorSwaveRot
operator ()	PartialPsimag/IndexedMatrix.h	/^    const value_type& operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::IndexedMatrix
operator ()	PartialPsimag/IndexedMatrix.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::IndexedMatrix
operator ()	PartialPsimag/KISS.h	/^    T operator () (T n)$/;"	f	class:psimag::KISS
operator ()	PartialPsimag/KISS.h	/^    result_type operator ()()$/;"	f	class:psimag::KISS
operator ()	PartialPsimag/Matrix.h	/^    T& operator() (size_type i, size_type j) {$/;"	f	class:psimag::Matrix
operator ()	PartialPsimag/Matrix.h	/^    const T& operator() (size_type i, size_type j) const {$/;"	f	class:psimag::Matrix
operator ()	PartialPsimag/Matrix.h	/^    int operator () (Matrix<T>& A, Matrix<T>& B) {$/;"	f	class:psimag::GESV
operator ()	PartialPsimag/Matrix.h	/^    int operator () (const Matrix<T>& A, Matrix<T>& INV) {$/;"	f	class:psimag::INVERT
operator ()	PartialPsimag/Matrix.h	/^    operator () (const std::vector<size_t> rowIndexes,$/;"	f	class:psimag::Matrix
operator ()	PartialPsimag/MatrixLike.h	/^      const value_type operator() (size_t i, size_t j) const {$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
operator ()	PartialPsimag/MatrixLike.h	/^      int operator () (const MatrixLikeType& A, Matrix<T>& INV) {$/;"	f	class:psimag::MatrixLike::INVERT
operator ()	PartialPsimag/MatrixLike.h	/^      value_type operator() (size_t i, size_t j) {$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
operator ()	PartialPsimag/MatrixSlice.h	/^    const value_type& operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::ColSlice
operator ()	PartialPsimag/MatrixSlice.h	/^    const value_type& operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::RowSlice
operator ()	PartialPsimag/MatrixSlice.h	/^    const value_type& operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::TransposedColSlice
operator ()	PartialPsimag/MatrixSlice.h	/^    const value_type& operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::TransposedRowSlice
operator ()	PartialPsimag/MatrixSlice.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::ColSlice
operator ()	PartialPsimag/MatrixSlice.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::RowSlice
operator ()	PartialPsimag/MatrixSlice.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::TransposedColSlice
operator ()	PartialPsimag/MatrixSlice.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::TransposedRowSlice
operator ()	PartialPsimag/RealPart.h	/^    const value_type& operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::RealPart
operator ()	PartialPsimag/RealPart.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::RealPart
operator ()	PartialPsimag/Symmetry/FourFold2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::FourFold
operator ()	PartialPsimag/Symmetry/FourFoldN2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::FourFoldN
operator ()	PartialPsimag/Symmetry/Glide2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::Glide
operator ()	PartialPsimag/Symmetry/IdentityElement2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::IdentityElement
operator ()	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    CellPosition<Field,DIM,Algorithms> operator()(const CellPosition<Field,DIM,Algorithms>& cellPosition) const $/;"	f	class:psimag::InverseLatticeTransformation
operator ()	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    CellTranslationType operator()(const CellTranslationType& cellTranslation) const $/;"	f	class:psimag::InverseLatticeTransformation
operator ()	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    LatticeCoordinatesType operator()(const LatticeCoordinatesType& latticeCoordinates) const $/;"	f	class:psimag::InverseLatticeTransformation
operator ()	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    void operator() (const InLatticeTemplate<Field,DIM,Algorithms>& srcLattice, $/;"	f	class:psimag::InverseLatticeTransformation
operator ()	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    void operator()(const SymmetryOperation<Field,DIM,Algorithms>& symop,  $/;"	f	class:psimag::InverseLatticeTransformation
operator ()	PartialPsimag/Symmetry/LatticeTransformation.h	/^    CellPosition<Field,DIM,Algorithms> operator()(const CellPosition<Field,DIM,Algorithms>& cellPosition) const $/;"	f	class:psimag::LatticeTransformation
operator ()	PartialPsimag/Symmetry/LatticeTransformation.h	/^    CellTranslationType operator()(const CellTranslationType& cellTranslation) const $/;"	f	class:psimag::LatticeTransformation
operator ()	PartialPsimag/Symmetry/LatticeTransformation.h	/^    Field& operator () (const size_t& row, const size_t& col) { $/;"	f	class:psimag::LatticeTransformation
operator ()	PartialPsimag/Symmetry/LatticeTransformation.h	/^    LatticeCoordinatesType operator()(const LatticeCoordinatesType& latticeCoordinates) const$/;"	f	class:psimag::LatticeTransformation
operator ()	PartialPsimag/Symmetry/LatticeTransformation.h	/^    void operator() (const InLatticeTemplate<Field,DIM,Algorithms>& srcLattice,$/;"	f	class:psimag::LatticeTransformation
operator ()	PartialPsimag/Symmetry/LatticeTransformation.h	/^    void operator()(const SymmetryOperation<Field,DIM,Algorithms>& symop,  $/;"	f	class:psimag::LatticeTransformation
operator ()	PartialPsimag/Symmetry/LatticeTransformationBase.h	/^    operator() (const InLatticeTemplate<Field,DIM,Algorithms>& srcLattice) const $/;"	f
operator ()	PartialPsimag/Symmetry/LatticeTransformationBase.h	/^    operator()( const SymmetryOperation<Field,DIM,Algorithms>& symop) const {   $/;"	f
operator ()	PartialPsimag/Symmetry/LatticeTransformationBase.h	/^    void operator()$/;"	f
operator ()	PartialPsimag/Symmetry/LatticeTransformationBase.h	/^    void operator()(const SymmetryElement<Field,DIM,Algorithms>& el,  $/;"	f
operator ()	PartialPsimag/Symmetry/Mat/Mat.h	/^    Field& operator () (size_t i,size_t j) $/;"	f	class:psimag::Mat
operator ()	PartialPsimag/Symmetry/Mat/Mat.h	/^    const Field& operator () (size_t i,size_t j) const$/;"	f	class:psimag::Mat
operator ()	PartialPsimag/Symmetry/MetricTensor.h	/^    bool operator() ( const size_t& i, const size_t& j) {$/;"	f	class:psimag::MetricTensorSortHelper
operator ()	PartialPsimag/Symmetry/Mirror2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::Mirror
operator ()	PartialPsimag/Symmetry/Orbits.h	/^    int operator () (size_t i,size_t j) const {$/;"	f	class:psimag::Orbits
operator ()	PartialPsimag/Symmetry/SeitzMatrix.h	/^    Field& operator () (const size_t& row, const size_t& col) {$/;"	f	class:psimag::SeitzMatrix
operator ()	PartialPsimag/Symmetry/SeitzMatrix.h	/^    const Field& operator () (const size_t& row, const size_t& col) const {$/;"	f	class:psimag::SeitzMatrix
operator ()	PartialPsimag/Symmetry/SixFold2D.h	/^    SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::SixFold
operator ()	PartialPsimag/Symmetry/SixFoldN2D.h	/^    SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::SixFoldN
operator ()	PartialPsimag/Symmetry/SymmetryElement.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const$/;"	f	class:psimag::SymmetryElement
operator ()	PartialPsimag/Symmetry/ThreeFold2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::ThreeFold
operator ()	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::ThreeFoldN
operator ()	PartialPsimag/Symmetry/TwoFold2D.h	/^    virtual SymmetryOperationType operator () (const Lattice<Field,DIM,Algorithms>& lattice) const {$/;"	f	class:psimag::TwoFold
operator ()	PsimagLite/drivers/minimizer.cpp	/^	FieldType operator()(const SomeVectorType &v) const$/;"	f	class:MyFunctionTest
operator ()	PsimagLite/src/AkimaSpline.h	/^		RealType operator()(const RealType& x) const$/;"	f	class:AkimaSpline
operator ()	PsimagLite/src/AlmostEqual.h	/^		bool operator()($/;"	f	class:PsimagLite::AlmostEqual
operator ()	PsimagLite/src/ChebyshevFunction.h	/^		RealType operator()(int m,const RealType& x) const$/;"	f	class:PsimagLite::ChebyshevFunction
operator ()	PsimagLite/src/ChebyshevSolver.h	/^			VectorElementType operator()(size_t i,size_t j) const$/;"	f	class:PsimagLite::ChebyshevSolver::InternalMatrix
operator ()	PsimagLite/src/CrsMatrix.h	/^		T operator()(int i,int j) const $/;"	f	class:PsimagLite::CrsMatrix
operator ()	PsimagLite/src/Geometry/Geometry.h	/^			RealType operator()$/;"	f	class:PsimagLite::Geometry
operator ()	PsimagLite/src/Geometry/GeometryDirection.h	/^			RealType operator()(size_t i,size_t edof1,size_t j,size_t edof2) const$/;"	f	class:PsimagLite::GeometryDirection
operator ()	PsimagLite/src/Geometry/GeometryTerm.h	/^			const RealType& operator()(size_t i1,size_t edof1,size_t i2,size_t edof2) const$/;"	f	class:PsimagLite::GeometryTerm
operator ()	PsimagLite/src/Geometry/GeometryTerm.h	/^			const RealType& operator()(size_t smax,size_t emin,size_t i1,size_t edof1,size_t i2,size_t edof2) const$/;"	f	class:PsimagLite::GeometryTerm
operator ()	PsimagLite/src/JSON/JsonParser/StateTranslationTable.h	/^    StatesAndActionsType operator() (StatesAndActionsType currentState, CharacterClass cls) {$/;"	f	class:JsonParser::StateTranslationTable
operator ()	PsimagLite/src/JSON/MatrixLike.h	/^      const value_type operator() (size_t i, size_t j) const {$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
operator ()	PsimagLite/src/JSON/MatrixLike.h	/^      int operator () (const MatrixLikeType& A, PsimagLite::Matrix<T>& INV) {$/;"	f	class:psimag::MatrixLike::INVERT
operator ()	PsimagLite/src/JSON/MatrixLike.h	/^      value_type operator() (size_t i, size_t j) {$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
operator ()	PsimagLite/src/JSON/Transposer.h	/^    const value_type& operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::Transposer
operator ()	PsimagLite/src/JSON/Transposer.h	/^    value_type operator () (size_t rowIndex, size_t colIndex) const {$/;"	f	class:psimag::Transposed
operator ()	PsimagLite/src/JSON/Transposer.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::Transposed
operator ()	PsimagLite/src/JSON/Transposer.h	/^    value_type& operator () (size_t rowIndex, size_t colIndex) {$/;"	f	class:psimag::Transposer
operator ()	PsimagLite/src/LanczosVectors.h	/^		VectorElementType& operator()(size_t i,size_t j)$/;"	f	class:PsimagLite::LanczosVectors
operator ()	PsimagLite/src/LanczosVectors.h	/^		const VectorElementType& operator()(size_t i,size_t j) const$/;"	f	class:PsimagLite::LanczosVectors
operator ()	PsimagLite/src/LinearPrediction.h	/^		const FieldType& operator()(size_t i) const$/;"	f	class:PsimagLite::LinearPrediction
operator ()	PsimagLite/src/Matrix.h	/^		T& operator()(size_t i,size_t j)$/;"	f	class:PsimagLite::Matrix
operator ()	PsimagLite/src/Matrix.h	/^		const T& operator()(size_t i,size_t j) const$/;"	f	class:PsimagLite::Matrix
operator ()	PsimagLite/src/Random48.h	/^		T operator()() const { return static_cast<T>(drand48()); }$/;"	f	class:PsimagLite::Random48
operator ()	PsimagLite/src/RandomForTests.h	/^		T operator()()$/;"	f	class:PsimagLite::RandomForTests
operator ()	PsimagLite/src/Sort.h	/^			bool operator()(const PairType& x1,const PairType& x2)$/;"	f	class:Sort::Compare
operator ()	gap.h	/^		ComplexType operator()(VectorType& k, size_t band) {$/;"	f	class:rpa::gap
operator ()	gaps2D.h	/^		ComplexType operator()(VectorType& k, size_t band) {$/;"	f	class:rpa::gap2D
operator ()	gaps3D.h	/^        ComplexType operator()(VectorType& k, size_t band,ComplexMatrixType& ak) {$/;"	f	class:rpa::gap3D
operator ()	sepBasis.h	/^		Field operator()(const size_t iB,const size_t l1,const size_t l2) {$/;"	f	class:rpa::sepBasis
operator *	PartialPsimag/Matrix.h	/^  operator * (const psimag::Matrix<T>& left,$/;"	f	namespace:psimag
operator *	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    const AppliedSymmetryElementType& operator* () {$/;"	f	class:psimag::AppliedSymmetryElementIterator
operator *	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianPosition<Field,DIM>  operator * (const CartesianPosition<Field,DIM>& p) const {$/;"	f	class:psimag::CartesianRotation
operator *	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianRotation<Field,DIM> operator*(const CartesianRotation<Field,DIM>& S) {$/;"	f	class:psimag::CartesianRotation
operator *	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianTranslation<Field,DIM> operator*(const CartesianTranslation<Trans_Field,DIM> t) {$/;"	f	class:psimag::CartesianRotation
operator *	PartialPsimag/Symmetry/CellRotation.h	/^    CellDirection<Field,DIM> operator*(const CellDirection<In_Field,DIM> t) {$/;"	f	class:psimag::CellRotation
operator *	PartialPsimag/Symmetry/CellRotation.h	/^    CellPosition<Field,DIM,Algorithms>  operator * (const CellPosition<In_Field,DIM,Algorithms>& p) const {$/;"	f	class:psimag::CellRotation
operator *	PartialPsimag/Symmetry/CellTranslation.h	/^  CellTranslation<Field,DIM>  operator * (const CellTranslation<Field,DIM>& lhs, Field scalar){$/;"	f	namespace:psimag
operator *	PartialPsimag/Symmetry/Mat/MatMult.h	/^  operator * (const MatType&  m, $/;"	f	namespace:psimag
operator *	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix<Field,DIM> operator*(const SeitzMatrix<Field,DIM>& S) {$/;"	f	class:psimag::SeitzMatrix
operator *	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzVector<Field,DIM> operator*(const SeitzVector<Trans_Field,DIM> t) {$/;"	f	class:psimag::SeitzMatrix
operator *	PartialPsimag/Symmetry/SeitzVector.h	/^  LField operator * (const SeitzVector<LField,DIM,0>& lhs,$/;"	f	namespace:psimag
operator *	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,IND>  operator * (Field scalar, const SeitzVector<Field,DIM,IND>& lhs){$/;"	f	namespace:psimag
operator *	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,IND>  operator * (const SeitzVector<Field,DIM,IND>& lhs, Field scalar){$/;"	f	namespace:psimag
operator *	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,IND>  operator * (const SeitzVector<Field,DIM,IND>& lhs, std::string scalarStr){$/;"	f	namespace:psimag
operator *	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator*(Int a)$/;"	f	class:rational
operator *	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator*(rational<Int> v)$/;"	f	class:rational
operator *	PartialPsimag/Vec.h	/^  T operator * (const Vec<T,2>& a, const Vec<T,2>& b)$/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  T operator * (const Vec<T,3>& a, const Vec<T,3>& b)$/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  T operator * (const Vec<T,DIM>& a, $/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  Vec<T,2> operator * (const T& a, const Vec<T,2>& b)$/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  Vec<T,2> operator * (const Vec<T,2>& b, const T& a)$/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  Vec<T,3> operator * (const T& a, const Vec<T,3>& b)$/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  Vec<T,3> operator * (const Vec<T,3>& b, const T& a)$/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  Vec<T,DIM> operator * (const T& a, $/;"	f	namespace:psimag
operator *	PartialPsimag/Vec.h	/^  Vec<T,DIM> operator * (const Vec<T,DIM>& b, $/;"	f	namespace:psimag
operator *	PsimagLite/src/Complex.h	/^	std::complex<double> operator*(int x,const std::complex<double>& y)$/;"	f	namespace:std
operator *	PsimagLite/src/CrsMatrix.h	/^	CrsMatrix<T1> operator*(const CrsMatrix<T1>& a,const CrsMatrix<T2>& b)$/;"	f	namespace:PsimagLite
operator *	PsimagLite/src/CrsMatrix.h	/^	CrsMatrix<T2> operator*(const T1& t1,const CrsMatrix<T2>& a)$/;"	f	namespace:PsimagLite
operator *	PsimagLite/src/JSON/OperationClosure.h	/^  OperationClosure<OperationClosure<Operand1Type,Operator,Operand2Type>,OP::TIMES,T > operator * (OperationClosure<Operand1Type,Operator,Operand2Type> lhs, $/;"	f	namespace:psimag
operator *	PsimagLite/src/JSON/OperationClosure.h	/^  OperationClosure<T,OP::TIMES,OperationClosure<Operand1Type,Operator,Operand2Type> > operator * (T& lhs, $/;"	f	namespace:psimag
operator *	PsimagLite/src/Vector.h	/^	inline X operator*(std::vector<X> const &v,std::vector<X> const &w)$/;"	f	namespace:std
operator *	PsimagLite/src/Vector.h	/^	inline std::vector<T2> operator*(const T1& v1,const std::vector<T2>& v2)$/;"	f	namespace:std
operator *=	PartialPsimag/Matrix.h	/^    ThisType& operator *= (const T& val)$/;"	f	class:psimag::Matrix
operator *=	PartialPsimag/Symmetry/SeitzVector.h	/^    ThisType& operator *= (const Field2& val){$/;"	f	class:psimag::SeitzVector
operator *=	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator*=(Int a)$/;"	f	class:rational
operator *=	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator*=(rational<Int> v)$/;"	f	class:rational
operator *=	PartialPsimag/Vec.h	/^    Vec<T,2>& operator *= (const T& a) $/;"	f	class:psimag::Vec
operator *=	PartialPsimag/Vec.h	/^    Vec<T,3>& operator *= (const T& a) $/;"	f	class:psimag::Vec
operator *=	PartialPsimag/Vec.h	/^    Vec<T,DIM>& operator *= (const T& a) $/;"	f	class:psimag::Vec
operator *=	PartialPsimag/Vector.h	/^		Vector<T>& operator*=(Vector<T>& v,ScalarType x)$/;"	f	class:psimag::Vector
operator *=	PsimagLite/src/CrsMatrix.h	/^		void operator*=(T x)$/;"	f	class:PsimagLite::CrsMatrix
operator *=	PsimagLite/src/Vector.h	/^	inline std::vector<T1> operator*=(std::vector<T1>& v,const T2& t2) $/;"	f	namespace:std
operator +	PartialPsimag/Symmetry/CellPosition.h	/^  CellPosition<Field,DIM,Algorithms> operator+ (const CellPosition<Field,DIM,Algorithms>& cellPosition, $/;"	f	namespace:psimag
operator +	PartialPsimag/Symmetry/Mat/MatSum.h	/^  MatType<T,NCOL,NROW> operator + (const MatType<T,NCOL,NROW>&  m, $/;"	f	namespace:psimag
operator +	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,0> operator + (const SeitzVector<Field,DIM,0>& lhs,$/;"	f	namespace:psimag
operator +	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,1> operator + (const SeitzVector<Field,DIM,0>& lhs,$/;"	f	namespace:psimag
operator +	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator+(rational<Int> v)$/;"	f	class:rational
operator +	PartialPsimag/Vec.h	/^  Vec<T,2> operator + (const Vec<T,2,Traits>& a, const Vec<T,2,Traits>& b)$/;"	f	namespace:psimag
operator +	PartialPsimag/Vec.h	/^  Vec<T,3> operator + (const Vec<T,3>& a, const Vec<T,3>& b)$/;"	f	namespace:psimag
operator +	PartialPsimag/Vec.h	/^  Vec<T,DIM> operator + (const Vec<T,DIM>& a, $/;"	f	namespace:psimag
operator +	PsimagLite/src/JSON/OperationClosure.h	/^		   OperationClosure<Operand21Type,Operator2,Operand22Type> > operator + (OperationClosure<Operand11Type,Operator1,Operand12Type> lhs, $/;"	f	namespace:psimag
operator +	PsimagLite/src/Matrix.h	/^	Matrix<T> operator+(const Matrix<T>& a,const Matrix<T>& b)$/;"	f	namespace:PsimagLite
operator +	PsimagLite/src/Vector.h	/^	inline std::vector<T1> operator+(const std::vector<T1>& v1,const std::vector<T2>& v2)$/;"	f	namespace:std
operator ++	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    AppliedSymmetryElementIteratorType operator++ (int dummy) {$/;"	f	class:psimag::AppliedSymmetryElementIterator
operator ++	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    AppliedSymmetryElementIteratorType& operator++ () {$/;"	f	class:psimag::AppliedSymmetryElementIterator
operator +=	PartialPsimag/Matrix.h	/^    ThisType& operator += (const ThisType& other)$/;"	f	class:psimag::Matrix
operator +=	PartialPsimag/Symmetry/CartesianRotation.h	/^    CartesianRotation<Field,DIM> operator += (const CartesianTranslation<IN_TYPE,DIM>& T) {$/;"	f	class:psimag::CartesianRotation
operator +=	PartialPsimag/Symmetry/OccupantClosure.h	/^    OccupantClosure& operator+= (const CartesianPositionType& cartPosition) {$/;"	f	class:psimag::OccupantClosure
operator +=	PartialPsimag/Symmetry/OccupantClosure.h	/^    OccupantClosure& operator+= (const CellPositionType& cellPosition) {$/;"	f	class:psimag::OccupantClosure
operator +=	PartialPsimag/Symmetry/SeitzMatrix.h	/^    SeitzMatrix<Field,DIM> operator += (const SeitzVector<IN_TYPE,DIM>& T) {$/;"	f	class:psimag::SeitzMatrix
operator +=	PartialPsimag/Symmetry/SeitzVector.h	/^    ThisType& operator += (const Field2& val){$/;"	f	class:psimag::SeitzVector
operator +=	PartialPsimag/Symmetry/SeitzVector.h	/^    ThisType& operator += (const SeitzVector<Field2,DIM,0, OtherTraits>& v)$/;"	f	class:psimag::SeitzVector
operator +=	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator+=(rational<Int> v)$/;"	f	class:rational
operator +=	PartialPsimag/Vec.h	/^    Vec<T,2>& operator += (const Vec<T,OtherDIM>& v)$/;"	f	class:psimag::Vec
operator +=	PartialPsimag/Vec.h	/^    Vec<T,3>& operator += (const Vec<T,3>& v)$/;"	f	class:psimag::Vec
operator +=	PartialPsimag/Vec.h	/^    Vec<T,DIM>& operator += (const Vec<T,DIM>& v)$/;"	f	class:psimag::Vec
operator +=	PsimagLite/src/CrsMatrix.h	/^		void operator+=(CrsMatrix<T> const &m) $/;"	f	class:PsimagLite::CrsMatrix
operator +=	PsimagLite/src/Matrix.h	/^		Matrix<T>& operator += (const Matrix<T>& other)$/;"	f	class:PsimagLite::Matrix
operator +=	PsimagLite/src/Vector.h	/^	inline std::vector<FieldType> operator+=(std::vector<FieldType>& v,const std::vector<FieldType>& w)$/;"	f	namespace:std
operator -	PartialPsimag/Symmetry/CellPosition.h	/^  CellTranslation<Field,DIM> operator-(const CellPosition<Field,DIM,Algorithms>& cellPosition1, $/;"	f	namespace:psimag
operator -	PartialPsimag/Symmetry/Mat/MatDifference.h	/^  operator - (const MatType <T,NCOL,NROW, TraitsTemplate <T,NCOL,NROW> >&  m, $/;"	f	namespace:psimag
operator -	PartialPsimag/Symmetry/SeitzMatrix.h	/^  SeitzMatrix<Field,DIM> operator - (const SeitzMatrix<Field,DIM>& lhs,$/;"	f	namespace:psimag
operator -	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,0> operator - (const SeitzVector<Field,DIM,0>& lhs){$/;"	f	namespace:psimag
operator -	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,0> operator - (const SeitzVector<Field,DIM,0>& lhs,$/;"	f	namespace:psimag
operator -	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,0> operator - (const SeitzVector<Field,DIM,1>& lhs,$/;"	f	namespace:psimag
operator -	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator-(rational<Int> v)$/;"	f	class:rational
operator -	PartialPsimag/Vec.h	/^  Vec<T,2> operator - (const Vec<T,2>& a)$/;"	f	namespace:psimag
operator -	PartialPsimag/Vec.h	/^  Vec<T,2> operator - (const Vec<T,2>& a, const Vec<T,2>& b)$/;"	f	namespace:psimag
operator -	PartialPsimag/Vec.h	/^  Vec<T,3> operator - (const Vec<T,3>& a)$/;"	f	namespace:psimag
operator -	PartialPsimag/Vec.h	/^  Vec<T,3> operator - (const Vec<T,3>& a, const Vec<T,3>& b)$/;"	f	namespace:psimag
operator -	PartialPsimag/Vec.h	/^  Vec<T,DIM> operator - (const Vec<T,DIM>& a)$/;"	f	namespace:psimag
operator -	PartialPsimag/Vec.h	/^  Vec<T,DIM> operator - (const Vec<T,DIM>& a, $/;"	f	namespace:psimag
operator -	PsimagLite/src/Matrix.h	/^	Matrix<T> operator-(const Matrix<T>& a,const Matrix<T>& b)$/;"	f	namespace:PsimagLite
operator -	PsimagLite/src/Vector.h	/^	inline std::vector<T1> operator-(const std::vector<T1>& v1,const std::vector<T2>& v2)$/;"	f	namespace:std
operator -=	PartialPsimag/Symmetry/SeitzVector.h	/^    SeitzVector<Field,DIM,IND>& operator -= (const SeitzVector<Field2,DIM,0>& v)$/;"	f	class:psimag::SeitzVector
operator -=	PartialPsimag/Symmetry/SeitzVector.h	/^    ThisType& operator -= (const Field2& val){$/;"	f	class:psimag::SeitzVector
operator -=	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator-=(rational<Int> v)$/;"	f	class:rational
operator -=	PartialPsimag/Vec.h	/^    Vec<T,2>& operator -= (const Vec<T,2>& v)$/;"	f	class:psimag::Vec
operator -=	PartialPsimag/Vec.h	/^    Vec<T,3>& operator -= (const Vec<T,3>& v)$/;"	f	class:psimag::Vec
operator -=	PartialPsimag/Vec.h	/^    Vec<T,DIM>& operator -= (const Vec<T,DIM>& v)$/;"	f	class:psimag::Vec
operator -=	PsimagLite/src/Matrix.h	/^		Matrix<T>& operator -= (const Matrix<T>& other)$/;"	f	class:PsimagLite::Matrix
operator -=	PsimagLite/src/Vector.h	/^	inline std::vector<FieldType> operator-=(std::vector<FieldType>& v,const std::vector<FieldType>& w)$/;"	f	namespace:std
operator /	PartialPsimag/Symmetry/SeitzVector.h	/^  SeitzVector<Field,DIM,0>  operator \/ (const SeitzVector<Field,DIM,0>& lhs, Field scalar){$/;"	f	namespace:psimag
operator /	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator\/(rational<Int> v)$/;"	f	class:rational
operator /	PartialPsimag/Vec.h	/^  Vec<T,2,Traits> operator \/ (const Vec<T,2,Traits>& b, const T& a)$/;"	f	namespace:psimag
operator /	PartialPsimag/Vec.h	/^  Vec<T,3,Traits> operator \/ (const Vec<T,3,Traits>& b, const T& a)$/;"	f	namespace:psimag
operator /	PartialPsimag/Vec.h	/^  Vec<T,DIM, Traits> operator \/ (const Vec<T,DIM,Traits>& b, $/;"	f	namespace:psimag
operator /=	PartialPsimag/Matrix.h	/^    ThisType& operator \/= (const T& val)$/;"	f	class:psimag::Matrix
operator /=	PartialPsimag/Symmetry/rational.h	/^  rational<Int> operator\/=(rational<Int> v)$/;"	f	class:rational
operator /=	PartialPsimag/Vec.h	/^    Vec<T,DIM>& operator \/= (const T& a) $/;"	f	class:psimag::Vec
operator /=	PsimagLite/src/Vector.h	/^	inline std::vector<T1> operator\/=(std::vector<T1>& v,const T2& t2) $/;"	f	namespace:std
operator <	PartialPsimag/Symmetry/CellPosition.h	/^  bool operator< (const CellPosition<Field,DIM, Algorithms>& lhs, $/;"	f	namespace:psimag
operator <	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  bool operator< (const LatticeCoordinates<DIM>& lhs, $/;"	f	namespace:psimag
operator <	PartialPsimag/Symmetry/Occupant.h	/^    bool operator< (const Occupant& other) const {$/;"	f	class:psimag::Occupant
operator <	PartialPsimag/Symmetry/rational.h	/^  bool operator<(rational<Int> v) { return (num*v.den) < (den*v.num); }$/;"	f	class:rational
operator <	PartialPsimag/Vec.h	/^  bool operator < ( const Vec<T,DIM>& a, const Vec<T,DIM>& b)$/;"	f	namespace:psimag
operator <<	PartialPsimag/Matrix.h	/^  std::ostream& operator << (std::ostream& os, const Matrix<T>& A) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/MatrixSlice.h	/^  std::ostream& operator << (std::ostream& os, const ColSlice<MatrixLikeType> ms) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/MatrixSlice.h	/^  std::ostream& operator << (std::ostream& os, const RowSlice<MatrixLikeType> ms) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/MatrixSlice.h	/^  std::ostream& operator << (std::ostream& os, const TransposedColSlice<MatrixLikeType> ms) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/MatrixSlice.h	/^  std::ostream& operator << (std::ostream& os, const TransposedRowSlice<MatrixLikeType> ms) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/AbstractRat.h	/^  std::ostream& operator<<(std::ostream&               os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^  std::ostream& operator << (std::ostream& os, const SymmetryOperation<Field,DIM,Algorithms>& S) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/CellParameters.h	/^  std::ostream& operator << (std::ostream& os, const CellParameters< Field, 1, Algorithms >& p) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/CellParameters.h	/^  std::ostream& operator << (std::ostream& os, const CellParameters< Field, 2 , Algorithms >& p) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/CellParameters.h	/^  std::ostream& operator << (std::ostream& os, const CellParameters< Field, 3 , Algorithms >& p) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/CellPosition.h	/^  std::ostream& operator << (std::ostream& os, const CellPosition<Field,DIM, Algorithms>& p) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/ConventionalCrystal.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/ConventionalLattice.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/Crystal.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/CrystalBase.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/FieldParser.h	/^  std::ostream& operator<<(std::ostream& os, const FieldParser<IntType>& fp)$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/Lattice.h	/^  std::ostream& operator << (std::ostream& os, const Lattice<Field,DIM,Algorithms>& cell) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/LatticeTransformation.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/LatticeWithPattern.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/Mat/Mat.h	/^  std::ostream& operator << (std::ostream& os, const Mat<T,NROW,NCOL,Traits> &m) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/Mat/MatPrint.h	/^inline  std::ostream& operator << (std::ostream& os, const MatType<T,NROW,NCOL>& m) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/MetricTensor.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/Occupant.h	/^inline  std::ostream& operator << (std::ostream& os, const Occupant& occupant) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/OriginLocator.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/Pattern.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/PatternData.h	/^  std::ostream& operator << (std::ostream& os, const PatternData<Field,DIM,Occupant, Algorithms>& patData) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/ReducedCrystal.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/ReducedLattice.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/STLUtil.h	/^std::ostream& operator<<(std::ostream& os, const std::map<K,T,C,A>& obj)$/;"	f
operator <<	PartialPsimag/Symmetry/STLUtil.h	/^std::ostream& operator<<(std::ostream& os, const std::vector<T,A>& obj)$/;"	f
operator <<	PartialPsimag/Symmetry/STLUtil.h	/^std::ostream& operator<<(std::ostream& os,$/;"	f
operator <<	PartialPsimag/Symmetry/SeitzMatrix.h	/^  inline  std::ostream& operator << (std::ostream& os, const SeitzMatrix<Field,DIM>& s) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/SeitzVector.h	/^  std::ostream& operator << (std::ostream& os, const SeitzVector<Field,DIM,IND>& t) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/SpaceGroup.h	/^  std::ostream& operator << (std::ostream& os, SpaceGroup<Field,DIM,Occupant,Algorithms> spaceGroup) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/SpaceGroup2D.h	/^  std::ostream& operator << (std::ostream& os, SpaceGroup<Field,2,Occupant,Algorithms> spaceGroup) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/SuperCrystal.h	/^  inline  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^  inline  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/Symmetry.h	/^  std::ostream& operator << (std::ostream& os, $/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/SymmetryElement.h	/^  std::ostream& operator << (std::ostream& os, const SymmetryElement<Field,DIM,Algorithms>& el) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/SymmetryOperation.h	/^  std::ostream& operator << (std::ostream& os, const SymmetryOperation<Field,DIM,Algorithms>& S) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Symmetry/rational.h	/^std::ostream& operator<<(std::ostream& s, rational<Int> a)$/;"	f
operator <<	PartialPsimag/Tag.h	/^    Tag& operator << (const Type& something) {$/;"	f	class:psimag::Tag
operator <<	PartialPsimag/Tag.h	/^    Tag& operator << (const std::vector<Type>& something) {$/;"	f	class:psimag::Tag
operator <<	PartialPsimag/Tag.h	/^  inline std::ostream& operator << (std::ostream& os, const Tag& t) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/TagAttributes.h	/^  inline std::ostream& operator << (std::ostream& os, const TagAttributes& attr) {$/;"	f	namespace:psimag
operator <<	PartialPsimag/Vec.h	/^  inline std::ostream& operator << (std::ostream& os, const Vec<T,DIM> &v)$/;"	f	namespace:psimag
operator <<	PartialPsimag/Vec.h	/^  std::ostream& operator << (std::ostream& os, const Vec<T,2> &v)$/;"	f	namespace:psimag
operator <<	PartialPsimag/Vec.h	/^  std::ostream& operator << (std::ostream& os, const Vec<T,3> &v)$/;"	f	namespace:psimag
operator <<	PartialPsimag/XMLHeading.h	/^  inline std::ostream& operator << (std::ostream& os, const XMLHeading& h ) {$/;"	f	namespace:psimag
operator <<	PsimagLite/drivers/minimizer.cpp	/^std::ostream& operator<<(std::ostream& os,const std::vector<T>& v)$/;"	f
operator <<	PsimagLite/drivers/testCRSMatrix.cpp	/^std::ostream& operator<<(std::ostream& os,const std::vector<T>& v)$/;"	f
operator <<	PsimagLite/src/CrsMatrix.h	/^	std::ostream &operator<<(std::ostream &os,const CrsMatrix<T> &m)$/;"	f	namespace:PsimagLite
operator <<	PsimagLite/src/Geometry/Geometry.h	/^	std::ostream& operator<<(std::ostream& os,const Geometry<RealType,PgType>& g) $/;"	f	namespace:PsimagLite
operator <<	PsimagLite/src/Geometry/GeometryDirection.h	/^	std::ostream& operator<<(std::ostream& os,const GeometryDirection<RealType,GeometryFactoryType>& gd)$/;"	f	namespace:PsimagLite
operator <<	PsimagLite/src/Geometry/GeometryTerm.h	/^	std::ostream& operator<<(std::ostream& os,const GeometryTerm<RealType>& gt)$/;"	f	namespace:PsimagLite
operator <<	PsimagLite/src/IoSimple.h	/^	IoSimple::Out& operator<<(IoSimple::Out& io,const T& t)$/;"	f	namespace:PsimagLite
operator <<	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^  std::wostream& operator << (std::wostream& os, const DefaultContext& ctx) {$/;"	f	namespace:JsonParser
operator <<	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  StreamType& operator << (StreamType& os, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <<	PsimagLite/src/Matrix.h	/^	std::ostream &operator<<(std::ostream &os,Matrix<T> const &A)$/;"	f	namespace:PsimagLite
operator <<	PsimagLite/src/SampleCRSMatrix.h	/^	std::ostream& operator<<(std::ostream& os,const SampleCRSMatrix<T>& m)$/;"	f	namespace:PsimagLite
operator <<	PsimagLite/src/Stack.h	/^	ostream& operator<<(ostream& os,const stack<FieldType>& st)$/;"	f	namespace:std
operator <<	PsimagLite/src/Vector.h	/^	std::ostream &operator<<(std::ostream &s,std::vector<X> const &v)$/;"	f	namespace:std
operator <<	utilities.h	/^std::ostream& operator<<(std::ostream& os, std::vector<MatrixTemplate<std::complex<FieldType> > > & v)$/;"	f
operator <<	utilities.h	/^std::ostream& operator<<(std::ostream& os,std::vector<FieldType>& v)$/;"	f
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  bool& operator <= (bool& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  double& operator <= (double& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  float& operator <= (float& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  int& operator <= (int& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  size_t& operator <=(size_t& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  std::complex<T>& operator <= (std::complex<T>& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  std::map<std::string,T>& operator <= (std::map<std::string,T>& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  std::string& operator <= (std::string& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  std::vector<T>& operator <= (std::vector<T>& lhs, const Whatever& w) {$/;"	f	namespace:JsonParser
operator <=	PsimagLite/src/JSON/JsonReader.h	/^  MatrixTemplate<T>& operator <= $/;"	f	namespace:dca
operator <=	PsimagLite/src/JSON/JsonReader.h	/^  psimag::Transposer<MatrixLikeType>& operator <= $/;"	f	namespace:dca
operator =	PartialPsimag/Matrix.h	/^    Matrix<T> &operator=(const Matrix<T>& mat)$/;"	f	class:psimag::Matrix
operator =	PartialPsimag/Matrix.h	/^    ThisType& operator = (const OperationClosure<ThisType, OP::TIMES, ThisType>& closure)$/;"	f	class:psimag::Matrix
operator =	PartialPsimag/Matrix.h	/^    ThisType& operator = (const T& val)$/;"	f	class:psimag::Matrix
operator =	PartialPsimag/Matrix.h	/^    ThisType& operator = (const UnaryOperationClosure< OP::INV, psimag::Matrix<T> >& closure)$/;"	f	class:psimag::Matrix
operator =	PartialPsimag/MatrixSlice.h	/^    ThisType& operator = (const VectorLike& v) {$/;"	f	class:psimag::RowSlice
operator =	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    AppliedSymmetryElement& operator = (const AppliedSymmetryElement& op) {$/;"	f	class:psimag::AppliedSymmetryElement
operator =	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    AppliedSymmetryElelment& operator = (const AppliedSymmetryElement& op) {$/;"	f	class:psimag::AppliedSymmetryElement
operator =	PartialPsimag/Symmetry/CellPosition.h	/^    ThisType& operator = (const ThisType& v)$/;"	f	class:psimag::CellPosition
operator =	PartialPsimag/Symmetry/CellTranslation.h	/^    ThisType& operator = (const ThisType& v)$/;"	f	class:psimag::CellTranslation
operator =	PartialPsimag/Symmetry/LatticeCoordinates.h	/^    ThisType& operator = (const ThisType& v)$/;"	f	class:psimag::LatticeCoordinates
operator =	PartialPsimag/Symmetry/Mat/Mat.h	/^    ThisType& operator = (const Field& a)$/;"	f	class:psimag::Mat
operator =	PartialPsimag/Symmetry/Mat/Mat.h	/^    ThisType& operator = (const ThisType& m)$/;"	f	class:psimag::Mat
operator =	PartialPsimag/Symmetry/Occupant.h	/^    Occupant& operator=(const Occupant& occupant) {$/;"	f	class:psimag::Occupant
operator =	PartialPsimag/Symmetry/SeitzVector.h	/^    ThisType& operator = (const SeitzVector<Field2,DIM,IND, OtherTraits>& v)$/;"	f	class:psimag::SeitzVector
operator =	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    SpaceGroup& operator = (const SpaceGroup& sg) {$/;"	f	class:psimag::SpaceGroup
operator =	PartialPsimag/Symmetry/SymmetryElement.h	/^    SymmetryElement& operator = (const SymmetryElement& el) {$/;"	f	class:psimag::SymmetryElement
operator =	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SymmetryOperation& operator = (const SymmetryOperation& op) {$/;"	f	class:psimag::SymmetryOperation
operator =	PartialPsimag/Tag.h	/^    Tag& operator= (const Tag& tag) {$/;"	f	class:psimag::Tag
operator =	PartialPsimag/TagAttributes.h	/^    TagAttributesClosure& operator = (const InType& obj) {$/;"	f	class:psimag::TagAttributesClosure
operator =	PartialPsimag/TagAttributes.h	/^    TagAttributesClosure& operator = (const std::pair<InType1,InType2>& obj) {$/;"	f	class:psimag::TagAttributesClosure
operator =	PartialPsimag/TagAttributes.h	/^    TagAttributesClosure& operator = (const std::vector<InType>& vec) {$/;"	f	class:psimag::TagAttributesClosure
operator =	PartialPsimag/Vec.h	/^    Vec<T,2>& operator = (const T& a) $/;"	f	class:psimag::Vec
operator =	PartialPsimag/Vec.h	/^    Vec<T,2>& operator = (const Vec<T,2>& v)$/;"	f	class:psimag::Vec
operator =	PartialPsimag/Vec.h	/^    Vec<T,3>& operator = (const T& a) $/;"	f	class:psimag::Vec
operator =	PartialPsimag/Vec.h	/^    Vec<T,3>& operator = (const Vec<T,3>& v)$/;"	f	class:psimag::Vec
operator =	PartialPsimag/Vec.h	/^    Vec<T,DIM>& operator = (const T& a) $/;"	f	class:psimag::Vec
operator =	PartialPsimag/Vec.h	/^    Vec<T,DIM>& operator = (const Vec<T,DIM>& v) $/;"	f	class:psimag::Vec
operator =	PsimagLite/src/CrsMatrix.h	/^		void operator=(const VerySparseMatrixType& m)$/;"	f	class:PsimagLite::CrsMatrix
operator =	PsimagLite/src/Geometry/GeometryFactory.h	/^		GeometryFactory& operator=(const GeometryFactory& g)$/;"	f	class:PsimagLite::GeometryFactory
operator =	PsimagLite/src/JSON/JSN_Writer.h	/^      void operator= (const T& val) {$/;"	f	class:dca::JSN::KeyReference
operator =	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& operator = (const T& value) {$/;"	f	class:JsonParser::Whatever
operator =	PsimagLite/src/JSON/Transposer.h	/^    ThisType& operator = (ThisType& other) {$/;"	f	class:psimag::Transposer
operator =	chi0.h	/^		susc& operator=(const susc& other) {$/;"	f	class:rpa::susc
operator ==	PartialPsimag/KISS.h	/^    friend bool operator == (const KISS& a, const KISS& b)$/;"	f	class:psimag::KISS
operator ==	PartialPsimag/Matrix.h	/^  bool Matrix<T>::operator == (const Matrix<T>& m)$/;"	f	class:psimag::Matrix
operator ==	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    bool operator== (const AppliedSymmetryElementIteratorType& other) { return (position == other.position); }$/;"	f	class:psimag::AppliedSymmetryElementIterator
operator ==	PartialPsimag/Symmetry/Mat/MatEqual.h	/^  bool operator == (const MatType <T,NCOL,NROW, TraitsTemplate <T,NCOL,NROW> >& m, $/;"	f	namespace:psimag
operator ==	PartialPsimag/Symmetry/Mat/MatEqual.h	/^  bool operator == (const MatType<T,NCOL,NROW>&  m, $/;"	f	namespace:psimag
operator ==	PartialPsimag/Symmetry/Occupant.h	/^    bool operator==(const Occupant &occupant) const {$/;"	f	class:psimag::Occupant
operator ==	PartialPsimag/Symmetry/SeitzMatrix.h	/^  bool operator == (const SeitzMatrix<Field,DIM>& lhs, $/;"	f	namespace:psimag
operator ==	PartialPsimag/Symmetry/SeitzVector.h	/^  bool operator == (const SeitzVector<Field1,DIM,IND>& lhs,$/;"	f	namespace:psimag
operator ==	PartialPsimag/Symmetry/SymmetryElement.h	/^  bool operator == (const SymmetryElement<Field,DIM,Algorithms>& el,$/;"	f	namespace:psimag
operator ==	PartialPsimag/Symmetry/rational.h	/^  bool operator==(rational<Int> v) { return (num==v.num) && (den==v.den); }$/;"	f	class:rational
operator ==	PartialPsimag/Vec.h	/^  bool operator == (const Vec<T,DIM>& a, const Vec<T,DIM>& b)$/;"	f	namespace:psimag
operator >	PartialPsimag/Symmetry/rational.h	/^  bool operator>(rational<Int> v) { return (num*v.den) > (den*v.num); }$/;"	f	class:rational
operator >>	PartialPsimag/Matrix.h	/^  std::istream& operator >> (std::istream& is, Matrix<T>& A) {$/;"	f	namespace:psimag
operator >>	PartialPsimag/Symmetry/Mat/Mat.h	/^  std::istream& operator >> (std::istream& is, Mat<T,NROW,NCOL>& m) {$/;"	f	namespace:psimag
operator >>	PartialPsimag/Symmetry/STLUtil.h	/^std::istream& operator>>(std::istream& is, std::map<K,T,C,A>& obj)$/;"	f
operator >>	PartialPsimag/Symmetry/STLUtil.h	/^std::istream& operator>>(std::istream& is, std::vector<T,A>& obj)$/;"	f
operator >>	PartialPsimag/Symmetry/STLUtil.h	/^std::istream& operator>>(std::istream& is,$/;"	f
operator >>	PartialPsimag/Vec.h	/^  inline std::istream& operator >> (std::istream& is, Vec<T,DIM>& v)$/;"	f	namespace:psimag
operator >>	PartialPsimag/Vec.h	/^  std::istream& operator >> (std::istream& is, Vec<T,2>& v)$/;"	f	namespace:psimag
operator >>	PartialPsimag/Vec.h	/^  std::istream& operator >> (std::istream& is, Vec<T,3>& v)$/;"	f	namespace:psimag
operator >>	PsimagLite/src/CrsMatrix.h	/^	std::istream &operator>>(std::istream &is,CrsMatrix<T>& m)$/;"	f	namespace:PsimagLite
operator >>	PsimagLite/src/IoSimple.h	/^	void operator>>(IoSimple::In& io,T& t)$/;"	f	namespace:PsimagLite
operator >>	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^  ParseBuffer& operator >> (ParseBuffer& buffer, T& value) {$/;"	f	namespace:JsonParser
operator >>	PsimagLite/src/Matrix.h	/^	std::istream& operator >> (std::istream& is, Matrix<T>& A)$/;"	f	namespace:PsimagLite
operator >>	PsimagLite/src/Stack.h	/^	istream& operator>>(istream& is,stack<X>& x)$/;"	f	namespace:std
operator >>	PsimagLite/src/Vector.h	/^	inline std::istream& operator>>(std::istream& is,std::vector<FieldType>& v)$/;"	f	namespace:std
operator >>	utilities.h	/^std::istream& operator>>(std::istream& is, std::vector<MatrixTemplate<std::complex<FieldType> > > & v)$/;"	f
operator CellPositions	PartialPsimag/Symmetry/OccupantClosure.h	/^    operator CellPositions() const {					\\$/;"	f	class:psimag::OccupantClosure
operator JSN&	PsimagLite/src/JSON/JSN_Writer.h	/^      operator JSN& () {$/;"	f	class:dca::JSN::KeyReference
operator LatticeType	PartialPsimag/Symmetry/ReciprocalLattice.h	/^    operator LatticeType() {$/;"	f	class:psimag::ReciprocalLattice
operator ValueType	PartialPsimag/TagAttributes.h	/^    operator ValueType() const {			$/;"	f	class:psimag::TagAttributesClosure
operator []	PartialPsimag/Matrix.h	/^    RowSlice<ThisType> operator [] (size_t row) {$/;"	f	class:psimag::Matrix
operator []	PartialPsimag/Matrix.h	/^    const RowSlice<const ThisType> operator [] (size_t row) const {$/;"	f	class:psimag::Matrix
operator []	PartialPsimag/MatrixSlice.h	/^    const value_type& operator[] (size_t componentIndex) const {$/;"	f	class:psimag::ColSlice
operator []	PartialPsimag/MatrixSlice.h	/^    const value_type& operator[] (size_t componentIndex) const {$/;"	f	class:psimag::RowSlice
operator []	PartialPsimag/MatrixSlice.h	/^    value_type operator[] (size_t componentIndex)  {$/;"	f	class:psimag::RowSlice
operator []	PartialPsimag/MatrixSlice.h	/^    value_type& operator[] (size_t componentIndex)  {$/;"	f	class:psimag::ColSlice
operator []	PartialPsimag/RealPart.h	/^    const value_type& operator[] (size_t componentIndex) const {$/;"	f	class:psimag::RealPart
operator []	PartialPsimag/RealPart.h	/^    value_type operator[] (size_t componentIndex)  {$/;"	f	class:psimag::RealPart
operator []	PartialPsimag/Symmetry/Lattice.h	/^    CartesianTranslationType operator [] (size_t j) const {$/;"	f	class:psimag::Lattice
operator []	PartialPsimag/Symmetry/Mat/Mat.h	/^    Field& operator[] (size_t i)$/;"	f	class:psimag::Mat
operator []	PartialPsimag/Symmetry/Mat/Mat.h	/^    const Field& operator[] (size_t i) const$/;"	f	class:psimag::Mat
operator []	PartialPsimag/Symmetry/OriginLocator.h	/^    OccupantClosureType operator [] (const Occupant& occupant) {$/;"	f	class:psimag::OriginLocator
operator []	PartialPsimag/Symmetry/SeitzVector.h	/^    Field& operator [] (size_t i) {  $/;"	f	class:psimag::SeitzVector
operator []	PartialPsimag/Symmetry/SeitzVector.h	/^    const Field& operator [] (size_t i) const {  $/;"	f	class:psimag::SeitzVector
operator []	PartialPsimag/TagAttributes.h	/^    TagAttributesClosure operator [] (std::string key) {$/;"	f	class:psimag::TagAttributes
operator []	PartialPsimag/Vec.h	/^    T& operator [] (size_t i) $/;"	f	class:psimag::Vec
operator []	PartialPsimag/Vec.h	/^    const T& operator [] (size_t i) const $/;"	f	class:psimag::Vec
operator []	PsimagLite/src/JSON/JSN_Writer.h	/^      KeyReference operator[](std::string subKey) { return writer.getComponentWriter(key)[subKey]; }$/;"	f	class:dca::JSN::KeyReference
operator []	PsimagLite/src/JSON/JSN_Writer.h	/^    KeyReference operator[](std::string key) { return KeyReference(key,*this); }$/;"	f	class:dca::JSN
operator []	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& operator[] (const std::string key) {$/;"	f	class:JsonParser::Whatever
operator []	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& operator[] (const std::wstring key) {$/;"	f	class:JsonParser::Whatever
operator []	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& operator[] (size_t index) {$/;"	f	class:JsonParser::Whatever
operator []	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    const Whatever& operator[] (const std::string key) const {$/;"	f	class:JsonParser::Whatever
operator []	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    const Whatever& operator[] (const std::wstring key) const {$/;"	f	class:JsonParser::Whatever
operator []	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    const Whatever& operator[] (size_t index) const {$/;"	f	class:JsonParser::Whatever
operator []	PsimagLite/src/JSON/JsonReader.h	/^    const JsonAccessor& operator[] (const std::string key) const {$/;"	f	class:dca::JsonReader
operator []	PsimagLite/src/JSON/JsonReader.h	/^    const JsonAccessor& operator[] (int index) {$/;"	f	class:dca::JsonReader
operator []	PsimagLite/src/JSON/Transposer.h	/^    const value_type& operator[] (size_t componentIndex) const {$/;"	f	class:psimag::Transposed
operator []	PsimagLite/src/JSON/Transposer.h	/^    const value_type& operator[] (size_t componentIndex) const {$/;"	f	class:psimag::Transposer
operator []	PsimagLite/src/JSON/Transposer.h	/^    value_type& operator[] (size_t componentIndex)  {$/;"	f	class:psimag::Transposed
operator []	PsimagLite/src/JSON/Transposer.h	/^    value_type& operator[] (size_t componentIndex)  {$/;"	f	class:psimag::Transposer
operator []	PsimagLite/src/Minimizer.h	/^		const FieldType& operator[](size_t i) const$/;"	f	class:PsimagLite::MockVector
operator psimag::AbstractRat<Int>	PartialPsimag/Symmetry/rational.h	/^  operator psimag::AbstractRat<Int>() {$/;"	f	class:rational
operatorPlus	PsimagLite/src/CrsMatrix.h	/^	void operatorPlus(CrsMatrix<T> &A,CrsMatrix<T> const &B,CrsMatrix<T> const &C)$/;"	f	namespace:PsimagLite
oppositeSpinPairing	parameters.h	/^		bool oppositeSpinPairing;$/;"	m	class:rpa::parameters
opsToXML	PartialPsimag/Symmetry/Symmetry.h	/^  Tag opsToXML(const Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>& symmetry) {$/;"	f	namespace:psimag
options	PsimagLite/src/ParametersForSolver.h	/^		std::string options;$/;"	m	struct:PsimagLite::ParametersForSolver
options	parameters.h	/^		std::string options;$/;"	m	class:rpa::parameters
orb1	bands.h	/^		std::vector<size_t> orb1,orb2;$/;"	m	class:rpa::Bands
orb1	bandstructure.h	/^		std::vector<size_t> orb1,orb2;$/;"	m	class:rpa::bandstructure
orb1	tbFromFile.h	/^		std::vector<size_t> orb1,orb2;$/;"	m	class:rpa::model
orb2	bands.h	/^		std::vector<size_t> orb1,orb2;$/;"	m	class:rpa::Bands
orb2	bandstructure.h	/^		std::vector<size_t> orb1,orb2;$/;"	m	class:rpa::bandstructure
orb2	tbFromFile.h	/^		std::vector<size_t> orb1,orb2;$/;"	m	class:rpa::model
orbOfEll	1band_wSpin.h	/^		std::vector<size_t> orbOfEll;$/;"	m	class:rpa::SingleBand_wSpin
orbOfEll	SrRuO_SO.h	/^		std::vector<size_t> orbOfEll;$/;"	m	class:rpa::model
orbToSite	parameters.h	/^		std::vector<int> orbToSite;$/;"	m	class:rpa::parameters
orbit	PartialPsimag/Symmetry/Orbits.h	/^    OrbitType& orbit(size_t i) {$/;"	f	class:psimag::Orbits
orbit	PartialPsimag/Symmetry/Orbits.h	/^    const OrbitType& orbit(size_t i) const {$/;"	f	class:psimag::Orbits
orbitFor	PartialPsimag/Symmetry/Orbits.h	/^    int orbitFor(size_t p) {$/;"	f	class:psimag::Orbits
orbitFor	PartialPsimag/Symmetry/Star.h	/^    int orbitFor(size_t p) {$/;"	f	class:psimag::Star
orbitSpace	PartialPsimag/Symmetry/Star.h	/^    OrbitSpaceType           orbitSpace;$/;"	m	class:psimag::Star
orbitString	PartialPsimag/Symmetry/Orbits.h	/^    std::string orbitString(size_t orbitIndex) const {$/;"	f	class:psimag::Orbits
orbitString	PartialPsimag/Symmetry/Star.h	/^    std::string orbitString(size_t orbitIndex) const {$/;"	f	class:psimag::Star
orbits	PartialPsimag/Symmetry/SymmetryGroup.h	/^    OrbitsType                               orbits;$/;"	m	class:psimag::SymmetryGroup
order	PartialPsimag/Symmetry/Lattice.h	/^    Vec<size_t, DIM>            order;           $/;"	m	class:psimag::Lattice
origin	PartialPsimag/Symmetry/FloodTiler.h	/^    CoordType                       origin;$/;"	m	class:psimag::FloodTiler
origin	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    static const std::string origin() {$/;"	f	class:psimag::SpaceGroupData
origional	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    BaseType origional;$/;"	m	class:psimag::HermiteNormalForm
os	PythonScripts/Calc_lambda.py	/^import os$/;"	i
os	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^import os$/;"	i
os	PythonScripts/CoupledLadders.py	/^import os$/;"	i
os	PythonScripts/Sr2RuO4.py	/^import os$/;"	i
os	PythonScripts/plotChiRPAAlongHighSym.py	/^import os$/;"	i
otherIndex	PartialPsimag/Symmetry/MetricTensor.h	/^    size_t otherIndex(size_t i, size_t j) {$/;"	f	class:psimag::MetricTensor
owner	PartialPsimag/Matrix.h	/^    bool owner;$/;"	m	class:psimag::Matrix
p1	PythonScripts/test.py	/^p1 = multiprocessing.Process(target=square_list, args=(mylist,0,1, result))$/;"	v
p2	PythonScripts/test.py	/^p2 = multiprocessing.Process(target=square_list, args=(mylist,2,3, result))$/;"	v
pageFaults	PsimagLite/src/Rusage.h	/^		long pageFaults() const { return rusage_.ru_majflt; }$/;"	f	class:PsimagLite::Rusage
pageReclaims	PsimagLite/src/Rusage.h	/^		long pageReclaims() const { return rusage_.ru_minflt; }$/;"	f	class:PsimagLite::Rusage
pairing	pairing.h	/^		pairing(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, $/;"	f	class:rpa::pairing
pairing	pairing.h	/^	class pairing {$/;"	c	namespace:rpa
pairingFromCharge	parameters.h	/^		size_t pairingFromCharge;$/;"	m	class:rpa::parameters
pairingFromSpin	parameters.h	/^		size_t pairingFromSpin;$/;"	m	class:rpa::parameters
pairingSpinParity	parameters.h	/^		size_t pairingSpinParity;$/;"	m	class:rpa::parameters
param	1band_wSpin.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::SingleBand_wSpin
param	4Orbital.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::FourOrbital
param	BSCCObilayer.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
param	BaFeAs_5orb.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::BaFeAs
param	FourOrbital.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::FourOrbital
param	KFe2Se2.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::KFe2Se2
param	SrRuO.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::SrRuO
param	SrRuO_SO.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
param	bands.h	/^		const rpa::parameters<Field,MatrixTemplate>& param;$/;"	m	class:rpa::Bands
param	bandstructure.h	/^		rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::bandstructure
param	bilayer.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
param	bilayerFESC.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
param	chi0.h	/^		rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::calcChi0Matrix
param	chi0.h	/^		rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::chi0q
param	chi0.h	/^		rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::susc
param	chi0Ofq.h	/^		const rpa::parameters<Field,MatrixTemplate>& param;$/;"	m	class:rpa::chi0ofq
param	coupledLadders.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
param	ferminator.h	/^		rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::ferminator
param	gap.h	/^		const rpa::parameters<Field,MatrixTemplate>& param;$/;"	m	class:rpa::gap
param	gaps2D.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::gap2D
param	gaps3D.h	/^        rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::gap3D
param	greensFunction.h	/^		const rpa::parameters<Field,MatrixTemplate>& param;$/;"	m	class:rpa::greensFunction
param	momentumDomain.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>&   param;$/;"	m	class:rpa::momentumDomain
param	orthoIIBilayer.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
param	pairing.h	/^		rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::pairing
param	rpa.h	/^			const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::interaction
param	rpa_CuO.h	/^			const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::interactionEmery
param	sepBasis.h	/^			const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::sepBasis
param	singleBand.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
param	susceptibility.h	/^			rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::susceptibility
param	tbFromFile.h	/^		const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& param;$/;"	m	class:rpa::model
parameters	PartialPsimag/Symmetry/Lattice.h	/^    CellParamType               parameters;     $/;"	m	class:psimag::Lattice
parameters	parameters.h	/^		parameters(ConcurrencyType& concurrency):$/;"	f	class:rpa::parameters
parameters	parameters.h	/^	class parameters {$/;"	c	namespace:rpa
params	PsimagLite/src/GslWrapper.h	/^			void * params;$/;"	m	struct:PsimagLite::GslWrapper::gsl_function
params_	PsimagLite/src/ChebyshevSerializer.h	/^		ParametersType params_;$/;"	m	class:PsimagLite::ChebyshevSerializer
params_	PsimagLite/src/ChebyshevSolver.h	/^		SolverParametersType& params_;$/;"	m	class:PsimagLite::ChebyshevSolver
parent	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever*      parent;$/;"	m	class:JsonParser::Whatever
parity	parameters.h	/^		Field parity;$/;"	m	class:rpa::parameters
paritySign	pairing.h	/^		FieldType paritySign;$/;"	m	class:rpa::pairing
parse	PartialPsimag/Symmetry/FieldParser.h	/^    const AbstractRat<IntType> parse() const {$/;"	f	class:psimag::FieldParser
parseChar	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    bool parseChar(std::wistream& inputStream) {$/;"	f	class:JsonParser::JsonParser
parseInput	PartialPsimag/Symmetry/FieldParser.h	/^    void parseInput() {$/;"	f	class:psimag::FieldParser
parseResult	PsimagLite/src/JSON/JsonReader.h	/^    JsonAccessor&                        parseResult;$/;"	m	class:dca::JsonReader
parseToDouble	PartialPsimag/Symmetry/FieldParser.h	/^    double parseToDouble() {$/;"	f	class:psimag::FieldParser
parseToFloat	PartialPsimag/Symmetry/FieldParser.h	/^	float parseToFloat() { return abstractRat.getFloat(); }$/;"	f	class:psimag::FieldParser
parser	PsimagLite/src/JSON/JsonReader.h	/^    JsonParser::JsonParser<JsonDataType> parser;$/;"	m	class:dca::JsonReader
pattern	PartialPsimag/Symmetry/GroupAction.h	/^    const PatternType&                       pattern; $/;"	m	class:psimag::GroupAction
pattern	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    PatternType    pattern;$/;"	m	class:psimag::LatticeWithPattern
pattern	PartialPsimag/Symmetry/OccupantClosure.h	/^    PatternType&      pattern;$/;"	m	class:psimag::OccupantClosure
patternData	PartialPsimag/Symmetry/OccupantClosure.h	/^    PatternDataType&  patternData;$/;"	m	class:psimag::OccupantClosure
patternData	PartialPsimag/Symmetry/OriginLocator.h	/^    PatternDataType         patternData;$/;"	m	class:psimag::OriginLocator
patternDistance	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    Field                                     patternDistance;$/;"	m	class:psimag::AppliedSymmetryElement
patternDistance	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    Field                    patternDistance;$/;"	m	class:psimag::AppliedSymmetryElement
performAction	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    void performAction(wchar_t nextChar, CharacterClass nextClass, StateType state, ActionType action) {$/;"	f	class:JsonParser::JsonParser
permute	PsimagLite/src/CrsMatrix.h	/^	void permute(CrsMatrix<S> &A,CrsMatrix<S> const &B,std::vector<size_t> const &perm)$/;"	f	namespace:PsimagLite
permuteInverse	PsimagLite/src/CrsMatrix.h	/^	void permuteInverse(CrsMatrix<S> &A,CrsMatrix<S> const &B,std::vector<size_t> const &perm)$/;"	f	namespace:PsimagLite
pfh	PsimagLite/src/Pthreads.h	/^	PthreadFunctionHolderType* pfh;$/;"	m	struct:PthreadFunctionStruct
phaseFactor	tbFromFile.h	/^		inline void phaseFactor(const VectorType& kOrg, ComplexMatrixType& eigenvects) {$/;"	f	class:rpa::model
pi_f	parameters.h	/^		const Field pi_f;$/;"	m	class:rpa::parameters
pickle	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^import _pickle as pickle$/;"	i
pickle	PythonScripts/CoupledLadders.py	/^import _pickle as pickle$/;"	i
pickle	PythonScripts/Sr2RuO4.py	/^import _pickle as pickle$/;"	i
pivotColumn	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    size_t pivotColumn(size_t row) const {$/;"	f	class:psimag::HermiteNormalForm
pivots	PartialPsimag/Matrix.h	/^    std::vector<int> pivots;$/;"	m	class:psimag::GESV
pivots	PartialPsimag/Matrix.h	/^    std::vector<int> pivots;$/;"	m	class:psimag::INVERT
pivots	PartialPsimag/MatrixLike.h	/^      std::vector<int> pivots;$/;"	m	class:psimag::MatrixLike::INVERT
pivots	PsimagLite/src/JSON/MatrixLike.h	/^      std::vector<int> pivots;$/;"	m	class:psimag::MatrixLike::INVERT
placeTileAt	PartialPsimag/Symmetry/FloodTiler.h	/^    void placeTileAt(const CoordType& coord) {$/;"	f	class:psimag::FloodTiler
placeTilesAdjacentTo	PartialPsimag/Symmetry/FloodTiler.h	/^    void placeTilesAdjacentTo(const CoordType& coord) {$/;"	f	class:psimag::FloodTiler
placeTilesAdjacentToInt	PartialPsimag/Symmetry/FloodTiler.h	/^    void placeTilesAdjacentToInt(const CoordType& coord, $/;"	f	class:psimag::FloodTiler
plot	PsimagLite/src/ChebyshevSerializer.h	/^		void plot(PlotDataType& result,$/;"	f	class:PsimagLite::ChebyshevSerializer
plot	PsimagLite/src/ContinuedFraction.h	/^		void plot(PlotDataType& result,const PlotParamsType& params) const$/;"	f	class:PsimagLite::ContinuedFraction
plot	PsimagLite/src/ContinuedFractionCollection.h	/^		void plot($/;"	f	class:PsimagLite::ContinuedFractionCollection
plotAll	PsimagLite/drivers/continuedFractionCollection.cpp	/^void plotAll(const ContinuedFractionCollectionType& cfCollection,$/;"	f
plotBandstructure	PythonScripts/Bandstructure.py	/^def plotBandstructure(fileID = ""):$/;"	f
plotChi0q	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def plotChi0q(self):$/;"	m	class:RPA
plotChiRPAw	PythonScripts/Plot_chiRPA_w.py	/^def plotChiRPAw(fileID = ""):$/;"	f
plotEvecs	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def plotEvecs(self):$/;"	m	class:RPA
plotOne	PsimagLite/src/ContinuedFractionCollection.h	/^		void plotOne($/;"	f	class:PsimagLite::ContinuedFractionCollection
plotOneByOne	PsimagLite/drivers/continuedFractionCollection.cpp	/^void plotOneByOne(const ContinuedFractionCollectionType& cfCollection,$/;"	f
plot_Fermi_surface	PythonScripts/Sr2RuO4.py	/^        def plot_Fermi_surface(self):$/;"	m	class:RPA
plot_colourline	PythonScripts/Bandstructure.py	/^	def plot_colourline(x,y,c,ax):$/;"	f	function:plotBandstructure
plotchi	PythonScripts/Plot_chiRPA_qxqy.py	/^def plotchi(file="chiRPA.txt"):$/;"	f
plotchi	PythonScripts/plotChiRPAAlongHighSym.py	/^def plotchi(U,Up,J,Jp):$/;"	f
plt	Plot_ek_high_sym.dat.py	/^import matplotlib.pyplot as plt$/;"	i
plt	PythonScripts/Bandstructure.py	/^import matplotlib.pyplot as plt$/;"	i
plt	PythonScripts/Plot_chiRPA_w.py	/^import matplotlib.pyplot as plt$/;"	i
plusOrigin	PartialPsimag/Symmetry/CartesianTranslation.h	/^    CartesianPositionType plusOrigin() const {$/;"	f	class:psimag::CartesianTranslation
pointGroup	PartialPsimag/Symmetry/Symmetry.h	/^    SymmetryGroupType            pointGroup;$/;"	m	class:psimag::Symmetry
pointGroupAppliedElements	PartialPsimag/Symmetry/SymmetryGroup.h	/^    AppliedSymmetryElementsPtrType pointGroupAppliedElements() const {$/;"	f	class:psimag::SymmetryGroup
pointer	PartialPsimag/Matrix.h	/^    typedef T*           pointer;$/;"	t	class:psimag::Matrix
pop	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    void pop(ModeType expectedMode) {$/;"	f	class:JsonParser::ModesMixin
posIndexToOrbit	PartialPsimag/Symmetry/Orbits.h	/^    std::map<size_t, size_t>                 posIndexToOrbit;$/;"	m	class:psimag::Orbits
posIndexToOrbit	PartialPsimag/Symmetry/Star.h	/^    std::map<size_t, size_t> posIndexToOrbit;$/;"	m	class:psimag::Star
position	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    size_t                             position;$/;"	m	class:psimag::AppliedSymmetryElementIterator
positionMap	PartialPsimag/Symmetry/OriginLocator.h	/^    std::vector<int> positionMap(SymmetryOperationType& symOp) {$/;"	f	class:psimag::OriginLocator
positions	PartialPsimag/Symmetry/PatternData.h	/^    CellPositions    positions;$/;"	m	class:psimag::PatternData
precalculate_ek0	PythonScripts/Sr2RuO4.py	/^        def precalculate_ek0(self):$/;"	m	class:RPA
precalculate_ekak	bandstructure.h	/^		void precalculate_ekak(bool calcGap=0) {$/;"	f	class:rpa::bandstructure
precalculate_ekqakq	bandstructure.h	/^		void precalculate_ekqakq(const VectorType& q, bool calcGap=0) {$/;"	f	class:rpa::bandstructure
precis	PsimagLite/src/JSON/JSN_Writer.h	/^    int  precis;$/;"	m	class:dca::JSN
predict	PsimagLite/src/LinearPrediction.h	/^		void predict(size_t p)$/;"	f	class:PsimagLite::LinearPrediction
prefix_	PsimagLite/src/ProgressIndicator.h	/^		std::string prefix_;$/;"	m	class:PsimagLite::ProgressIndicator
primes	PartialPsimag/Symmetry/AbstractRat.h	/^    static const int    primes[]; \/\/= {2,3,5,7,11,13,17,19};$/;"	m	class:psimag::AbstractRat
primes	PartialPsimag/Symmetry/AbstractRat.h	/^  const int AbstractRat<IntType>::primes[]={2,3,5,7,11,13,17,19};$/;"	m	class:psimag::AbstractRat
print	PartialPsimag/Matrix.h	/^    void print(std::ostream& os) const {$/;"	f	class:psimag::Matrix
print	PartialPsimag/Matrix.h	/^    void print(std::ostream& os, const ScalarType& scalar, int width) {$/;"	f	class:psimag::MatrixScalarPrinter
print	PartialPsimag/Matrix.h	/^    void print(std::ostream& os, const std::complex<ScalarType>& scalar, int width) {$/;"	f	class:psimag::MatrixScalarPrinter
print	PartialPsimag/MatrixLike.h	/^    void print(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
print	PartialPsimag/Symmetry/GroupAction.h	/^    void print(std::ostream& os, std::vector<int> subsetOfOps=std::vector<int>(0)) const {$/;"	f	class:psimag::GroupAction
print	PartialPsimag/VectorLike.h	/^    void print(const VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
print	PsimagLite/src/IoSimple.h	/^			void print(const T&  something)$/;"	f	class:PsimagLite::IoSimple::Out
print	PsimagLite/src/IoSimple.h	/^			void print(const std::string& something)$/;"	f	class:PsimagLite::IoSimple::Out
print	PsimagLite/src/JSON/JSN_Writer.h	/^    void print(std::ostream& os,int off=1,bool printLastBrace=true) const {$/;"	f	class:dca::JSN
print	PsimagLite/src/JSON/MatrixLike.h	/^    void print(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
print	PsimagLite/src/ProgressIndicator.h	/^		void print(const std::string& something,std::ostream& os) const$/;"	f	class:PsimagLite::ProgressIndicator
print	chi0.h	/^		void print() {$/;"	f	class:rpa::susc
printArray	PartialPsimag/MatrixLike.h	/^    void printArray(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
printArray	PartialPsimag/VectorLike.h	/^    void printArray(const VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
printArray	PsimagLite/src/JSON/MatrixLike.h	/^    void printArray(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
printChars	PsimagLite/scripts/functionSigIndent.pl	/^sub printChars$/;"	s
printChi0k	chi0.h	/^		void printChi0k(const VectorType& q) {$/;"	f	class:rpa::calcChi0Matrix
printFunc	PsimagLite/scripts/functionSigIndent.pl	/^sub printFunc$/;"	s
printGap	parameters.h	/^		size_t printGap;$/;"	m	class:rpa::parameters
printGap	susceptibility.h	/^		void printGap(const std::string& file="gapRPA.txt") {$/;"	f	class:rpa::susceptibility
printGap2	susceptibility.h	/^		void printGap2() {$/;"	f	class:rpa::susceptibility
printGap3	susceptibility.h	/^		void printGap3() {$/;"	f	class:rpa::susceptibility
printGroup	PartialPsimag/Symmetry/SymmetryGroup.h	/^    void printGroup(std::ostream& os) {$/;"	f	class:psimag::SymmetryGroup
printHeader	PsimagLite/scripts/pTeX.pl	/^sub printHeader$/;"	s
printInterface	PsimagLite/scripts/pTeX.pl	/^sub printInterface$/;"	s
printLine	PsimagLite/src/JSON/JSN_Writer.h	/^    void printLine(std::ostream& os,$/;"	f	class:dca::JSN
printLines	PsimagLite/src/JSON/JSN_Writer.h	/^    void printLines(std::ostream& os,$/;"	f	class:dca::JSN
printList	PartialPsimag/MatrixLike.h	/^    void printList(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
printList	PartialPsimag/VectorLike.h	/^    void printList(const VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
printList	PsimagLite/src/JSON/MatrixLike.h	/^    void printList(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
printMatrix	PsimagLite/src/IoSimple.h	/^			void printMatrix(Matrix<X> const &mat,std::string const &s)$/;"	f	class:PsimagLite::IoSimple::Out
printMatrix	PsimagLite/src/IoSimple.h	/^			void printMatrix(X const &mat,std::string const &s)$/;"	f	class:PsimagLite::IoSimple::Out
printMemoryOrder	PartialPsimag/Matrix.h	/^    void printMemoryOrder(std::ostream& os) const {$/;"	f	class:psimag::Matrix
printNames	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    static void printNames(std::ostream& out) {$/;"	f	class:psimag::SymmetryElements
printNonZero	PsimagLite/src/Matrix.h	/^	void printNonZero(const Matrix<T>& m,std::ostream& os)$/;"	f	namespace:PsimagLite
printPostQualifier	PsimagLite/scripts/functionSigIndent.pl	/^sub printPostQualifier$/;"	s
printRow	PartialPsimag/MatrixLike.h	/^    void printRow(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
printRow	PsimagLite/src/JSON/MatrixLike.h	/^    void printRow(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
printVector	PsimagLite/src/IoSimple.h	/^			void printVector(X const &x,std::string const &label)$/;"	f	class:PsimagLite::IoSimple::Out
printVector	PsimagLite/src/JSON/JSN_Writer.h	/^    void printVector(std::vector<T> vec,$/;"	f	class:dca::JSN
printWarnings	PsimagLite/scripts/indentStrict.pl	/^sub printWarnings$/;"	s
printedFirstLine	PsimagLite/src/JSON/JSN_Writer.h	/^    mutable bool printedFirstLine;$/;"	m	class:dca::JSN
printline	PsimagLite/src/IoSimple.h	/^			void printline(const std::string &s)$/;"	f	class:PsimagLite::IoSimple::Out
printline	PsimagLite/src/IoSimple.h	/^			void printline(std::ostringstream &s)$/;"	f	class:PsimagLite::IoSimple::Out
printline	PsimagLite/src/ProgressIndicator.h	/^		void printline(const std::string &s,SomeOutputType& os) const$/;"	f	class:PsimagLite::ProgressIndicator
printline	PsimagLite/src/ProgressIndicator.h	/^		void printline(std::ostringstream &s,std::ostream& os) const$/;"	f	class:PsimagLite::ProgressIndicator
procBuffer	PsimagLite/scripts/FunctionParsing.pm	/^sub procBuffer$/;"	s
procBuffer	PsimagLite/scripts/functionSigIndent.pl	/^sub procBuffer$/;"	s
procLine	PsimagLite/scripts/colorOutput.pl	/^sub procLine$/;"	s
procThisFile	PsimagLite/scripts/pTeX.pl	/^sub procThisFile$/;"	s
procThisLine	PsimagLite/scripts/pTeX.pl	/^sub procThisLine$/;"	s
progress_	PsimagLite/src/ChebyshevSerializer.h	/^		ProgressIndicator progress_;$/;"	m	class:PsimagLite::ChebyshevSerializer
progress_	PsimagLite/src/ChebyshevSolver.h	/^		ProgressIndicator progress_;$/;"	m	class:PsimagLite::ChebyshevSolver
progress_	PsimagLite/src/ContinuedFraction.h	/^		ProgressIndicator progress_;$/;"	m	class:PsimagLite::ContinuedFraction
progress_	PsimagLite/src/ContinuedFractionCollection.h	/^		ProgressIndicator progress_;$/;"	m	class:PsimagLite::ContinuedFractionCollection
progress_	PsimagLite/src/LanczosSolver.h	/^		ProgressIndicator progress_;$/;"	m	class:PsimagLite::LanczosSolver
progress_	PsimagLite/src/LanczosVectors.h	/^		ProgressIndicator progress_;$/;"	m	class:PsimagLite::LanczosVectors
psimag	PartialPsimag/BLAS.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/IndexedMatrix.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/KISS.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/LAPACK.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Matrix.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/MatrixLike.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/MatrixSlice.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/OperationClosure.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/PSIMAGAssert.h	/^namespace psimag { $/;"	n
psimag	PartialPsimag/Real.h	/^namespace  psimag {$/;"	n
psimag	PartialPsimag/RealPart.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/AbstractRat.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/BravaisType.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CartesianPosition.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CartesianRotation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CartesianTranslation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CellDirection.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CellParameters.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CellPosition.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CellRotation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CellTranslation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CeneringPointGroup.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Centering.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Centering2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ConventionalCrystal.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ConventionalLattice.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Crystal.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/CrystalBase.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/FieldConvert.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/FieldParser.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/FiniteGroup.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/FloodTiler.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ForEachCentering.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/FourFold2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/FourFoldN2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Glide2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/GroupAction.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/IdentityElement2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Lattice.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/LatticeCoordinates.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/LatticeTransformation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/LatticeTranslation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/LatticeWithPattern.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/Mat.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatCopy.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatDet.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatDifference.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatEqual.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatForEach.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatForEach2.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatForEach3.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatForEachDiagonal.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatIdentity.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatInverse.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatMagnitude.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatMax.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatMult.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatPrint.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatReduce.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatReduce2.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatReduceDiagonal.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatSum.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatTrace.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatTraits.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatTranspose.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mat/MatUtil.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/MetricTensor.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/MillerDirection.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Mirror2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/NullType.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Occupant.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/OccupantClosure.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Orbits.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/OriginLocator.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Pattern.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/PatternData.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/PatternWithLattice.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/PrimitiveCell.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Reciprocal.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ReciprocalLattice.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ReducedCrystal.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ReducedLattice.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Reducer.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/STLUtil.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SearchTable.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SeitzMatrix.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SeitzMatrixTraits.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SeitzPosition.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SeitzTranslation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SeitzVector.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Simple2DReducer.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SixFold2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SixFoldN2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SpaceGroup.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SpaceGroup2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SpaceGroupConstructor.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SpaceGroupConstructor2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Star.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SuperCrystal.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/Symmetry.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SymmetryElement.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SymmetryElementName.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SymmetryElements2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SymmetryGroup.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SymmetryOperation.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/SymmetryOperations2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/TestPattern.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ThreeFold2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/ThreeFoldN2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/TwoFold2D.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Symmetry/TypeManip.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Tag.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/TagAttributeParser.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/TagAttributes.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/ValueTypeFunction.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Vec.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/Vector.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/VectorLike.h	/^namespace psimag {$/;"	n
psimag	PartialPsimag/XMLHeading.h	/^namespace psimag {$/;"	n
psimag	PsimagLite/src/BLAS.h	/^namespace psimag {$/;"	n
psimag	PsimagLite/src/JSON/MatrixLike.h	/^namespace psimag {$/;"	n
psimag	PsimagLite/src/JSON/OperationClosure.h	/^namespace psimag {$/;"	n
psimag	PsimagLite/src/JSON/PSIMAGAssert.h	/^namespace psimag { $/;"	n
psimag	PsimagLite/src/JSON/Transposer.h	/^namespace psimag {$/;"	n
pthread_mutex_lock	PsimagLite/src/NoPthreads.h	/^void pthread_mutex_lock(int myMutex)$/;"	f
pthread_mutex_unlock	PsimagLite/src/NoPthreads.h	/^void pthread_mutex_unlock(int myMutex)$/;"	f
push	PsimagLite/src/ChebyshevSolver.h	/^		void push(TridiagonalMatrixType& ab,const RealType& a,const RealType& b) const$/;"	f	class:PsimagLite::ChebyshevSolver
push	PsimagLite/src/ContinuedFractionCollection.h	/^		void push(const ContinuedFractionType& cf)$/;"	f	class:PsimagLite::ContinuedFractionCollection
push	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    void push(ModeType mode) {$/;"	f	class:JsonParser::ModesMixin
push	PsimagLite/src/LanczosSolver.h	/^		void push(TridiagonalMatrixType& ab,const RealType& a,const RealType& b) const$/;"	f	class:PsimagLite::LanczosSolver
push	PsimagLite/src/TridiagonalMatrix.h	/^		void push(const FieldType& a,const FieldType& b)$/;"	f	class:PsimagLite::TridiagonalMatrix
pushCol	PsimagLite/src/CrsMatrix.h	/^		void pushCol(int i) { colind_.push_back(i); }$/;"	f	class:PsimagLite::CrsMatrix
pushCol	PsimagLite/src/SampleCRSMatrix.h	/^		void pushCol(int i) { colind_.push_back(i); }$/;"	f	class:PsimagLite::SampleCRSMatrix
pushValue	PsimagLite/src/CrsMatrix.h	/^		void pushValue(T const &value) { values_.push_back(value); }$/;"	f	class:PsimagLite::CrsMatrix
pushValue	PsimagLite/src/SampleCRSMatrix.h	/^		void pushValue(const T& value) { values_.push_back(value); }$/;"	f	class:PsimagLite::SampleCRSMatrix
push_back	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& push_back() {$/;"	f	class:JsonParser::Whatever
push_back	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& push_back(T& value) {$/;"	f	class:JsonParser::Whatever
push_back_null	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    Whatever& push_back_null() {$/;"	f	class:JsonParser::Whatever
put	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^    void put(wchar_t wc) {$/;"	f	class:JsonParser::ParseBuffer
pxwave	CrystalHarmonics2D.h	/^	FieldType pxwave(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
pywave	CrystalHarmonics2D.h	/^	FieldType pywave(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
qMesh	chi0.h	/^		momentumDomain<Field,psimag::Matrix,ConcurrencyType>& qMesh;$/;"	m	class:rpa::chi0q
qMesh	pairing.h	/^		momentumDomain<FieldType,psimag::Matrix,ConcurrencyType>& qMesh;$/;"	m	class:rpa::pairing
qStore	pairing.h	/^		std::vector<VectorType> qStore;$/;"	m	class:rpa::pairing
quoted	PsimagLite/src/JSON/JSN_Writer.h	/^    std::string quoted(std::string str) {$/;"	f	class:dca::JSN
quotes	PartialPsimag/TagAttributeParser.h	/^    const string     quotes;$/;"	m	class:psimag::TagAttributeParser
qxmax	parameters.h	/^		Field qxmin,qxmax,qymin,qymax,qzmin,qzmax;$/;"	m	class:rpa::parameters
qxmin	parameters.h	/^		Field qxmin,qxmax,qymin,qymax,qzmin,qzmax;$/;"	m	class:rpa::parameters
qymax	parameters.h	/^		Field qxmin,qxmax,qymin,qymax,qzmin,qzmax;$/;"	m	class:rpa::parameters
qymin	parameters.h	/^		Field qxmin,qxmax,qymin,qymax,qzmin,qzmax;$/;"	m	class:rpa::parameters
qzmax	parameters.h	/^		Field qxmin,qxmax,qymin,qymax,qzmin,qzmax;$/;"	m	class:rpa::parameters
qzmin	parameters.h	/^		Field qxmin,qxmax,qymin,qymax,qzmin,qzmax;$/;"	m	class:rpa::parameters
radians	PartialPsimag/Symmetry/CellParameters.h	/^  static Field radians(Field degrees) {$/;"	f	namespace:psimag
random	PsimagLite/src/Random48.h	/^		T random() \/\/ deprecated!!! use operator() instead$/;"	f	class:PsimagLite::Random48
randomizeVector	PsimagLite/src/Vector.h	/^	void randomizeVector(std::vector<typename RandomType::value_type>& v,const X& a,const X& b,const RandomType& r)$/;"	f	namespace:PsimagLite
rank	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    size_t rank() const { return _rank;}$/;"	f	class:psimag::HermiteNormalForm
rank	PsimagLite/src/ChebyshevSolver.h	/^			size_t rank() const { return matx_.rank(); }$/;"	f	class:PsimagLite::ChebyshevSolver::InternalMatrix
rank	PsimagLite/src/Concurrency.h	/^		int rank(int dummy= -1) { return 0; }$/;"	f	class:PsimagLite::Concurrency
rank	PsimagLite/src/ConcurrencyMpi.h	/^		int rank(CommType mpiComm=COMM_WORLD) $/;"	f	class:PsimagLite::ConcurrencyMpi
rank	PsimagLite/src/ConcurrencySerial.h	/^		int rank(CommType comm1=COMM_WORLD) { return 0; }$/;"	f	class:PsimagLite::ConcurrencySerial
rank	PsimagLite/src/CrsMatrix.h	/^		size_t rank() const { return size_; }$/;"	f	class:PsimagLite::CrsMatrix
rank	PsimagLite/src/IoSimple.h	/^			int rank() { return rank_; }$/;"	f	class:PsimagLite::IoSimple::Out
rank	PsimagLite/src/SampleCRSMatrix.h	/^		size_t rank() const { return rank_; }$/;"	f	class:PsimagLite::SampleCRSMatrix
rank_	PsimagLite/src/IoSimple.h	/^			int rank_;$/;"	m	class:PsimagLite::IoSimple::Out
rank_	PsimagLite/src/ProgressIndicator.h	/^		size_t rank_;$/;"	m	class:PsimagLite::ProgressIndicator
rank_	PsimagLite/src/SampleCRSMatrix.h	/^		size_t rank_;$/;"	m	class:PsimagLite::SampleCRSMatrix
rating	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    Field                                   rating; $/;"	m	class:psimag::SpaceGroup
rational	PartialPsimag/Symmetry/rational.h	/^  rational<Int>() {num=Int(0); den=Int(1);}$/;"	f	class:rational
rational	PartialPsimag/Symmetry/rational.h	/^  rational<Int>(Int u) {num=u; den=Int(1);}$/;"	f	class:rational
rational	PartialPsimag/Symmetry/rational.h	/^  rational<Int>(Int u, Int v) {setValue(u,v);}$/;"	f	class:rational
rational	PartialPsimag/Symmetry/rational.h	/^  rational<Int>(const double val) {$/;"	f	class:rational
rational	PartialPsimag/Symmetry/rational.h	/^  rational<Int>(const rational<Int> &a){num=a.num; den=a.den;}$/;"	f	class:rational
rational	PartialPsimag/Symmetry/rational.h	/^  rational<Int>(psimag::AbstractRat<long>& abstractRat)$/;"	f	class:rational
rational	PartialPsimag/Symmetry/rational.h	/^template<class Int> class rational$/;"	c
read	PsimagLite/src/IoSimple.h	/^				std::pair<std::string,size_t> read($/;"	f	class:PsimagLite::IoSimple::In
read	PsimagLite/src/IoSimple.h	/^				void read($/;"	f	class:PsimagLite::IoSimple::In
readCSVFile	bands.h	/^		void readCSVFile() {$/;"	f	class:rpa::Bands
readCSVFile	tbFromFile.h	/^		void readCSVFile() {$/;"	f	class:rpa::model
readChi	parameters.h	/^		size_t readChi;$/;"	m	class:rpa::parameters
readChi0Emery	susceptibility.h	/^		void readChi0Emery (std::vector<std::vector<FieldType> >& qField, $/;"	f	class:rpa::susceptibility
readChiForSus	parameters.h	/^		size_t readChiForSus;$/;"	m	class:rpa::parameters
readChi_	pairing.h	/^		size_t readChi_;$/;"	m	class:rpa::pairing
readChiqTxt	chi0.h	/^		void readChiqTxt(const std::string& file,momentumDomain<Field,psimag::Matrix,ConcurrencyType>& qMesh) {$/;"	f	class:rpa::chi0q
readChiqTxt2	chi0.h	/^	void readChiqTxt2(std::vector<std::vector<FieldType> >& qField,$/;"	f	namespace:rpa
readFSFromFile	parameters.h	/^		bool readFSFromFile;$/;"	m	class:rpa::parameters
readFile	PsimagLite/scripts/pTeX.pl	/^sub readFile$/;"	s
readFileVerbatim	PsimagLite/scripts/pTeX.pl	/^sub readFileVerbatim$/;"	s
readFromFile	ferminator.h	/^	void readFromFile() {$/;"	f	class:rpa::ferminator
readFromFile2	ferminator.h	/^	void readFromFile2() {$/;"	f	class:rpa::ferminator
readFromInputFile	parameters.h	/^			void readFromInputFile(const std::string& file) {$/;"	f	class:rpa::parameters
readKnownSize	PsimagLite/src/IoSimple.h	/^				std::pair<std::string,size_t> readKnownSize($/;"	f	class:PsimagLite::IoSimple::In
readMatrix	PsimagLite/src/IoSimple.h	/^				void readMatrix($/;"	f	class:PsimagLite::IoSimple::In
readSparseVector	PsimagLite/src/IoSimple.h	/^				void readSparseVector($/;"	f	class:PsimagLite::IoSimple::In
readTwoColumnData	PsimagLite/drivers/akimaSpline.cpp	/^void readTwoColumnData(const std::string& file,VectorType& v0,VectorType& v1)$/;"	f
readVector	PsimagLite/src/SampleCRSMatrix.h	/^		void readVector(SomeIoInputType& io,std::vector<SomeFieldType>& v) const$/;"	f	class:PsimagLite::SampleCRSMatrix
readline	PsimagLite/src/IoSimple.h	/^				size_t readline($/;"	f	class:PsimagLite::IoSimple::In
real	PsimagLite/src/Complex.h	/^	double real(double t) { return t; }$/;"	f	namespace:std
reciprocalCrystal	PartialPsimag/Symmetry/SuperCrystal.h	/^    CrystalType                    reciprocalCrystal;             \/**  The 'reciprocal' crystal. *\/$/;"	m	class:psimag::SuperCrystal
reciprocalCrystalLattice	PartialPsimag/Symmetry/SuperCrystal.h	/^    LatticeType                    reciprocalCrystalLattice;      \/**  The reciprocal lattice of the crystal that this is a SuperCrystal of. *\/$/;"	m	class:psimag::SuperCrystal
reciprocalCrystalPattern	PartialPsimag/Symmetry/SuperCrystal.h	/^    LatticeWithPatternType         reciprocalCrystalPattern;      \/**  The superCrystal generated pattern for the 'reciprocal' crystal. *\/$/;"	m	class:psimag::SuperCrystal
reciprocalSet	PartialPsimag/Symmetry/Lattice.h	/^    bool                        reciprocalSet; \/\/ Should init to false.$/;"	m	class:psimag::Lattice
reciprocalSuperCrystal	PartialPsimag/Symmetry/SuperCrystal.h	/^    BaseType                       reciprocalSuperCrystal;        \/**  The reciprocal of this SuperCrystal. *\/$/;"	m	class:psimag::SuperCrystal
reciprocalSuperCrystalLattice	PartialPsimag/Symmetry/SuperCrystal.h	/^    LatticeType                    reciprocalSuperCrystalLattice; \/**  The reciprocal lattice of this SuperCrystal's lattice. *\/$/;"	m	class:psimag::SuperCrystal
reciprocalSuperCrystalPattern	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    PatternType             reciprocalSuperCrystalPattern; $/;"	m	class:psimag::SuperCrystalBuilder
reciprocate	PartialPsimag/Symmetry/Reciprocal.h	/^  LatticeTemplate2<Field,2,Algorithms> reciprocate(const LatticeTemplate1<Field,2,Algorithms>& givenLattice) {$/;"	f	namespace:psimag
reduce	PartialPsimag/Symmetry/Reducer.h	/^    static ReducedCell reduce(Lattice& lattice) {$/;"	f	class:psimag::Reducer
reduce	PartialPsimag/Symmetry/Simple2DReducer.h	/^    static void reduce(ReducedCrystalType& reduced) {$/;"	f	class:psimag::Simple2DReducer
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(PsimagLite::Matrix<double>& m,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(double& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(int& i,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(psimag::Matrix<double>& m,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(psimag::Matrix<std::complex<double> >& m,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(std::vector<double>& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(std::vector<psimag::Matrix<std::complex<double> > >& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencyMpi.h	/^		void reduce(std::vector<std::complex<double> >& v,CommType mpiComm=COMM_WORLD)$/;"	f	class:PsimagLite::ConcurrencyMpi
reduce	PsimagLite/src/ConcurrencySerial.h	/^		void reduce(DataType& v,CommType mpiComm=COMM_WORLD) {}$/;"	f	class:PsimagLite::ConcurrencySerial
reduceDiagonal	PartialPsimag/Symmetry/ReducedLattice.h	/^    bool reduceDiagonal(size_t bi, size_t bj) {$/;"	f	class:psimag::ReducedLattice
reducedCrystal	PartialPsimag/Symmetry/Crystal.h	/^    ReducedCrystalType      reducedCrystal; $/;"	m	class:psimag::Crystal
refCounter_	PsimagLite/src/Geometry/GeometryFactory.h	/^		static size_t refCounter_;$/;"	m	class:PsimagLite::GeometryFactory
refCounter_	PsimagLite/src/Geometry/GeometryFactory.h	/^	size_t GeometryFactory::refCounter_=0;$/;"	m	class:PsimagLite::GeometryFactory
reference	PartialPsimag/Matrix.h	/^    typedef T&           reference;$/;"	t	class:psimag::Matrix
referenceLattice	PartialPsimag/Symmetry/PatternWithLattice.h	/^    const LatticeType&           referenceLattice;$/;"	m	class:psimag::PatternWithLattice
referencedObject	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    Whatever& referencedObject() {$/;"	f	class:JsonParser::DefaultContext
remainingChars	PartialPsimag/TagAttributeParser.h	/^    string::size_type remainingChars() {$/;"	f	class:psimag::TagAttributeParser
removeTrailingDirs	PsimagLite/scripts/pTeX.pl	/^sub removeTrailingDirs$/;"	s
replaceMacros	PsimagLite/scripts/pTeX.pl	/^sub replaceMacros$/;"	s
rescale	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void rescale(Field newFactor) {$/;"	f	class:psimag::BackSubstitution
reset	PsimagLite/src/LanczosVectors.h	/^		void reset(size_t matrixRank,size_t steps)$/;"	f	class:PsimagLite::LanczosVectors
reset	PsimagLite/src/Matrix.h	/^		void reset(size_t nrow,size_t ncol)$/;"	f	class:PsimagLite::Matrix
resize	PartialPsimag/Matrix.h	/^    void resize(size_type m,size_type n,size_type ldim=0) {$/;"	f	class:psimag::Matrix
resize	PsimagLite/src/CrsMatrix.h	/^		void resize(int nsize)$/;"	f	class:PsimagLite::CrsMatrix
resize	PsimagLite/src/CrsMatrix.h	/^		void resize(int nsize,int nonzero) $/;"	f	class:PsimagLite::CrsMatrix
resize	PsimagLite/src/JSON/Transposer.h	/^    void resize(size_t nRow, size_t nCol) {$/;"	f	class:psimag::Transposed
resize	PsimagLite/src/JSON/Transposer.h	/^    void resize(size_t nRow, size_t nCol) {$/;"	f	class:psimag::Transposer
resize	PsimagLite/src/LanczosVectors.h	/^		void resize(size_t matrixRank,size_t steps)$/;"	f	class:PsimagLite::LanczosVectors
resize	PsimagLite/src/Matrix.h	/^		void resize(size_t nrow,size_t ncol)$/;"	f	class:PsimagLite::Matrix
resize	PsimagLite/src/TridiagonalMatrix.h	/^		void resize(size_t n)$/;"	f	class:PsimagLite::TridiagonalMatrix
resize	PsimagLite/src/TridiagonalMatrix.h	/^		void resize(size_t n,FieldType value)$/;"	f	class:PsimagLite::TridiagonalMatrix
resizeContainers	ferminator.h	/^	void resizeContainers() {$/;"	f	class:rpa::ferminator
result	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    Whatever                  result;$/;"	m	class:JsonParser::DefaultContext
result	PythonScripts/test.py	/^result = multiprocessing.Array('i', 4) $/;"	v
result_type	PartialPsimag/KISS.h	/^    typedef Real   result_type;$/;"	t	class:psimag::KISS
rewind	PsimagLite/src/IoSimple.h	/^				void rewind()$/;"	f	class:PsimagLite::IoSimple::In
rewriteSig	PsimagLite/scripts/functionSigIndent.pl	/^sub rewriteSig$/;"	s
rhs	PartialPsimag/OperationClosure.h	/^    const Operand2Type& rhs;$/;"	m	class:psimag::OperationClosure
rhs	PsimagLite/src/JSON/OperationClosure.h	/^    const Operand2Type& rhs;$/;"	m	class:psimag::OperationClosure
rng_	PsimagLite/src/ChebyshevSolver.h	/^		RngType rng_;$/;"	m	class:PsimagLite::ChebyshevSolver
rng_	PsimagLite/src/LanczosSolver.h	/^		PsimagLite::Random48<RealType> rng_;$/;"	m	class:PsimagLite::LanczosSolver
root	PsimagLite/src/ConcurrencyMpi.h	/^		bool root(CommType mpiComm=COMM_WORLD) $/;"	f	class:PsimagLite::ConcurrencyMpi
root	PsimagLite/src/ConcurrencySerial.h	/^		bool root(CommType commm1=COMM_WORLD) { return true; }$/;"	f	class:PsimagLite::ConcurrencySerial
rotation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    RotationType             rotation;$/;"	m	class:psimag::SeitzMatrix
rotationAngle	PartialPsimag/Symmetry/SymmetryElement.h	/^    Field                   rotationAngle;$/;"	m	class:psimag::SymmetryElement
rowIndices	PartialPsimag/IndexedMatrix.h	/^    IndexType                   rowIndices;$/;"	m	class:psimag::IndexedMatrix
rowptr_	PsimagLite/src/CrsMatrix.h	/^		std::vector<int> rowptr_;$/;"	m	class:PsimagLite::CrsMatrix
rowptr_	PsimagLite/src/SampleCRSMatrix.h	/^		std::vector<size_t> rowptr_;$/;"	m	class:PsimagLite::SampleCRSMatrix
rpa	1band_wSpin.h	/^namespace rpa {$/;"	n
rpa	4Orbital.h	/^namespace rpa {$/;"	n
rpa	BSCCObilayer.h	/^namespace rpa {$/;"	n
rpa	BaFeAs_5orb.h	/^namespace rpa {$/;"	n
rpa	CrystalHarmonics.h	/^namespace rpa {$/;"	n
rpa	CrystalHarmonics2D.h	/^namespace rpa {$/;"	n
rpa	FourOrbital.h	/^namespace rpa {$/;"	n
rpa	KFe2Se2.h	/^namespace rpa {$/;"	n
rpa	PartialPsimag/Symmetry/PsimagGeometry.h	/^namespace rpa {$/;"	n
rpa	PartialPsimag/Symmetry/fetchGeometry1D.h	/^namespace rpa {$/;"	n
rpa	PartialPsimag/Symmetry/fetchGeometry2D.h	/^namespace rpa {$/;"	n
rpa	PartialPsimag/Symmetry/fetchMesh.h	/^namespace rpa {$/;"	n
rpa	PartialPsimag/Symmetry/fetchMeshWignerSeitz.h	/^namespace rpa {$/;"	n
rpa	SrRuO.h	/^namespace rpa {$/;"	n
rpa	SrRuO_SO.h	/^namespace rpa {$/;"	n
rpa	bands.h	/^namespace rpa {$/;"	n
rpa	bandstructure.h	/^namespace rpa {$/;"	n
rpa	bilayer.h	/^namespace rpa {$/;"	n
rpa	bilayerFESC.h	/^namespace rpa {$/;"	n
rpa	chi0.h	/^namespace rpa {$/;"	n
rpa	chi0Ofq.h	/^namespace rpa {$/;"	n
rpa	coupledLadders.h	/^namespace rpa {$/;"	n
rpa	ferminator.h	/^namespace rpa {$/;"	n
rpa	gap.h	/^namespace rpa {$/;"	n
rpa	gaps2D.h	/^namespace rpa {$/;"	n
rpa	gaps3D.h	/^namespace rpa {$/;"	n
rpa	greensFunction.h	/^namespace rpa {$/;"	n
rpa	interpolation.h	/^namespace rpa{$/;"	n
rpa	momentumDomain.h	/^namespace rpa {$/;"	n
rpa	orthoIIBilayer.h	/^namespace rpa {$/;"	n
rpa	pairing.h	/^namespace rpa {$/;"	n
rpa	parameters.h	/^namespace rpa {$/;"	n
rpa	rpa.h	/^namespace rpa {$/;"	n
rpa	rpa_CuO.h	/^namespace rpa {$/;"	n
rpa	sepBasis.h	/^namespace rpa {$/;"	n
rpa	singleBand.h	/^namespace rpa {$/;"	n
rpa	susInt.h	/^namespace rpa {$/;"	n
rpa	susceptibility.h	/^namespace rpa {$/;"	n
rpa	tbFromFile.h	/^namespace rpa {$/;"	n
rsqrt	PartialPsimag/Symmetry/AbstractRat.h	/^  Rat rsqrt(int sq) {$/;"	f	namespace:psimag
rsqrt_2	PartialPsimag/Symmetry/AbstractRat.h	/^  Rat rsqrt_2(int sq) {$/;"	f	namespace:psimag
rusage_	PsimagLite/src/Rusage.h	/^		struct rusage rusage_;$/;"	m	class:PsimagLite::Rusage	typeref:struct:PsimagLite::Rusage::rusage
sameColumn	PsimagLite/src/Geometry/Ladder.h	/^		bool sameColumn(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Ladder
sameRow	PsimagLite/src/Geometry/Ladder.h	/^		bool sameRow(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::Ladder
sameType	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool sameType   = false;$/;"	m	struct:psimag::Conversion
sameType	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool sameType   = true;$/;"	m	class:psimag::Conversion
sameType	PartialPsimag/Symmetry/TypeManip.h	/^        static const bool sameType   = true;$/;"	m	struct:psimag::Conversion
satisfies	PartialPsimag/Symmetry/LatticeWithPattern.h	/^    bool satisfies(const SymmetryOperationType&  symmetryOperation) {$/;"	f	class:psimag::LatticeWithPattern
satisfies	PartialPsimag/Symmetry/OriginLocator.h	/^    bool satisfies(const SymmetryOperationType&  symmetryOperation) {$/;"	f	class:psimag::OriginLocator
satisfies	PartialPsimag/Symmetry/PatternWithLattice.h	/^    bool satisfies(const SymmetryOperationType&  symmetryOperation) {$/;"	f	class:psimag::PatternWithLattice
save	PartialPsimag/Matrix.h	/^    void save(std::string directory, int number)$/;"	f	class:psimag::Matrix
save	PsimagLite/src/ChebyshevSerializer.h	/^		void save(IoOutputType& io) const$/;"	f	class:PsimagLite::ChebyshevSerializer
save	PsimagLite/src/ContinuedFraction.h	/^		void save(IoOutputType& io) const$/;"	f	class:PsimagLite::ContinuedFraction
save	PsimagLite/src/ContinuedFractionCollection.h	/^		void save(IoOutputType& io) const$/;"	f	class:PsimagLite::ContinuedFractionCollection
save	PsimagLite/src/LineMarker.h	/^		void save(IoOutputType& io) const$/;"	f	class:PsimagLite::LineMarker
save	PsimagLite/src/SampleCRSMatrix.h	/^		void save(SomeIoOutputType& io) const$/;"	f	class:PsimagLite::SampleCRSMatrix
save	PsimagLite/src/TridiagonalMatrix.h	/^		void save(IoOutputType& io) const$/;"	f	class:PsimagLite::TridiagonalMatrix
saveObj	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def saveObj(self,dirname=""):$/;"	m	class:RPA
saveVector	PsimagLite/src/SampleCRSMatrix.h	/^		void saveVector(SomeIoOutputType& io,const std::vector<SomeFieldType>& v) const$/;"	f	class:PsimagLite::SampleCRSMatrix
scState	parameters.h	/^		size_t scState;$/;"	m	class:rpa::parameters
scalarProd	momentumDomain.h	/^		FieldType scalarProd(const VectorType& a, const VectorType& b) const {$/;"	f	class:rpa::momentumDomain
scalarProduct	PartialPsimag/MatrixLike.h	/^    typename VectorLikeType2::value_type scalarProduct(const VectorLikeType1& v1,$/;"	f	namespace:psimag::MatrixLike
scalarProduct	PartialPsimag/VectorLike.h	/^    typename VectorLikeType2::value_type scalarProduct(const VectorLikeType1& v1,$/;"	f	namespace:psimag::VectorLike
scalarProduct	PsimagLite/src/JSON/MatrixLike.h	/^    typename VectorLikeType2::value_type scalarProduct(const VectorLikeType1& v1,$/;"	f	namespace:psimag::MatrixLike
scaleFactor	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    Field                        scaleFactor;$/;"	m	class:psimag::BackSubstitution
scaled_integer_solution	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    bool scaled_integer_solution;$/;"	m	class:psimag::BackSubstitution
searchFlatMapFor	PsimagLite/src/JSON/JsonReader.h	/^    const JsonAccessor& searchFlatMapFor(const std::string key) const {$/;"	f	class:dca::JsonReader
searchFor	PsimagLite/src/JSON/JsonReader.h	/^    const JsonAccessor& searchFor(const std::string key) const {$/;"	f	class:dca::JsonReader
searchFor	PsimagLite/src/JSON/JsonReader.h	/^    const JsonAccessor& searchFor(const std::string key1,$/;"	f	class:dca::JsonReader
seed	PartialPsimag/KISS.h	/^    void seed(seed_type s) $/;"	f	class:psimag::KISS
seed_type	PartialPsimag/KISS.h	/^    typedef unsigned int seed_type; $/;"	t	class:psimag::KISS
seed_type	PartialPsimag/KISS.h	/^    typedef unsigned long int seed_type;  $/;"	t	class:psimag::KISS
seitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,2> seitzPosition(Field x, Field y) {$/;"	f	namespace:psimag
seitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,2> seitzPosition(IN_TYPE t0, IN_TYPE t1) {$/;"	f	namespace:psimag
seitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,3> seitzPosition(Field x, Field y, Field z) {$/;"	f	namespace:psimag
seitzPosition	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,3> seitzPosition(IN_TYPE t0, IN_TYPE t1, IN_TYPE t2) {$/;"	f	namespace:psimag
seitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^  SeitzTranslation<Field,2> seitzTranslation(Field x, Field y) {$/;"	f	namespace:psimag
seitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^  SeitzTranslation<Field,2> seitzTranslation(IN_TYPE t0, IN_TYPE t1) {$/;"	f	namespace:psimag
seitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^  SeitzTranslation<Field,3> seitzTranslation(Field x, Field y, Field z) {$/;"	f	namespace:psimag
seitzTranslation	PartialPsimag/Symmetry/SeitzTranslation.h	/^  SeitzTranslation<Field,3> seitzTranslation(IN_TYPE t0, IN_TYPE t1, IN_TYPE t2) {$/;"	f	namespace:psimag
selectSpaceGroup	PartialPsimag/Symmetry/Symmetry.h	/^    void selectSpaceGroup() {$/;"	f	class:psimag::Symmetry
selected	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    bool                                    selected;$/;"	m	class:psimag::SpaceGroup
selectedSpaceGroupIndex	PartialPsimag/Symmetry/Symmetry.h	/^    size_t                      selectedSpaceGroupIndex;$/;"	m	class:psimag::Symmetry
sense	PartialPsimag/Symmetry/SymmetryElement.h	/^    int                     sense;$/;"	m	class:psimag::SymmetryElement
sense	PartialPsimag/Symmetry/SymmetryOperation.h	/^    int sense(const SeitzPositionType& fixedPoint,$/;"	f	class:psimag::SymmetryOperation
sepBasis	sepBasis.h	/^		sepBasis(const rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters, $/;"	f	class:rpa::sepBasis
sepBasis	sepBasis.h	/^	class sepBasis {$/;"	c	namespace:rpa
set	PartialPsimag/Symmetry/Pattern.h	/^    void set(size_t posIndex, size_t occupantIndex, const CellPositionType& cellPos) { $/;"	f	class:psimag::Pattern
set	PsimagLite/src/ContinuedFraction.h	/^		void set($/;"	f	class:PsimagLite::ContinuedFraction
set	PsimagLite/src/CrsMatrix.h	/^		void set(const std::vector<int> &rowptr,const std::vector<int>& colind,const std::vector<T>& values)$/;"	f	class:PsimagLite::CrsMatrix
set	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    void set(const T& v) {$/;"	f	class:JsonParser::DefaultContext
set	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void set(bool value) {$/;"	f	class:JsonParser::Whatever
set	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void set(const std::wstring& value) {$/;"	f	class:JsonParser::Whatever
set	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void set(double value) {$/;"	f	class:JsonParser::Whatever
set	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void set(int value) {$/;"	f	class:JsonParser::Whatever
setAmplitudes	gap.h	/^		void setAmplitudes() {$/;"	f	class:rpa::gap
setAppliedSymmetryElements	PartialPsimag/Symmetry/Symmetry.h	/^    void setAppliedSymmetryElements() {$/;"	f	class:psimag::Symmetry
setAppliedSymmetryElements	PartialPsimag/Symmetry/Symmetry.h	/^    void setAppliedSymmetryElements(const InverseLatticeTransformation<Field,DIM>&          transform, $/;"	f	class:psimag::Symmetry
setCanonicalPositionAndNetDirection	PartialPsimag/Symmetry/SymmetryOperation.h	/^  void setCanonicalPositionAndNetDirection(SymmetryElement<Field,2,Algorithms>&        element,$/;"	f	namespace:psimag
setCartesianSites	PartialPsimag/Symmetry/Pattern.h	/^    void setCartesianSites(Matrix<Field>& sites) const {$/;"	f	class:psimag::Pattern
setCol	PsimagLite/src/CrsMatrix.h	/^		void setCol(int n,int v) {$/;"	f	class:PsimagLite::CrsMatrix
setCommentState	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    void setCommentState() {$/;"	f	class:JsonParser::JsonParser
setDet	PartialPsimag/Symmetry/Lattice.h	/^    void setDet() {$/;"	f	class:psimag::Lattice
setDirComponent	PartialPsimag/Symmetry/SymmetryElementName.h	/^    void setDirComponent(std::ostream& buff, $/;"	f	class:psimag::SymmetryElementName
setDirectionPart	PartialPsimag/Symmetry/SymmetryElementName.h	/^    void setDirectionPart(std::ostream& buff, $/;"	f	class:psimag::SymmetryElementName
setFSValues	ferminator.h	/^	void setFSValues() {$/;"	f	class:rpa::ferminator
setFixedPoint	PartialPsimag/Symmetry/SymmetryOperation.h	/^    void setFixedPoint(const SeitzPositionType& pos) {$/;"	f	class:psimag::SymmetryOperation
setGlideFraction	PartialPsimag/Symmetry/SymmetryElement.h	/^    void setGlideFraction() {$/;"	f	class:psimag::SymmetryElement
setLowerTriangle	chi0.h	/^		void setLowerTriangle() {$/;"	f	class:rpa::susc
setMirrorElements	PartialPsimag/Symmetry/SymmetryOperation.h	/^  void setMirrorElements(SymmetryElement<Field,2,Algorithms>&  element,$/;"	f	namespace:psimag
setMode	PsimagLite/src/ChebyshevSolver.h	/^		void setMode(const std::string& options)$/;"	f	class:PsimagLite::ChebyshevSolver
setMode	PsimagLite/src/LanczosSolver.h	/^		void setMode(const std::string& options)$/;"	f	class:PsimagLite::LanczosSolver
setNull	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    void setNull () {$/;"	f	class:JsonParser::Whatever
setNumOccupants	PartialPsimag/Symmetry/Pattern.h	/^    void setNumOccupants(size_t numOccupants) {$/;"	f	class:psimag::Pattern
setNumPos	PartialPsimag/Symmetry/Pattern.h	/^    void setNumPos(size_t numpos) {$/;"	f	class:psimag::Pattern
setParamBasedOnText	parameters.h	/^			void setParamBasedOnText(std::string& text, std::stringstream& str) {$/;"	f	class:rpa::parameters
setParams2D	gaps2D.h	/^		void setParams2D() {$/;"	f	class:rpa::gap2D
setParams3D	gaps3D.h	/^        void setParams3D() {$/;"	f	class:rpa::gap3D
setPositionPart	PartialPsimag/Symmetry/SymmetryElementName.h	/^    void setPositionPart(std::ostream& buff, $/;"	f	class:psimag::SymmetryElementName
setRotationElements	PartialPsimag/Symmetry/SymmetryOperation.h	/^  void setRotationElements(SymmetryElement<Field,2,Algorithms>&         element,$/;"	f	namespace:psimag
setRow	PsimagLite/src/CrsMatrix.h	/^		void setRow(int n,int v) $/;"	f	class:PsimagLite::CrsMatrix
setRow	PsimagLite/src/SampleCRSMatrix.h	/^		void setRow(int n,int v)$/;"	f	class:PsimagLite::SampleCRSMatrix
setTerm	PartialPsimag/Symmetry/AbstractRat.h	/^    void setTerm(const int prime, const std::pair<IntType, IntType>& intPair) {$/;"	f	class:psimag::AbstractRat
setThreads	PsimagLite/src/NoPthreads.h	/^			static void setThreads(size_t dummy) { } \/\/ dummy$/;"	f	class:PsimagLite::NoPthreads
setThreads	PsimagLite/src/Pthreads.h	/^			static void setThreads(size_t nthreads) {nthreads_=nthreads; }$/;"	f	class:PsimagLite::Pthreads
setToIdentity	PartialPsimag/Symmetry/CartesianRotation.h	/^    void setToIdentity() {$/;"	f	class:psimag::CartesianRotation
setToInversion	PartialPsimag/Symmetry/SymmetryOperation.h	/^    void setToInversion() {$/;"	f	class:psimag::SymmetryOperation
setTranslation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void setTranslation(const IN_TYPE values[DIM]) {$/;"	f	class:psimag::SeitzMatrix
setTranslation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void setTranslation(const SeitzVector<IN_TYPE, DIM, 0, TraitsTemplate<IN_TYPE, DIM+1, 1> >& t) {$/;"	f	class:psimag::SeitzMatrix
setTranslation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void setTranslation(const Vec<IN_TYPE, DIM> t) {$/;"	f	class:psimag::SeitzMatrix
setTranslation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void setTranslation(const VecTemplate<IN_TYPE, DIM, TraitsTemplate<IN_TYPE, DIM,1> >& t) {$/;"	f	class:psimag::SeitzMatrix
setTranslationValue	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void setTranslationValue(const IN_TYPE& value) {$/;"	f	class:psimag::SeitzMatrix
setValue	PartialPsimag/Symmetry/rational.h	/^  void setValue(Int u, Int v) {$/;"	f	class:rational
setValues	PsimagLite/src/CrsMatrix.h	/^		void setValues(int n,const T &v) {$/;"	f	class:PsimagLite::CrsMatrix
setVectorFromCol	PartialPsimag/MatrixLike.h	/^    VectorLikeType& setVectorFromCol(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
setVectorFromCol	PsimagLite/src/JSON/MatrixLike.h	/^    VectorLikeType& setVectorFromCol(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
setVectorFromRow	PartialPsimag/MatrixLike.h	/^    VectorLikeType& setVectorFromRow(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
setVectorFromRow	PsimagLite/src/JSON/MatrixLike.h	/^    VectorLikeType& setVectorFromRow(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
setVectors	PsimagLite/drivers/concurrencyTest.cpp	/^void setVectors(std::vector<VectorType>& vec, size_t total1, size_t total2)$/;"	f
set_indexOfAdd	momentumDomain.h	/^		void set_indexOfAdd() {$/;"	f	class:rpa::momentumDomain
set_momenta	momentumDomain.h	/^		void set_momenta(const Field& kxmin, const Field& kxmax, $/;"	f	class:rpa::momentumDomain
set_momenta	momentumDomain.h	/^		void set_momenta(const bool& indexation) {$/;"	f	class:rpa::momentumDomain
set_momenta_FS	momentumDomain.h	/^		void set_momenta_FS(const VectorType& shift) {$/;"	f	class:rpa::momentumDomain
set_momenta_Path1	momentumDomain.h	/^		void set_momenta_Path1() {$/;"	f	class:rpa::momentumDomain
set_momenta_Path2	momentumDomain.h	/^		void set_momenta_Path2() { \/\/ Gamma -> X -> M -> Gamma$/;"	f	class:rpa::momentumDomain
set_primitiveVectors	momentumDomain.h	/^		void set_primitiveVectors() {$/;"	f	class:rpa::momentumDomain
set_sol	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void set_sol(size_t  r, size_t  pivotC) {$/;"	f	class:psimag::BackSubstitution
setupDirectMatrix	rpa_CuO.h	/^		void setupDirectMatrix(std::vector<Field>& q) {$/;"	f	class:rpa::interactionEmery
setupExchangeMatrix	rpa_CuO.h	/^		void setupExchangeMatrix() {$/;"	f	class:rpa::interactionEmery
setupGMatrix	sepBasis.h	/^		void setupGMatrix() {$/;"	f	class:rpa::sepBasis
setupInteractionMatrix	1band_wSpin.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::SingleBand_wSpin
setupInteractionMatrix	BSCCObilayer.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupInteractionMatrix	SrRuO_SO.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupInteractionMatrix	bilayer.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupInteractionMatrix	bilayerFESC.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupInteractionMatrix	coupledLadders.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupInteractionMatrix	orthoIIBilayer.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupInteractionMatrix	singleBand.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupInteractionMatrix	tbFromFile.h	/^		void setupInteractionMatrix() {$/;"	f	class:rpa::model
setupLMatrix	tbFromFile.h	/^		void setupLMatrix() {$/;"	f	class:rpa::model
setupMomentumTables	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def setupMomentumTables(self):$/;"	m	class:RPA
setupMomentumTables	PythonScripts/Sr2RuO4.py	/^        def setupMomentumTables(self):$/;"	m	class:RPA
setupOrbitalIndices	parameters.h	/^			void setupOrbitalIndices(){$/;"	f	class:rpa::parameters
setupQandOmegaMesh	susceptibility.h	/^		void setupQandOmegaMesh(size_t nq1, size_t nq2, size_t nq3, $/;"	f	class:rpa::susceptibility
setupVBare	rpa_CuO.h	/^		void setupVBare(std::vector<Field>& q) {$/;"	f	class:rpa::interactionEmery
setup_kgrid	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^	def setup_kgrid(self):$/;"	m	class:RPA
setup_kgrid	PythonScripts/Sr2RuO4.py	/^        def setup_kgrid(self):$/;"	m	class:RPA
sharedMemory	PsimagLite/src/Rusage.h	/^		long sharedMemory() const { return rusage_.ru_ixrss; }$/;"	f	class:PsimagLite::Rusage
shared_array1	PythonScripts/Sr2RuO4.py	/^        shared_array1 = sharedctypes.RawArray(ek._type_,ek)$/;"	v	class:RPA
shared_array2	PythonScripts/Sr2RuO4.py	/^        shared_array2 = sharedctypes.RawArray(akRe._type_,akRe)$/;"	v	class:RPA
shared_array3	PythonScripts/Sr2RuO4.py	/^        shared_array3 = sharedctypes.RawArray(akIm._type_,akIm)$/;"	v	class:RPA
sharedctypes	PythonScripts/Sr2RuO4.py	/^from multiprocessing import sharedctypes$/;"	i
shift	momentumDomain.h	/^		VectorType shift;$/;"	m	class:rpa::momentumDomain
shiftPattern	PartialPsimag/Symmetry/Pattern.h	/^    void shiftPattern(const CartesianTranslationType&  originShift) {$/;"	f	class:psimag::Pattern
shortestDiagonalFactor	PartialPsimag/Symmetry/ReducedLattice.h	/^    size_t shortestDiagonalFactor(size_t b1i, size_t b2i) {$/;"	f	class:psimag::ReducedLattice
sign	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  static int sign(const Field v) { $/;"	f	class:psimag::BasicCrystalAlgorithms
signChange	PsimagLite/src/Geometry/GeometryFactory.h	/^		int signChange(size_t i1, size_t i2) const$/;"	f	class:PsimagLite::GeometryFactory
signChange	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		int signChange(size_t i1,size_t i2) const$/;"	f	class:PsimagLite::KTwoNiFFour
signChange_	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		int signChange_;$/;"	m	class:PsimagLite::KTwoNiFFour
signF	parameters.h	/^		Field signF; \/\/ sign of FF term in BCS chi0 calculation$/;"	m	class:rpa::parameters
signalsReceived	PsimagLite/src/Rusage.h	/^		long signalsReceived() const { return rusage_.ru_nsignals; }$/;"	f	class:PsimagLite::Rusage
simplex	PsimagLite/src/Minimizer.h	/^		int simplex(VectorType& minVector,RealType delta=1e-3,RealType tolerance=1e-3)$/;"	f	class:PsimagLite::Minimizer
sinTheta	PartialPsimag/Symmetry/SymmetryOperation.h	/^    Field sinTheta(const SeitzPositionType&        fixedPoint,$/;"	f	class:psimag::SymmetryOperation
sin_alpha	PartialPsimag/Symmetry/CellParameters.h	/^    Field sin_alpha;  \/**< sin(alpha) **\/$/;"	m	class:psimag::CellParameters
sin_beta	PartialPsimag/Symmetry/CellParameters.h	/^    Field sin_beta;   \/**< sin(beta) **\/$/;"	m	class:psimag::CellParameters
sin_gamma	PartialPsimag/Symmetry/CellParameters.h	/^    Field sin_gamma;  \/**< sin(gamma) **\/$/;"	m	class:psimag::CellParameters
sixfold	PartialPsimag/Symmetry/CellRotation.h	/^		   twofold=2, threefold=3,  fourfold=4, sixfold=6 } RotationType;$/;"	e	enum:psimag::CellRotation::__anon62
sixfoldInv	PartialPsimag/Symmetry/CellRotation.h	/^    typedef enum { sixfoldInv=-6, fourfoldInv=-4, threefoldInv=-3, twofoldInv=-2, inversion=-1, identity=1, $/;"	e	enum:psimag::CellRotation::__anon62
size	PartialPsimag/Matrix.h	/^    size_type size() const { return nRow*nCol; }$/;"	f	class:psimag::Matrix
size	PartialPsimag/MatrixLike.h	/^      size_t size() const {return n_row()*n_col();}$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
size	PartialPsimag/MatrixLike.h	/^    void size(const MatrixLikeType& matrix)  {$/;"	f	namespace:psimag::MatrixLike
size	PartialPsimag/MatrixSlice.h	/^    inline size_t size()  const { return mat.n_col(); }$/;"	f	class:psimag::RowSlice
size	PartialPsimag/MatrixSlice.h	/^    size_t size()  const { return mat.n_row(); }$/;"	f	class:psimag::ColSlice
size	PartialPsimag/RealPart.h	/^    size_t size()  const { return mat.size(); }$/;"	f	class:psimag::RealPart
size	PartialPsimag/TagAttributes.h	/^    size_t size() const { return attrs.size(); }$/;"	f	class:psimag::TagAttributes
size	PartialPsimag/Vec.h	/^    static size_t size () { return 2; }$/;"	f	class:psimag::Vec
size	PartialPsimag/Vec.h	/^    static size_t size () { return 3; }$/;"	f	class:psimag::Vec
size	PartialPsimag/Vec.h	/^    static size_t size () { return DIM; }$/;"	f	class:psimag::Vec
size	PsimagLite/drivers/minimizer.cpp	/^	size_t size() const { return  2; }$/;"	f	class:MyFunctionTest
size	PsimagLite/src/ContinuedFraction.h	/^		size_t size() const { return ab_.size(); }$/;"	f	class:PsimagLite::ContinuedFraction
size	PsimagLite/src/ContinuedFractionCollection.h	/^		size_t size() const { return data_.size(); }$/;"	f	class:PsimagLite::ContinuedFractionCollection
size	PsimagLite/src/Geometry/GeometryDirection.h	/^			size_t size() const$/;"	f	class:PsimagLite::GeometryDirection
size	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    size_t size() const {$/;"	f	class:JsonParser::Whatever
size	PsimagLite/src/JSON/MatrixLike.h	/^      size_t size() const {return n_row()*n_col();}$/;"	f	class:psimag::MatrixLike::DoubleVectorWrap
size	PsimagLite/src/JSON/MatrixLike.h	/^    void size(const MatrixLikeType& matrix)  {$/;"	f	namespace:psimag::MatrixLike
size	PsimagLite/src/JSON/Transposer.h	/^    size_t size()  const { return mat.size(); }$/;"	f	class:psimag::Transposed
size	PsimagLite/src/JSON/Transposer.h	/^    size_t size()  const { return mat.size(); }$/;"	f	class:psimag::Transposer
size	PsimagLite/src/Minimizer.h	/^		size_t size() const { return v_->size; }$/;"	f	class:PsimagLite::MockVector
size	PsimagLite/src/TridiagonalMatrix.h	/^		size_t size() const { return a_.size(); }$/;"	f	class:PsimagLite::TridiagonalMatrix
size_	PsimagLite/src/CrsMatrix.h	/^		int size_;$/;"	m	class:PsimagLite::CrsMatrix
size_type	PartialPsimag/Matrix.h	/^    typedef size_t       size_type;$/;"	t	class:psimag::Matrix
sizetvectors	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, std::vector<size_t> >          sizetvectors;$/;"	m	class:dca::JSN
skipWhiteAnd	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    static void skipWhiteAnd(std::wstring chars, std::wistream& inputStream) {$/;"	f	class:JsonParser::CharacterMapper
slashes	PartialPsimag/TagAttributeParser.h	/^    const string     slashes;$/;"	m	class:psimag::TagAttributeParser
sliceCol	PartialPsimag/MatrixSlice.h	/^    const size_t          sliceCol;$/;"	m	class:psimag::ColSlice
sliceRow	PartialPsimag/MatrixSlice.h	/^    const size_t          sliceRow;$/;"	m	class:psimag::RowSlice
slope	PartialPsimag/Symmetry/SeitzPosition.h	/^  Field slope(const SeitzPosition<Field,2>&  p1, $/;"	f	namespace:psimag
slope	PartialPsimag/Symmetry/SeitzTranslation.h	/^  Field slope(const SeitzTranslation<Field,2>&  t) {$/;"	f	namespace:psimag
sname	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    std::string sname() const {$/;"	f	class:JsonParser::Whatever
sol	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    Vec<SolutionType, NCOL>        sol;$/;"	m	class:psimag::BackSubstitution
sort	PsimagLite/src/Sort.h	/^	void sort(ContainerType& x,std::vector<size_t>& iperm)$/;"	f	class:Sort
spaceGroup	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    const SpaceGroupType&              spaceGroup;$/;"	m	class:psimag::AppliedSymmetryElementIterator
spaceGroup	PartialPsimag/Symmetry/Symmetry.h	/^    const SpaceGroupType& spaceGroup() const {$/;"	f	class:psimag::Symmetry
spaceGroups	PartialPsimag/Symmetry/Symmetry.h	/^    SpaceGroupVectorType        spaceGroups;$/;"	m	class:psimag::Symmetry
spaceGroupsSet	PartialPsimag/Symmetry/Symmetry.h	/^    bool                        spaceGroupsSet;$/;"	m	class:psimag::Symmetry
spinFactor	parameters.h	/^		Field staticUFactor,chargeFactor,spinFactor;$/;"	m	class:rpa::parameters
spinMatrix	1band_wSpin.h	/^		ComplexMatrixType   spinMatrix;$/;"	m	class:rpa::SingleBand_wSpin
spinMatrix	BSCCObilayer.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinMatrix	SrRuO_SO.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinMatrix	bilayer.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinMatrix	bilayerFESC.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinMatrix	coupledLadders.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinMatrix	orthoIIBilayer.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinMatrix	singleBand.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinMatrix	tbFromFile.h	/^		ComplexMatrixType spinMatrix;$/;"	m	class:rpa::model
spinOfEll	1band_wSpin.h	/^		std::vector<int>    spinOfEll;$/;"	m	class:rpa::SingleBand_wSpin
spinOfEll	SrRuO_SO.h	/^		std::vector<int> spinOfEll;$/;"	m	class:rpa::model
split	PartialPsimag/Symmetry/FieldParser.h	/^inline  std::vector<std::string> split(const std::string input, const char sep) {$/;"	f	namespace:psimag
split	PsimagLite/src/Geometry/Geometry.h	/^			void split(BlockType& S,std::vector<BlockType>& X,std::vector<BlockType>& Y,BlockType& E) const$/;"	f	class:PsimagLite::Geometry
sqrtString	PartialPsimag/Symmetry/FieldParser.h	/^    static std::string   sqrtString;$/;"	m	class:psimag::FieldParser
squareElements	PartialPsimag/Matrix.h	/^    ThisType& squareElements()$/;"	f	class:psimag::Matrix
squareElements	PartialPsimag/MatrixLike.h	/^    MatrixLikeType& squareElements(MatrixLikeType& matrix) {$/;"	f	namespace:psimag::MatrixLike
squareElements	PartialPsimag/VectorLike.h	/^    VectorLikeType& squareElements(VectorLikeType& vector) {$/;"	f	namespace:psimag::VectorLike
squareElements	PsimagLite/src/JSON/MatrixLike.h	/^    MatrixLikeType& squareElements(MatrixLikeType& matrix) {$/;"	f	namespace:psimag::MatrixLike
square_list	PythonScripts/test.py	/^def square_list(mylist, start,stop, result): $/;"	f
squaredLength	PartialPsimag/VectorLike.h	/^    typename VectorLikeType::value_type squaredLength(const VectorLikeType& vector) {$/;"	f	namespace:psimag::VectorLike
stack	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    std::vector<Whatever*>    stack;$/;"	m	class:JsonParser::DefaultContext
stack	PsimagLite/src/JSON/JsonParser/ModesMixin.h	/^    std::vector<ModeType> stack;$/;"	m	class:JsonParser::ModesMixin
standAlone	PartialPsimag/XMLHeading.h	/^    std::string standAlone;$/;"	m	class:psimag::XMLHeading
start	PartialPsimag/TagAttributeParser.h	/^    string::size_type start;$/;"	m	class:psimag::TagAttributeParser
startPos	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    int            startPos;$/;"	m	class:JsonParser::Whatever
start_	PsimagLite/src/Profiling.h	/^			clock_t start_;	$/;"	m	class:PsimagLite::Profiling
state	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    StateType             state;$/;"	m	class:JsonParser::JsonParser
states	PsimagLite/src/JSON/JsonParser/StatesMixin.h	/^    typedef enum states {$/;"	g	class:JsonParser::StatesMixin
statesAndActions	PsimagLite/src/JSON/JsonParser/StatesAndActionsMixin.h	/^    typedef enum statesAndActions {$/;"	g	class:JsonParser::StatesAndActionsMixin
staticUFactor	parameters.h	/^		Field staticUFactor,chargeFactor,spinFactor;$/;"	m	class:rpa::parameters
static_size	PartialPsimag/Vec.h	/^    static const size_t static_size=2;$/;"	m	class:psimag::Vec
static_size	PartialPsimag/Vec.h	/^    static const size_t static_size=3;$/;"	m	class:psimag::Vec
static_size	PartialPsimag/Vec.h	/^    static const size_t static_size=DIM;$/;"	m	class:psimag::Vec
std	PsimagLite/src/Complex.h	/^namespace std {$/;"	n
std	PsimagLite/src/Stack.h	/^namespace std {$/;"	n
std	PsimagLite/src/Vector.h	/^namespace std {$/;"	n
step_	PsimagLite/src/ConcurrencySerial.h	/^		int step_;$/;"	m	class:PsimagLite::ConcurrencySerial
step_	PsimagLite/src/Range.h	/^		size_t step_; \/\/ step within this processor$/;"	m	class:PsimagLite::Range
steps	PsimagLite/src/ChebyshevSolver.h	/^		size_t steps() const {return params_.steps; }$/;"	f	class:PsimagLite::ChebyshevSolver
steps	PsimagLite/src/LanczosSolver.h	/^		size_t steps() const {return steps_; }$/;"	f	class:PsimagLite::LanczosSolver
steps	PsimagLite/src/ParametersForSolver.h	/^		size_t steps;$/;"	m	struct:PsimagLite::ParametersForSolver
stepsForEnergyConvergence	PsimagLite/src/ParametersForSolver.h	/^		size_t stepsForEnergyConvergence;$/;"	m	struct:PsimagLite::ParametersForSolver
stepsForEnergyConvergence_	PsimagLite/src/LanczosSolver.h	/^		size_t stepsForEnergyConvergence_;$/;"	m	class:PsimagLite::LanczosSolver
steps_	PsimagLite/src/LanczosSolver.h	/^		size_t steps_;$/;"	m	class:PsimagLite::LanczosSolver
steps_	PsimagLite/src/LanczosVectors.h	/^		size_t steps_;$/;"	m	class:PsimagLite::LanczosVectors
storeChi	parameters.h	/^		size_t storeChi;$/;"	m	class:rpa::parameters
storeChi_	pairing.h	/^		size_t storeChi_;$/;"	m	class:rpa::pairing
storeGammaOrb	parameters.h	/^		size_t storeGammaOrb;$/;"	m	class:rpa::parameters
storeGammaOrb_	pairing.h	/^		size_t storeGammaOrb_;$/;"	m	class:rpa::pairing
str	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^    std::wstring str() {$/;"	f	class:JsonParser::ParseBuffer
stringLists	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, std::vector<std::string> >     stringLists;$/;"	m	class:dca::JSN
stringMarker	PsimagLite/src/ChebyshevSerializer.h	/^		static const std::string& stringMarker() { return stringMarker_; }$/;"	f	class:PsimagLite::ChebyshevSerializer
stringMarker_	PsimagLite/src/ChebyshevSerializer.h	/^		static const std::string stringMarker_;$/;"	m	class:PsimagLite::ChebyshevSerializer
stringMarker_	PsimagLite/src/ChebyshevSerializer.h	/^	const std::string ChebyshevSerializer<RealType,VectorType>::stringMarker_ =$/;"	m	class:PsimagLite::ChebyshevSerializer
strings	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, std::string>                   strings;$/;"	m	class:dca::JSN
subLatVecCoords	PartialPsimag/Symmetry/SuperCrystal.h	/^    SubLatticeVecCoordsType        subLatVecCoords;$/;"	m	class:psimag::SuperCrystal
subLattice	PartialPsimag/Symmetry/Lattice.h	/^    ThisType subLattice(const LatticeCoordsType& coords) const {$/;"	f	class:psimag::Lattice
subLatticeVecCoords	PartialPsimag/Symmetry/SuperCrystalBuilder.h	/^    SubLatticeVecCoordsType subLatticeVecCoords;$/;"	m	class:psimag::SuperCrystalBuilder
subOptions	parameters.h	/^		std::string subOptions;$/;"	m	class:rpa::parameters
sublattice	parameters.h	/^		size_t sublattice;$/;"	m	class:rpa::parameters
subs0	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t subs0(size_t smax,size_t emin,size_t i) const$/;"	f	class:PsimagLite::KTwoNiFFour
subs1	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t subs1(size_t smax,size_t emin,size_t i) const$/;"	f	class:PsimagLite::KTwoNiFFour
subs2	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t subs2(size_t smax,size_t emin,size_t i) const$/;"	f	class:PsimagLite::KTwoNiFFour
subs3	PsimagLite/src/Geometry/KTwoNiFFour.h	/^		size_t subs3(size_t smax,size_t emin,size_t i) const$/;"	f	class:PsimagLite::KTwoNiFFour
sum	PartialPsimag/VectorLike.h	/^    sum(const VectorLikeType1& vector1,$/;"	f	namespace:psimag::VectorLike
sumBlock	PsimagLite/src/CrsMatrix.h	/^	void sumBlock(CrsMatrix<T> &A,CrsMatrix<T> const &B,size_t offset)$/;"	f	namespace:PsimagLite
super	greensFunction.h	/^ 		BaseType& super;$/;"	m	class:rpa::greensFunction
susInt	susInt.h	/^	inline FieldType susInt(const FieldType& e1, const FieldType& e2, $/;"	f	namespace:rpa
susInt	susInt.h	/^	inline std::complex<FieldType> susInt(const FieldType& e1, const FieldType& e2, $/;"	f	namespace:rpa
susIntBCS	susInt.h	/^	inline std::complex<FieldType> susIntBCS(const FieldType& e1, const FieldType& e2,$/;"	f	namespace:rpa
susIntBCSFF	susInt.h	/^	inline std::complex<FieldType> susIntBCSFF(const FieldType& e1, const FieldType& e2,$/;"	f	namespace:rpa
susIntBCSGG	susInt.h	/^	inline std::complex<FieldType> susIntBCSGG(const FieldType& e1, const FieldType& e2,$/;"	f	namespace:rpa
susc	chi0.h	/^		susc() {}$/;"	f	class:rpa::susc
susc	chi0.h	/^		susc(const susc& other):$/;"	f	class:rpa::susc
susc	chi0.h	/^		susc(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::susc
susc	chi0.h	/^	class susc:$/;"	c	namespace:rpa
susceptibility	susceptibility.h	/^		susceptibility(rpa::parameters<Field,MatrixTemplate,ConcurrencyType>& parameters,$/;"	f	class:rpa::susceptibility
susceptibility	susceptibility.h	/^	class susceptibility {$/;"	c	namespace:rpa
susq	pairing.h	/^		chi0q<FieldType,SuscType,BandsType,GapType,psimag::Matrix,ConcurrencyType> susq;$/;"	m	class:rpa::pairing
swap2Rows	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    void swap2Rows(size_t r1, size_t r2) {$/;"	f	class:psimag::HermiteNormalForm
swapBasisVectors	PartialPsimag/Symmetry/ReducedLattice.h	/^    void swapBasisVectors(size_t b1i, size_t b2i) {$/;"	f	class:psimag::ReducedLattice
swapCols	PartialPsimag/Symmetry/Mat/Mat.h	/^    void swapCols(size_t c1, size_t c2) {$/;"	f	class:psimag::Mat
swapCols	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void swapCols(size_t i, size_t j) { rotation.swapCols(i,j);}$/;"	f	class:psimag::SeitzMatrix
swapRows	PartialPsimag/Symmetry/Mat/Mat.h	/^    void swapRows(size_t r1, size_t r2) {$/;"	f	class:psimag::Mat
swapRows	PartialPsimag/Symmetry/SeitzMatrix.h	/^    void swapRows(size_t i, size_t j) { rotation.swapRows(i,j);}$/;"	f	class:psimag::SeitzMatrix
swaps	PsimagLite/src/Rusage.h	/^		long swaps() const { return rusage_.ru_nswap; }$/;"	f	class:PsimagLite::Rusage
swave	CrystalHarmonics2D.h	/^	FieldType swave(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
swaveRPAKFe2Se2_elDoped	CrystalHarmonics2D.h	/^	FieldType swaveRPAKFe2Se2_elDoped(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
swaveRPALiFeAs	CrystalHarmonics2D.h	/^	FieldType swaveRPALiFeAs(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
swaveRPALiFeAs_2	CrystalHarmonics2D.h	/^	FieldType swaveRPALiFeAs_2(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
swaveRot	CrystalHarmonics2D.h	/^	FieldType swaveRot(const std::vector<FieldType>& kvector, $/;"	f	namespace:rpa
symmetry	PartialPsimag/Symmetry/CrystalBase.h	/^    SymmetryType symmetry;$/;"	m	class:psimag::CrystalBase
symmetryDistance	PartialPsimag/Symmetry/Lattice.h	/^    Field symmetryDistance(const SymmetryOperation<Field,DIM,Algorithms>& cartSymmetryOperation) const {$/;"	f	class:psimag::Lattice
symmetryElement	PartialPsimag/Symmetry/SymmetryOperation.h	/^  SymmetryElement<Field,2,Algorithms> symmetryElement(const SymmetryOperation<Field,2,Algorithms> cartesianOp,$/;"	f	namespace:psimag
symmetryGroup	PartialPsimag/Symmetry/Symmetry.h	/^    SymmetryGroupType            symmetryGroup;$/;"	m	class:psimag::Symmetry
symmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^  SymmetryOperation<Field,2,Algorithms> symmetryOperation(IN_TYPE x1, IN_TYPE x2, IN_TYPE x3,$/;"	f	namespace:psimag
symmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^  SymmetryOperation<Field,2,Algorithms> symmetryOperation(IN_TYPE x1, IN_TYPE x2,$/;"	f	namespace:psimag
symmetryOperation	PartialPsimag/Symmetry/SymmetryOperation.h	/^  SymmetryOperation<Field,3,Algorithms> symmetryOperation(IN_TYPE x1, IN_TYPE x2, IN_TYPE x3,$/;"	f	namespace:psimag
sys	Plot_ek_high_sym.dat.py	/^import sys$/;"	i
sys	PythonScripts/Bandstructure.py	/^import sys$/;"	i
sys	PythonScripts/Calc_lambda.py	/^import sys$/;"	i
sys	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^import sys$/;"	i
sys	PythonScripts/CoupledLadders.py	/^import sys$/;"	i
sys	PythonScripts/Plot_chiRPA_qxqy.py	/^import sys$/;"	i
sys	PythonScripts/Plot_chiRPA_w.py	/^import sys$/;"	i
sys	PythonScripts/Sr2RuO4.py	/^import sys$/;"	i
sys	PythonScripts/plotChiRPAAlongHighSym.py	/^import sys$/;"	i
t	BSCCObilayer.h	/^		Field t,tp,tpp,tperp,mu;$/;"	m	class:rpa::model
tagAttributes	PartialPsimag/TagAttributes.h	/^    std::map<std::string, std::string>& tagAttributes;$/;"	m	class:psimag::TagAttributesClosure
targetLattice	PartialPsimag/Symmetry/FloodTiler.h	/^    LatticeType                     targetLattice;$/;"	m	class:psimag::FloodTiler
tbfile	parameters.h	/^		std::string tbfile;$/;"	m	class:rpa::parameters
tempc	pairing.h	/^		ComplexMatrixType tempc;$/;"	m	class:rpa::pairing
temperature	parameters.h	/^		Field temperature;$/;"	m	class:rpa::parameters
templatedFunction	PsimagLite/scripts/functionSigIndent.pl	/^sub templatedFunction$/;"	s
temps	pairing.h	/^		ComplexMatrixType temps;$/;"	m	class:rpa::pairing
terms	PsimagLite/src/Geometry/Geometry.h	/^			size_t terms() const { return terms_.size(); }$/;"	f	class:PsimagLite::Geometry
terms_	PsimagLite/src/Geometry/Geometry.h	/^			std::vector<GeometryTermType> terms_;$/;"	m	class:PsimagLite::Geometry
testMultiply	PsimagLite/drivers/testCRSMatrix.cpp	/^void testMultiply(const SampleCRSMatrix<T>& m,RealType maxValue)$/;"	f
testPattern	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^    TestPatternType                           testPattern;$/;"	m	class:psimag::AppliedSymmetryElement
testPattern	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^    TestPatternType          testPattern;$/;"	m	class:psimag::AppliedSymmetryElement
theCharacters	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^    std::vector<wchar_t> theCharacters;$/;"	m	class:JsonParser::ParseBuffer
thereSnoGsl	PsimagLite/src/GslWrapper.h	/^		void thereSnoGsl() const$/;"	f	class:PsimagLite::GslWrapper
threadNum	PsimagLite/src/Pthreads.h	/^	int threadNum;	$/;"	m	struct:PthreadFunctionStruct
thread_function_wrapper	PsimagLite/src/Pthreads.h	/^void *thread_function_wrapper(void *dummyPtr)$/;"	f
threefold	PartialPsimag/Symmetry/CellRotation.h	/^		   twofold=2, threefold=3,  fourfold=4, sixfold=6 } RotationType;$/;"	e	enum:psimag::CellRotation::__anon62
threefoldInv	PartialPsimag/Symmetry/CellRotation.h	/^    typedef enum { sixfoldInv=-6, fourfoldInv=-4, threefoldInv=-3, twofoldInv=-2, inversion=-1, identity=1, $/;"	e	enum:psimag::CellRotation::__anon62
threshold	PartialPsimag/Symmetry/BasicCrystalAlgorithms.h	/^  static double threshold() {$/;"	f	class:psimag::BasicCrystalAlgorithms
tileInTargetLatticeFor	PartialPsimag/Symmetry/FloodTiler.h	/^    bool tileInTargetLatticeFor(const CartesianTranslationType& trans) {$/;"	f	class:psimag::FloodTiler
tileLattice	PartialPsimag/Symmetry/FloodTiler.h	/^    const LatticeType&              tileLattice;$/;"	m	class:psimag::FloodTiler
tilePattern	PartialPsimag/Symmetry/FloodTiler.h	/^    const PatternType&              tilePattern;$/;"	m	class:psimag::FloodTiler
tiledPatternData	PartialPsimag/Symmetry/FloodTiler.h	/^    PatternDataType                 tiledPatternData;$/;"	m	class:psimag::FloodTiler
time	PsimagLite/src/Rusage.h	/^		std::pair<size_t,size_t> time(size_t userOrSystem = USER_TIME) const$/;"	f	class:PsimagLite::Rusage
time	PythonScripts/Calc_lambda.py	/^import time$/;"	i
time	PythonScripts/Calc_lambda_bilayer_fullBZ.py	/^import time$/;"	i
time	PythonScripts/CoupledLadders.py	/^import time$/;"	i
time	PythonScripts/Sr2RuO4.py	/^import time$/;"	i
time	PythonScripts/plotChiRPAAlongHighSym.py	/^import time$/;"	i
times	PartialPsimag/MatrixLike.h	/^    MatrixLikeType& times(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
times	PartialPsimag/VectorLike.h	/^    VectorLikeType& times(VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
times	PsimagLite/src/JSON/MatrixLike.h	/^    MatrixLikeType& times(MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
to	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<bool>           { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_BOOL;     } };$/;"	f	class:JsonParser::TYPE
to	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<double>         { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_DOUBLE;   } };$/;"	f	class:JsonParser::TYPE
to	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<int>            { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_INTEGER;  } };$/;"	f	class:JsonParser::TYPE
to	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<std::map<std::wstring,Whatever> >  { public: Whatever::WhateverType to() {return Whatever::WHATEVER_MAP;    } };$/;"	f	class:JsonParser::TYPE
to	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<std::string>    { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_STRING;   } };$/;"	f	class:JsonParser::TYPE
to	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<> class TYPE<std::vector<Whatever> >            { public: Whatever::WhateverType to() {return Whatever::WHATEVER_VECTOR; } };$/;"	f	class:JsonParser::TYPE
to	PsimagLite/src/JSON/JsonParser/Whatever.h	/^  template<typename T> class TYPE       { public: static Whatever::WhateverType to() {return Whatever::WHATEVER_UNKNOWN;  } };$/;"	f	class:JsonParser::TYPE
toJSN	PartialPsimag/Matrix.h	/^	  void toJSN(std::ostream& os, std::string title="Matrix", int width=13, bool showIndices= false,bool pythonFormat=true) const $/;"	f	class:psimag::Matrix
toJSN	PartialPsimag/MatrixLike.h	/^    void toJSN(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
toJSN	PartialPsimag/VectorLike.h	/^    void toJSN(const VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
toJSN	PsimagLite/src/JSON/MatrixLike.h	/^    void toJSN(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
toJSN	PsimagLite/src/JSON/Transposer.h	/^    void toJSN(std::ostream& os, std::string title, int width) const {$/;"	f	class:psimag::Transposer
toJSN2	PartialPsimag/Matrix.h	/^	  void toJSN2(std::ostream& os, std::string title="Matrix", int width=13, bool showIndices= false,bool pythonFormat=true) const $/;"	f	class:psimag::Matrix
toString	PartialPsimag/Tag.h	/^  std::string toString(Field value) {$/;"	f	namespace:psimag
toString	PartialPsimag/VectorLike.h	/^    std::string toString(const VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
toString	PsimagLite/src/JSON/JSN_Writer.h	/^    std::string toString(const std::map<std::string, T>& map) {$/;"	f	class:dca::JSN
toString	PsimagLite/src/JSON/JSN_Writer.h	/^    std::string toString(const std::map<std::string, std::string>& map) {$/;"	f	class:dca::JSN
toString	PsimagLite/src/JSON/JSN_Writer.h	/^    std::string toString(const std::map<std::string, std::vector<T> >& map) {$/;"	f	class:dca::JSN
toXML	PartialPsimag/Matrix.h	/^  Tag toXML(const Matrix<Field>& matrix,$/;"	f	namespace:psimag
toXML	PartialPsimag/MatrixLike.h	/^    Tag toXML(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
toXML	PartialPsimag/Symmetry/AppliedSymmetryElement.h	/^  Tag toXML(const AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms>& symEl,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^  Tag toXML(const AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms>& symOp,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/AppliedSymmetryOperation.h	/^  Tag toXML(const AppliedSymmetryOperation<Field,DIM,Occupant,LatticeType,Algorithms>& symEl,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CartesianPosition.h	/^  Tag toXML(const CartesianPosition<Field,DIM> pos,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CartesianTranslation.h	/^  Tag toXML(const CartesianTranslation<Field,DIM> pos,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CellParameters.h	/^  Tag toXML(const CellParameters< Field, 1, Algorithms >& p,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CellParameters.h	/^  Tag toXML(const CellParameters< Field, 2, Algorithms >& p,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CellParameters.h	/^  Tag toXML(const CellParameters< Field, 3 , Algorithms >& p,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CellPosition.h	/^  Tag toXML(const CellPosition<Field,DIM,Algorithms> pos, $/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CellTranslation.h	/^  Tag toXML(const CellTranslation<Field,DIM> t, std::string name="CellTranslation") {$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/Crystal.h	/^  Tag toXML(const Crystal<Field,DIM,Occupant,Algorithms>& crystal,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/CrystalBase.h	/^  Tag toXML(const CrystalBase<Field,DIM,Occupant,LatticeTemplate,Algorithms>& crystalBase,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/GroupAction.h	/^  Tag toXML(const GroupAction<Field,DIM,Occupant,LatticeTemplate,Algorithms>& groupAction,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/GroupMultiplicationTable.h	/^  Tag toXML(const GroupMultiplicationTable<Field,DIM,Occupant,LatticeTemplate,Algorithms>& multiplicationTable,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/Lattice.h	/^  Tag toXML(const Lattice<Field,DIM,Algorithms>& lat,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/LatticeCoordinates.h	/^  Tag toXML(const LatticeCoordinates<DIM> lTrans,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/LatticeTransformation.h	/^  Tag toXML(const LatticeTransformation<Field,DIM>& latTrans,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/LatticeTranslation.h	/^  Tag toXML(const LatticeTranslation<DIM> lTrans,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/LatticeWithPattern.h	/^  Tag toXML(const LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>& latticeWithPattern,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^  Tag toXML(const HermiteNormalForm<Field, NROW, NCOL>& hnf,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/MetricTensor.h	/^    Tag toXML() {$/;"	f	class:psimag::MetricTensor
toXML	PartialPsimag/Symmetry/MetricTensor.h	/^  Tag toXML(MetricTensor<Field,DIM> metric,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/Orbits.h	/^  Tag toXML(const Orbits<Field>& orbits,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/Pattern.h	/^  Tag toXML(const Pattern<Field,DIM,Occupant,Algorithms>& pat,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SeitzMatrix.h	/^  Tag toXML(const SeitzMatrix<Field,DIM>& m,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SeitzPosition.h	/^  Tag toXML(const SeitzPosition<Field,DIM> pos, $/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SeitzTranslation.h	/^  Tag toXML(const SeitzTranslation<Field,DIM> pos, $/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SpaceGroup2D.h	/^  Tag toXML(const SpaceGroup<Field,DIM,Occupant,Algorithms>& spaceGroup,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/Star.h	/^  Tag toXML(const Star<Field,DIM,Occupant,LatticeTemplate,Algorithms>& star,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SuperCrystal.h	/^  Tag toXML(const SuperCrystal<Field,DIM,Occupant,Algorithms,BuilderHelperTemplate>& superCrystal,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/Symmetry.h	/^  Tag toXML(const Symmetry<Field,DIM,Occupant,LatticeTemplate,Algorithms>& symmetry,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SymmetryElement.h	/^  Tag toXML(const SymmetryElement<Field,DIM,Algorithms>& el,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SymmetryGroup.h	/^  Tag toXML(const SymmetryGroup<Field,DIM,Occupant,LatticeTemplate,Algorithms>& symmetryGroup,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/SymmetryOperation.h	/^  Tag toXML(const SymmetryOperation<Field,DIM,Algorithms>& symOp,$/;"	f	namespace:psimag
toXML	PartialPsimag/Symmetry/TestPattern.h	/^  Tag toXML(const TestPattern<Field,DIM,Occupant,LatticeType,Algorithms>& latticeWithPattern,$/;"	f	namespace:psimag
toXML	PartialPsimag/VectorLike.h	/^    Tag toXML(const VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
toZero	greensFunction.h	/^	void toZero() {$/;"	f	class:rpa::greensFunction
token	PartialPsimag/TagAttributeParser.h	/^    string     token;$/;"	m	class:psimag::TagAttributeParser
tokenizer	PsimagLite/src/Tokenizer.h	/^	void tokenizer(const std::string& str,$/;"	f	namespace:PsimagLite
tolerance	PsimagLite/src/ParametersForSolver.h	/^		RealType tolerance;$/;"	m	struct:PsimagLite::ParametersForSolver
total_	PsimagLite/src/ConcurrencySerial.h	/^		size_t total_;$/;"	m	class:PsimagLite::ConcurrencySerial
total_	PsimagLite/src/Range.h	/^		size_t total_; \/\/ total number of indices total_(total),$/;"	m	class:PsimagLite::Range
total_	PsimagLite/src/Range.h	/^		size_t total_; \/\/ total number of indices$/;"	m	class:PsimagLite::Range
tp	BSCCObilayer.h	/^		Field t,tp,tpp,tperp,mu;$/;"	m	class:rpa::model
tperp	BSCCObilayer.h	/^		Field t,tp,tpp,tperp,mu;$/;"	m	class:rpa::model
tpp	BSCCObilayer.h	/^		Field t,tp,tpp,tperp,mu;$/;"	m	class:rpa::model
trace	PartialPsimag/Symmetry/SymmetryElement.h	/^    Field                   trace;$/;"	m	class:psimag::SymmetryElement
trace	PartialPsimag/Symmetry/SymmetryOperation.h	/^    Field trace() const {$/;"	f	class:psimag::SymmetryOperation
trace	PsimagLite/src/JSON/JsonParser/DefaultContext.h	/^    bool                      trace;$/;"	m	class:JsonParser::DefaultContext
trace	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    bool                 trace;$/;"	m	class:JsonParser::JsonParser
trace	PsimagLite/src/JSON/JsonParser/ParseBuffer.h	/^    bool                 trace;$/;"	m	class:JsonParser::ParseBuffer
transRotation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    RotationType             transRotation;$/;"	m	class:psimag::SeitzMatrix
transSet	PartialPsimag/Symmetry/SeitzMatrix.h	/^    bool                     transSet;$/;"	m	class:psimag::SeitzMatrix
transform	PartialPsimag/Symmetry/Lattice.h	/^    LatticeTransformationType   transform;$/;"	m	class:psimag::Lattice
transformFullFast	PsimagLite/src/CrsMatrix.h	/^	inline Matrix<T> transformFullFast(CrsMatrix<T> const &S,Matrix<T> const &fmB)$/;"	f	namespace:PsimagLite
transformK	tbFromFile.h	/^		void transformK(const std::vector<FieldType>& kIn, std::vector<FieldType>& kOut) {$/;"	f	class:rpa::model
transformation	PartialPsimag/Symmetry/InverseLatticeTransformation.h	/^    const LatticeTransformationType& transformation;$/;"	m	class:psimag::InverseLatticeTransformation
translation	PartialPsimag/Symmetry/SeitzMatrix.h	/^    TranslationType          translation;$/;"	m	class:psimag::SeitzMatrix
translationPart	PartialPsimag/Symmetry/SymmetryElement.h	/^    CellTranslationType     translationPart;$/;"	m	class:psimag::SymmetryElement
translationPart	PartialPsimag/Symmetry/SymmetryOperation.h	/^    SeitzTranslationType translationPart() const {$/;"	f	class:psimag::SymmetryOperation
transpose	PartialPsimag/MatrixSlice.h	/^    ColSlice<MatrixLikeType> transpose() {$/;"	f	class:psimag::TransposedColSlice
transpose	PartialPsimag/MatrixSlice.h	/^    RowSlice<MatrixLikeType> transpose() {$/;"	f	class:psimag::TransposedRowSlice
transpose	PartialPsimag/MatrixSlice.h	/^    TransposedColSlice<MatrixLikeType> transpose() {$/;"	f	class:psimag::ColSlice
transpose	PartialPsimag/MatrixSlice.h	/^    TransposedRowSlice<MatrixLikeType> transpose() {$/;"	f	class:psimag::RowSlice
transpose	PartialPsimag/Symmetry/SeitzMatrix.h	/^    const SeitzMatrix<Field, DIM> transpose()  const{$/;"	f	class:psimag::SeitzMatrix
transpose	PartialPsimag/Symmetry/SeitzMatrix.h	/^    const SeitzMatrix<Field, DIM> transpose()  {$/;"	f	class:psimag::SeitzMatrix
transpose	PsimagLite/src/JSON/Transposer.h	/^    MatrixLikeType& transpose() {$/;"	f	class:psimag::Transposed
transpose	PsimagLite/src/JSON/Transposer.h	/^    MatrixLikeType& transpose() {$/;"	f	class:psimag::Transposer
transpose	PsimagLite/src/JSON/Transposer.h	/^    const MatrixLikeType& transpose() const {$/;"	f	class:psimag::Transposed
transpose	PsimagLite/src/JSON/Transposer.h	/^    const MatrixLikeType& transpose() const {$/;"	f	class:psimag::Transposer
transposeConjugate	PsimagLite/src/CrsMatrix.h	/^	inline void transposeConjugate(CrsMatrix<S>  &B,CrsMatrix<S2> const &A)$/;"	f	namespace:PsimagLite
transposeConjugate	PsimagLite/src/Matrix.h	/^	PsimagLite::Matrix<T> transposeConjugate(const Matrix<T>& A)$/;"	f	namespace:PsimagLite
transposeConjugate	PsimagLite/src/Matrix.h	/^	void transposeConjugate(Matrix<T>& m2,const Matrix<T>& m)$/;"	f	namespace:PsimagLite
ttos	PsimagLite/src/TypeToString.h	/^std::string ttos(T t)$/;"	f
twofold	PartialPsimag/Symmetry/CellRotation.h	/^		   twofold=2, threefold=3,  fourfold=4, sixfold=6 } RotationType;$/;"	e	enum:psimag::CellRotation::__anon62
twofoldInv	PartialPsimag/Symmetry/CellRotation.h	/^    typedef enum { sixfoldInv=-6, fourfoldInv=-4, threefoldInv=-3, twofoldInv=-2, inversion=-1, identity=1, $/;"	e	enum:psimag::CellRotation::__anon62
type	PartialPsimag/Symmetry/CellRotation.h	/^    RotationType type() {$/;"	f	class:psimag::CellRotation
type	PartialPsimag/Symmetry/SymmetryElement.h	/^    std::string             type;$/;"	m	class:psimag::SymmetryElement
type	PartialPsimag/Symmetry/SymmetryOperation.h	/^    typename CellRotation<Field, DIM>::RotationType type() {$/;"	f	class:psimag::SymmetryOperation
type	PsimagLite/src/ChebyshevSerializer.h	/^		size_t type;$/;"	m	struct:PsimagLite::KernelPolynomialParameters
type	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    WhateverType   type;$/;"	m	class:JsonParser::Whatever
type1	PsimagLite/src/Geometry/KTwoNiFFour.h	/^			size_t type1;$/;"	m	struct:PsimagLite::KTwoNiFFour::AdditionalData
type2	PsimagLite/src/Geometry/KTwoNiFFour.h	/^			size_t type2;$/;"	m	struct:PsimagLite::KTwoNiFFour::AdditionalData
typeName	PartialPsimag/Symmetry/ConventionalLattice.h	/^    static std::string typeName() { return "ConventionalLattice";   }$/;"	f	class:psimag::ConventionalLattice
typeName	PartialPsimag/Symmetry/Lattice.h	/^    static std::string typeName() { return "InputLattice";   }$/;"	f	class:psimag::Lattice
typeName	PartialPsimag/Symmetry/ReducedLattice.h	/^    static std::string typeName() { return "ReducedLattice";   }$/;"	f	class:psimag::ReducedLattice
typeName	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    static std::wstring typeName(WhateverType t) {$/;"	f	class:JsonParser::Whatever
typeString	PartialPsimag/Symmetry/CellParameters.h	/^    std::string typeString() const {$/;"	f	class:psimag::CellParameters
typeToString	PsimagLite/src/TypeToString.h	/^	std::string typeToString(T t)$/;"	f	namespace:PsimagLite
unNormalizedName	PartialPsimag/Symmetry/SymmetryElement.h	/^    std::string             unNormalizedName;$/;"	m	class:psimag::SymmetryElement
unimplemented	PsimagLite/src/ChebyshevSolver.h	/^		void unimplemented(const std::string& s) const$/;"	f	class:PsimagLite::ChebyshevSolver
uniqueActions	PartialPsimag/Symmetry/GroupAction.h	/^    void uniqueActions(Matrix<int>& permutations) const {$/;"	f	class:psimag::GroupAction
uniquePermutationOps	PartialPsimag/Symmetry/GroupAction.h	/^    std::vector<int> uniquePermutationOps() const {$/;"	f	class:psimag::GroupAction
unloadBuffer	PsimagLite/src/JSON/JsonParser/JsonParser.h	/^    void unloadBuffer() {$/;"	f	class:JsonParser::JsonParser
unpack	PsimagLite/src/PackIndices.h	/^		void unpack(size_t& x,size_t& y,size_t ind) const$/;"	f	class:PsimagLite::PackIndices
unsharedData	PsimagLite/src/Rusage.h	/^		long unsharedData() const { return rusage_.ru_idrss; }$/;"	f	class:PsimagLite::Rusage
unsharedStack	PsimagLite/src/Rusage.h	/^		long unsharedStack() const { return rusage_.ru_isrss; }$/;"	f	class:PsimagLite::Rusage
update	PartialPsimag/Symmetry/Lattice.h	/^    void update(bool skipParameters=false) {$/;"	f	class:psimag::Lattice
update	PartialPsimag/TagAttributes.h	/^    void update(const std::string attrString) {$/;"	f	class:psimag::TagAttributes
update	PsimagLite/src/MemoryUsage.h	/^		void update()$/;"	f	class:PsimagLite::MemoryUsage
update	PsimagLite/src/Rusage.h	/^		void update()$/;"	f	class:PsimagLite::Rusage
usage	PsimagLite/drivers/combineContinuedFraction.cpp	/^void usage(const char *progName)$/;"	f
usage	PsimagLite/drivers/continuedFraction.cpp	/^void usage(const char *progName)$/;"	f
usage	PsimagLite/drivers/continuedFractionCollection.cpp	/^void usage(const char *progName)$/;"	f
usage	PsimagLite/drivers/kernelPolynomial.cpp	/^void usage(const char *progName)$/;"	f
usage	PsimagLite/drivers/linearPrediction.cpp	/^void usage(const char *progName)$/;"	f
v	PartialPsimag/Symmetry/Mat/HermiteNormalForm.h	/^    const Vec<SolutionType, NROW>&              v;$/;"	m	class:psimag::BackSubstitution
v_	PsimagLite/src/Minimizer.h	/^		const gsl_vector *v_;$/;"	m	class:PsimagLite::MockVector
valString	PsimagLite/src/JSON/JSN_Writer.h	/^    void valString(std::ostream& os, int offset, int keyWidth,$/;"	f	class:dca::JSN
valString	PsimagLite/src/JSON/JSN_Writer.h	/^    void valString(std::ostream& os,int offset, int keyWidth,$/;"	f	class:dca::JSN
validElements	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    validElements(const  std::vector< AppliedSymmetryElement<Field,DIM,Occupant,LatticeType,Algorithms> >& appliedEls) {$/;"	f	class:psimag::SymmetryElements
validElements	PartialPsimag/Symmetry/SymmetryElements2D.h	/^    validElements(const LatticeWithPattern<Field,DIM,Occupant,LatticeType,Algorithms>&             latpat,$/;"	f	class:psimag::SymmetryElements
validPosition	PartialPsimag/Symmetry/AppliedSymmetryElementIterator.h	/^    bool validPosition() { $/;"	f	class:psimag::AppliedSymmetryElementIterator
value	PartialPsimag/Symmetry/TypeManip.h	/^        static const int value = v;$/;"	m	struct:psimag::Int2Type
value	PsimagLite/src/JSON/JSN_Writer.h	/^  template<>           class PrintArrayWidth<double> {public: enum {value=13}; };$/;"	e	enum:dca::PrintArrayWidth::__anon118
value	PsimagLite/src/JSON/JSN_Writer.h	/^  template<typename T> class PrintArrayWidth         {public: enum {value=7 }; };$/;"	e	enum:dca::PrintArrayWidth::__anon117
valueString	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    std::wstring   valueString;$/;"	m	class:JsonParser::Whatever
value_type	PartialPsimag/IndexedMatrix.h	/^    typedef typename MatrixLikeType::value_type value_type;$/;"	t	class:psimag::IndexedMatrix
value_type	PartialPsimag/Matrix.h	/^    typedef T            value_type;$/;"	t	class:psimag::Matrix
value_type	PartialPsimag/MatrixLike.h	/^      typedef typename InnerVectorType::value_type  value_type;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
value_type	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type value_type;$/;"	t	class:psimag::ColSlice
value_type	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type value_type;$/;"	t	class:psimag::RowSlice
value_type	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type value_type;$/;"	t	class:psimag::TransposedColSlice
value_type	PartialPsimag/MatrixSlice.h	/^    typedef typename MatrixLikeType::value_type value_type;$/;"	t	class:psimag::TransposedRowSlice
value_type	PartialPsimag/RealPart.h	/^    typedef  typename ComplexMatrixLikeType::value_type::value_type value_type;$/;"	t	class:psimag::RealPart
value_type	PsimagLite/src/CrsMatrix.h	/^		typedef T value_type;$/;"	t	class:PsimagLite::CrsMatrix
value_type	PsimagLite/src/JSON/MatrixLike.h	/^      typedef typename InnerVectorType::value_type  value_type;$/;"	t	class:psimag::MatrixLike::DoubleVectorWrap
value_type	PsimagLite/src/JSON/Transposer.h	/^    typedef typename MatrixLikeType::value_type value_type;$/;"	t	class:psimag::Transposed
value_type	PsimagLite/src/JSON/Transposer.h	/^    typedef typename MatrixLikeType::value_type value_type;$/;"	t	class:psimag::Transposer
value_type	PsimagLite/src/Matrix.h	/^		typedef T value_type; \/\/ legacy name$/;"	t	class:PsimagLite::Matrix
value_type	PsimagLite/src/Random48.h	/^		typedef T value_type; \/\/ legacy name$/;"	t	class:PsimagLite::Random48
value_type	PsimagLite/src/RandomForTests.h	/^		typedef T value_type; \/\/ legacy name$/;"	t	class:PsimagLite::RandomForTests
value_type	PsimagLite/src/SampleCRSMatrix.h	/^		typedef T value_type;$/;"	t	class:PsimagLite::SampleCRSMatrix
value_type	PsimagLite/src/TridiagonalMatrix.h	/^		typedef FieldType value_type;$/;"	t	class:PsimagLite::TridiagonalMatrix
values_	PsimagLite/src/CrsMatrix.h	/^		std::vector<T> values_;$/;"	m	class:PsimagLite::CrsMatrix
values_	PsimagLite/src/SampleCRSMatrix.h	/^		std::vector<T> values_;$/;"	m	class:PsimagLite::SampleCRSMatrix
values_	PsimagLite/src/SparseRow.h	/^		std::vector<ValueType> values_;$/;"	m	class:PsimagLite::SparseRow
vectorPrint	PsimagLite/src/Vector.h	/^	void vectorPrint(std::vector<T> const &v,char const *name,std::ostream &s)$/;"	f	namespace:PsimagLite
vectors	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, std::vector<double> >          vectors;$/;"	m	class:dca::JSN
version	PartialPsimag/XMLHeading.h	/^    std::string version;$/;"	m	class:psimag::XMLHeading
verticies	PartialPsimag/Symmetry/SpaceGroup2D.h	/^    std::vector<CellPositionType>           verticies;$/;"	m	class:psimag::SpaceGroup
verticies	PartialPsimag/Symmetry/SpaceGroupData2D.h	/^    static const std::vector<CellPositionType> verticies() {$/;"	f	class:psimag::SpaceGroupData
vkF	ferminator.h	/^		VectorType deltakF,vkF,gammaB1GkF;$/;"	m	class:rpa::ferminator
vkF	pairing.h	/^		std::vector<FieldType> vkF;$/;"	m	class:rpa::pairing
vmPeak	PsimagLite/src/MemoryUsage.h	/^		long vmPeak(bool needsUpdate = true)$/;"	f	class:PsimagLite::MemoryUsage
vmSize	PsimagLite/src/MemoryUsage.h	/^		long vmSize(bool needsUpdate = true)$/;"	f	class:PsimagLite::MemoryUsage
volume	PartialPsimag/Symmetry/Lattice.h	/^    Field volume() const { return abs( det); }$/;"	f	class:psimag::Lattice
voluntaryContextSwitches	PsimagLite/src/Rusage.h	/^		long voluntaryContextSwitches() const { return rusage_.ru_nvcsw; }$/;"	f	class:PsimagLite::Rusage
w	gaps3D.h	/^        std::vector<MatrixType> w;$/;"	m	class:rpa::gap3D
wIm	gaps3D.h	/^        std::vector<MatrixType> wIm;$/;"	m	class:rpa::gap3D
wcharToClass	PsimagLite/src/JSON/JsonParser/CharacterMapper.h	/^    static CharacterClass wcharToClass(wchar_t widec) {$/;"	f	class:JsonParser::CharacterMapper
weight	PsimagLite/src/ParametersForSolver.h	/^		RealType weight;$/;"	m	struct:PsimagLite::ParametersForSolver
weight_	PsimagLite/src/ContinuedFraction.h	/^		RealType weight_;$/;"	m	class:PsimagLite::ContinuedFraction
weights	ferminator.h	/^		std::vector<std::vector<ComplexType> > weights;$/;"	m	class:rpa::ferminator
weights2	ferminator.h	/^		std::vector<std::vector<ComplexType> > weights2;$/;"	m	class:rpa::ferminator
whateverBool	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    bool           whateverBool;$/;"	m	class:JsonParser::Whatever
whateverDouble	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    double         whateverDouble;$/;"	m	class:JsonParser::Whatever
whateverInteger	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    int            whateverInteger;$/;"	m	class:JsonParser::Whatever
whateverMap	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    WhateverMap    whateverMap;$/;"	m	class:JsonParser::Whatever
whateverVector	PsimagLite/src/JSON/JsonParser/Whatever.h	/^    WhateverVector whateverVector;$/;"	m	class:JsonParser::Whatever
who_	PsimagLite/src/Rusage.h	/^		int who_;$/;"	m	class:PsimagLite::Rusage
wmax	parameters.h	/^		Field wmin,wmax;$/;"	m	class:rpa::parameters
wmax_	susceptibility.h	/^			FieldType wmin_,wmax_;$/;"	m	class:rpa::susceptibility
wmin	parameters.h	/^		Field wmin,wmax;$/;"	m	class:rpa::parameters
wmin_	susceptibility.h	/^			FieldType wmin_,wmax_;$/;"	m	class:rpa::susceptibility
writeChi0Emery	susceptibility.h	/^		void writeChi0Emery(const std::vector<std::vector<FieldType> >& qField, $/;"	f	class:rpa::susceptibility
writeChiSChiC	susceptibility.h	/^		void writeChiSChiC(std::vector<ComplexMatrixType>& chiS,$/;"	f	class:rpa::susceptibility
writeChiqTxt	chi0.h	/^		void writeChiqTxt() {$/;"	f	class:rpa::chi0q
writeChiqTxt	susceptibility.h	/^		void writeChiqTxt(VectorSuscType& chi0Matrix) {$/;"	f	class:rpa::susceptibility
writeChiqTxt2	chi0.h	/^	void writeChiqTxt2(const std::vector<std::vector<FieldType> >& qField,$/;"	f	namespace:rpa
writeFullChi0	parameters.h	/^		bool writeFullChi0;$/;"	m	class:rpa::parameters
writeFullChi0	susceptibility.h	/^			bool writeFullChi0;$/;"	m	class:rpa::susceptibility
writeGammaPPAndNorm	pairing.h	/^		void writeGammaPPAndNorm() {$/;"	f	class:rpa::pairing
writeGap	bandstructure.h	/^		void writeGap() {$/;"	f	class:rpa::bandstructure
writeKF	ferminator.h	/^	void writeKF() {$/;"	f	class:rpa::ferminator
writeMatrixElementsOnFs	pairing.h	/^	void writeMatrixElementsOnFs(){$/;"	f	class:rpa::pairing
writeParameters	parameters.h	/^			void writeParameters(std::ostream& os) {$/;"	f	class:rpa::parameters
writeVTK	PartialPsimag/Matrix.h	/^    void writeVTK(std::string fileName,$/;"	f	class:psimag::Matrix
writeVTK	PartialPsimag/MatrixLike.h	/^    void writeVTK(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
writeVTK	PartialPsimag/VectorLike.h	/^    void writeVTK(const VectorLikeType& vector,$/;"	f	namespace:psimag::VectorLike
writeVTK	PsimagLite/src/JSON/MatrixLike.h	/^    void writeVTK(const MatrixLikeType& matrix,$/;"	f	namespace:psimag::MatrixLike
writer	PsimagLite/src/JSON/JSN_Writer.h	/^      JSN& writer;$/;"	m	class:dca::JSN::KeyReference
writers	PsimagLite/src/JSON/JSN_Writer.h	/^    MapType<std::string, ThisType>                   writers;$/;"	m	class:dca::JSN
x0	PsimagLite/src/AkimaSpline.h	/^		RealType x0,x1,a0,a1,a2,a3;$/;"	m	struct:AkimaSpline::AkimaStruct
x1	PsimagLite/src/AkimaSpline.h	/^		RealType x0,x1,a0,a1,a2,a3;$/;"	m	struct:AkimaSpline::AkimaStruct
xIntercept	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,2> xIntercept(const SeitzPosition<Field,2>& position1, $/;"	f	namespace:psimag
x_	PsimagLite/src/Sort.h	/^			const std::vector<PairType>& x_;$/;"	m	class:Sort::Compare
yIntercept	PartialPsimag/Symmetry/SeitzPosition.h	/^  SeitzPosition<Field,2> yIntercept(const SeitzPosition<Field,2>& position1, $/;"	f	namespace:psimag
y_	PsimagLite/src/ChebyshevSolver.h	/^			mutable VectorType y_;$/;"	m	class:PsimagLite::ChebyshevSolver::InternalMatrix
y_	PsimagLite/src/LinearPrediction.h	/^		std::vector<FieldType> y_;$/;"	m	class:PsimagLite::LinearPrediction
z_	PsimagLite/src/LanczosVectors.h	/^		VectorType z_;$/;"	m	class:PsimagLite::LanczosVectors
~CartesianRotation	PartialPsimag/Symmetry/CartesianRotation.h	/^    ~CartesianRotation() {$/;"	f	class:psimag::CartesianRotation
~CellRotation	PartialPsimag/Symmetry/CellRotation.h	/^    ~CellRotation() {$/;"	f	class:psimag::CellRotation
~ConcurrencyMpi	PsimagLite/src/ConcurrencyMpi.h	/^		~ConcurrencyMpi()$/;"	f	class:PsimagLite::ConcurrencyMpi
~CrsMatrix	PsimagLite/src/CrsMatrix.h	/^		~CrsMatrix() {  }$/;"	f	class:PsimagLite::CrsMatrix
~GeometryFactory	PsimagLite/src/Geometry/GeometryFactory.h	/^		~GeometryFactory()$/;"	f	class:PsimagLite::GeometryFactory
~In	PsimagLite/src/IoSimple.h	/^				~In() { fin_.close(); }$/;"	f	class:PsimagLite::IoSimple::In
~LanczosVectors	PsimagLite/src/LanczosVectors.h	/^		~LanczosVectors()$/;"	f	class:PsimagLite::LanczosVectors
~Lattice	PartialPsimag/Symmetry/Lattice.h	/^    ~Lattice() {$/;"	f	class:psimag::Lattice
~Mat	PartialPsimag/Symmetry/Mat/Mat.h	/^    ~Mat() {}$/;"	f	class:psimag::Mat
~Matrix	PartialPsimag/Matrix.h	/^    ~Matrix() { kill(); }$/;"	f	class:psimag::Matrix
~Minimizer	PsimagLite/src/Minimizer.h	/^		~Minimizer()$/;"	f	class:PsimagLite::Minimizer
~Out	PsimagLite/src/IoSimple.h	/^			~Out()$/;"	f	class:PsimagLite::IoSimple::Out
~Profiling	PsimagLite/src/Profiling.h	/^			~Profiling()$/;"	f	class:PsimagLite::Profiling
~SymmetryElement	PartialPsimag/Symmetry/SymmetryElement.h	/^    virtual ~SymmetryElement() {}$/;"	f	class:psimag::SymmetryElement
~Vec	PartialPsimag/Vec.h	/^    ~Vec() $/;"	f	class:psimag::Vec
